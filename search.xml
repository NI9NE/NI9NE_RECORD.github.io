<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[框架开发-Laravel]]></title>
    <url>%2F2018%2F11%2F12%2F%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-Laravel%2F</url>
    <content type="text"><![CDATA[0. 准备姿势 (安装部署) composer(依赖管理工具) 安装/使用1.1. composer下载 1`https://getcomposer.org` [composer官网] 1.2. 环境检查1.3. 安装1.4. 源地址问题 1`https://developer.aliyun.com/composer` [Composer 阿里镜像] 1.5. 使用composer 12PS. 下载量最高的 100 个 Laravel 扩展包推荐https://github.com/summerblue/laravel-package-top-100 Laravel安装 2.0 Laravel被称为“全栈”式框架,因为它能够处理从网络服务到数据库管理、HTML生成的一切事情,垂直集成的web开发环境给开发者提供了更好的体验 Laravel是一套简洁、优雅的PHP Web开发框架(PHP Web Framework)。它可以让你从面条一样杂乱的代码中解脱出来；它可以帮你构建一个完美的网络APP，而且每行代码都可以简洁、富于表达力。 2.1. 选择Lravel框架的版本 与 运行环境 Laravel 版本计划 LTS 与 非LTS LTS意为: Long Time Support. 非LTS: 更新频繁. 12345678910Laravel 5.1 LTS – 2015 年 6 月份 LTS 长久支持版本，Bug修复直到2017年6月份，安全修复直到2018年6月份.Laravel 5.2 – 2015 年 12 月份 一般发行版，提供6个月的Bug修复支持，一年的安全修复支持.Laravel 5.3 – 2016 年 8 月份 一般发行版，提供6个月的Bug修复支持，一年的安全修复支持.Laravel 5.4 – 2017 年 1 月份 一般发行版，提供6个月的Bug修复支持，一年的安全修复支持.Laravel 5.5 LTS – 2017 年 7 月份 下一个版本的LTS版本，会停止Laravel 5.1的Bug修复，安全修复直到2018年7月份. 2.2. 安装Laravel 123456`http://laravelacademy.org`1). 通过Composer 安装 Laravel 安装器2). 通过Composer Create-Project 新建项目 composer create-project --prefer-dist laravel/laravel laravel-case 5.5.* 13). 复制已安装好的 laravel框架 2.3. 访问 / 配置虚拟主机 一. 初识佳人 (基本及配置) Laravel的目录结构 ![1567586616147](/images/imgs/客户端 浏览器.png) 1.1. Laravel的目录部署 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051|-- app 应用目录(程序逻辑部分)|-- bootstrap 启动和自动载入配置目录 |-- cache 存放框架启动缓存 |-- app.php 创建框架应用实例 |-- autoload.php 自动加载|-- config 配置文件目录 |-- app.php 系统级配置文件 |-- auth.php 用户身份认证配置文件 |-- broadcasting.php 事件广播配置文件 |-- cache.php 缓存配置文件 |-- compile.php 编译额外文件和类需要的配置文件,一般用户很少用到 |-- database.php 数据库配置文件 |-- filesystems.php 文件系统配置文件,这里可以配置云存储参数 |-- mail.php 电子邮件配置文件 |-- queue.php 消息队列配置文件 |-- services.php 可存放第三方服务的配置信息 |-- session.php 配置session的存储方式和生命周期等信息 |-- view.php 模板文件配置文件,包含模板目录和编译目录等|-- database 数据库迁移和填充文件目录|-- public 网站入口目录 |-- css 前端CSS文件目录 |-- js 前端JS文件目录 |-- index.php 入口文件 |-- .htaccess Apache服务器用该文件重写URL |-- web.config IIS服务器用该文件重写URL|-- resources 视图与原始资源文件目录 |-- assets 可存放包含LESS、SASS、CoffeeScript在内的原始资源文件 |-- lang 本地化文件目录 |-- views 视图文件目录(view层文件就在这里)|-- routes 路由目录(3种路由文件) |-- web.php 包含的路由都会应用web中间件组 |-- api.php 包含的路由应用了api中间件组 |-- console.php 用于定义所有基于闭包的控制台命令|-- storage 本地存储:编译后的blade模板等文件目录 |-- app 可用于存储应用程序所需的一些文件 |-- framework 该目录下包括缓存、sessions和编译后的视图文件 |-- logs 日志目录|-- tests 自动化测试目录|-- vendor Composer依赖目录(Laravel框架源码和第三方类库)|-- .env 环境配置文件|-- .env.example 环境配置文件(示例)|-- .gitattributes 用于设置文件的对比方式(GIT)|-- .gitignore 忽略文件(GIT)|-- artisan 控制台命令文件|-- composer.json Composer的依赖关系描述文件|-- composer.lock Composer的锁定版本库文件|-- gulpfile.js 前端构建工具gulp的配置文件|-- package.json npm的依赖模块配置文件|-- phpunit.xml php单元测试文件|-- readme.md 读我.md|-- server.php PHP内置web服务器的快速调试脚本 1.2. App应用目录 12345678910111213141516171819 @ 表示默认不存在,但可创建的内容 |-- Console 命令行程序目录(自定义的Artisan命令) |-- Commands 包含了用于命令行执行的类,可在该目录下自定义类 |-- Kernel.php 命令调用内核文件 |-- Exception 异常处理器 |-- Http 控制器、中间件以及表单请求等 |-- Controllers 控制器目录 |-- Middleware 中间件目录 @|-- Requests 请求类目录 |-- Kernel.php 包含http中间件和路由中间件的内核文件 |-- Providers 服务提供者:绑定服务到容器、注册事件等 User.php ORM 模型类(对象关系映射)@|-- Events 事件类目录,处理应用事件的@|-- Jobs 队列任务@|-- Listeners 事件监听器@|-- Mail 邮件发送类@|-- Notifications 应用发送的所有通知@|-- Policies 授权策略类 Laravel的配置 2.1. 开发前的一些配置 1234567891011121).目录权限问题 /storage /vendor /bootstrap/cache2).应用密钥 (APP_KEY) php artisan key:genera3).时区设置4).清空缓存 php artisan cache:clear 2.2. 开发中用到的配置 1). 环境配置文件说明 .env 2). 访问配置 3). 配置缓存 php artisan config:cache 4). 维护模式(网站一键离线功能) php artisan down php artisan up 15). 错误&amp;日志 16). HTTP 状态异常 二. 尝试接近 (路由) 路由说明 文件位置 基本路由 12345678Route::get(&apos;/get&apos;,function()&#123;&#125;); //GET方式Route::post(&apos;/post&apos;,function()&#123;&#125;); //POST方式Route::match([&apos;get&apos;,&apos;post&apos;],&apos;/&apos;,function()&#123;&#125;);//指定一组 允许的请求方式Route::any(&apos;/all&apos;,function()&#123;&#125;);//可响应所有 HTTP请求Route::put(...); //不常用Route::delete(...); //不常用Route::options(...);//不常用以上请求方式中,只有get与options不需要csrf验证 PS.1 postman 请求工具 参数路由3.1. 必选参数3.2. 可选参数3.3. 约束参数格式3.4. 多个参数 命名路由 路由组设置 当前访问的路由信息返回数组,包含路由信息$route = Route::current();路由name的名字,放在控制器里执行$name = Route::currentRouteName();控制器里action名称$action = Route::currentRouteAction(); PS.2 Laravel-Debugbar 调试工具 用于显示调试 及 错误信息 以方便开发. PS.1 postman 请求工具可指定模拟GET或POST等多种方式,去请求页面.下载Postman程序 https://www.getpostman.com/ GET方式,在URL地址栏里带参数,直接请求即可. POST方式: 要设置以下两项 Headers (请求头数据类型,同表单enctype的默认值) Body (请求体) PS.2 Laravel-Debugbar 调试工具用于显示调试 及 错误信息 以方便开发.!(只能在开发过程中 使用该扩展包:因为它会 显示框架信息 还对性能有影响) 1.安装 Debugbarbarryvdh/laravel-debugbarhttps://packagist.org/packages/barryvdh/laravel-debugbar 使用方法,请参考文档! 三. 执子之手 (中间件) 中间件介绍 创建中间件php artisan make:middleware Test 中间件功能设计 注册中间件全局中间件: $middleware中间件组: $middlewareGroups指定路由中间件: $routeMiddleware 使用中间件 CSRF保护HTML表单里设置CSRF令牌从CSRF保护中排除指定URLJQuery中的CSRF令牌处理 四. 正式交往 (控制器) 控制器介绍 创建控制器使用Artisan命令创建php artisan make:controller UserControllerphp artisan make:controller OrderController 使用路由访问控制器 普通访问 带参数访问 别名访问 单动作控制器(单功能) 控制器中间件 RESTful 资源控制器php artisan make:controller PhotoController --resource 依赖注入 &amp; 控制器 依赖注入说明 构造函数注入 方法注入 GET参数 与 路由参数 的问题 路由缓存 (基于控制器)生成路由缓存: php artisan route:cache移除路由缓存: php artisan route:clear 五. 提出要求 (HTTP请求) HTTP请求的报文的说明 基本信息获取 请求参数的获取 闪存信息 文件信息处理 六. 满足要求 (HTTP响应) 返回字串/数组/视图/json 响应-下载 跳转和重定向 七. 制造美好 (视图) 八. 人造人计划 (DB数据操作) 连接数据库 原生数据库操作 查询构建器 –]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页登录验证实现]]></title>
    <url>%2F2018%2F11%2F07%2F%E7%BD%91%E9%A1%B5%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[第三方登录/短信验证/邮箱验证 该登录注册基于tp5框架, 短信验证是基于容联云短信平台接口实现,邮件验证是通过swiftmailer插件实现 1.搭建前端页面 2.创建路由3.书写注册,登录后台逻辑代码4.创建验证器validate模块​ validata模块使用basicValidate.php作为入口,其余验证器继承实现 123456789101112131415161718192021222324252627282930&lt;?phpnamespace app\index\validate;use think\Request;use think\Validate;use think\Exception;class basicValidate extends Validate&#123; /** 获取http传入的参数,对这些参数做校验 * @return bool */ public function goCheck() &#123; //获取http传入的参数 // 对这些参数做校验 $request = Request::instance(); $params = $request-&gt;param(); $result = $this-&gt;check($params); if (!$result)&#123; $error = $this-&gt;getError(); return $error; &#125;else&#123; return true; &#125; &#125;&#125; 1234567891011121314151617181920212223class registerValidate extends basicValidate&#123; protected $rule = [ &apos;nickname&apos; =&gt; &apos;alphaDash|length:4,25&apos;, &apos;email&apos;=&gt;[&apos;regex&apos;=&gt;&apos;/^[0-9a-zA-Z-_!]&#123;2,18&#125;@[\da-zA-z]&#123;1,10&#125;\.(com|cn|net|org|edu|com\.cn|tv)$/&apos;], &apos;pwd&apos;=&gt;&apos;alphaNum|length:4,20&apos;, &apos;tel&apos;=&gt;[&apos;regex&apos;=&gt;&apos;/^1(3\d|4[5-9]|5[0-35-9]|66|7[03-8]|8\d|9[89])\d&#123;8&#125;$/&apos;], &apos;__token__&apos;=&gt;&apos;require|token&apos;, ]; protected $message = [ &apos;nickname.alphaDash&apos; =&gt; &apos;只能为字母,数字,下划线&apos;, &apos;nickname.length&apos; =&gt; &apos;用户名长度为4-25位&apos;, &apos;email.regex&apos;=&gt;&apos;邮箱格式错误&apos;, &apos;pwd.alphaNum&apos;=&gt;&apos;密码只能为数字字母组成&apos;, &apos;pwd.length&apos;=&gt;&apos;密码长度为4-20位&apos;, &apos;tel.regex&apos;=&gt;&apos;手机号格式错误&apos;, &apos;__token__.require&apos;=&gt;&apos;非法提交&apos;, &apos;__token__.token&apos;=&gt;&apos;请不要重复提交表单&apos;, ];&#125; 5.注册页面引入图形验证及验证码功能1.1引入图形验证码功能 安装 ​ composer require topthink/think-captcha 1.* 引入页面 &lt;img onclick=&quot;this.src=&#39;{:captcha_src(1)}?&#39;+Math.random()&quot; src=&quot;{:captcha_src(1)}&quot; alt=&quot;captcha&quot; /&gt; 页面ajax验证 1234567891011121314151617181920function checkCode()&#123; cap = $(&apos;#capCode&apos;).val(); $.ajax(&#123; method: &apos;get&apos;, url: &quot;&#123;:url(&apos;index/index/verify&apos;)&#125;?code=&quot; + cap +&quot;&amp;id=1&quot;, async : &apos;false&apos;, dataType: &apos;json&apos;, success: function (data) &#123; console.log(data); if(data)&#123; sendMsg(); &#125;else&#123; toastr.error(&apos;验证码填写出错&apos;); &#125; &#125;, error: function () &#123; alert(&apos;AJAX1 执行失败&apos;); &#125; &#125;);&#125; 后台验证 123456789101112use think\captcha\Captcha; /**ajax检测验证码是否正确 * @param $code * @param string $id * @return mixed */ function verify($code, $id = &apos;&apos;) &#123; $captcha = new Captcha(); return $captcha-&gt;check($code, $id); &#125; 1.2引入短信验证功能 依据容联云文档引入REST.php到extend目录 页面使用ajax发送短信请求 1234567891011121314151617181920function sendMsg() &#123; tel = $(&apos;#name&apos;).val(); console.log(tel); $.ajax(&#123; method: &apos;get&apos;, url: &quot;&#123;:url(&apos;index/index/send&apos;)&#125;?tel=&quot; + tel, dataType: &apos;json&apos;, success: function (data) &#123; console.log(data); if (data.statusCode==&apos;000000&apos;) &#123; toastr.success(&apos;短信发送成功&apos;); &#125; else &#123; toastr.error(data.statusMsg); &#125; &#125;, error: function () &#123; alert(&apos;AJAX 执行失败&apos;); &#125; &#125;);&#125; 后台处理发送请求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 // ajax请求发送短信 public function send(Request $request) &#123; $get = $request-&gt;get(); $tel = $get[&apos;tel&apos;]; $server = $request-&gt;server(); // 获取用户ip $ip = $server[&apos;REMOTE_ADDR&apos;]; $userre = $this-&gt;index-&gt;checkCount($ip); if (!$userre) &#123; $data[&apos;statusMsg&apos;] = &apos;同一个ip24小时只能发送10条短信&apos;; $data[&apos;statusCode&apos;] =&quot;111111&quot;; return $data; &#125; // 生成随机的验证码, 并存储至session $code = mt_rand(1000,9999); Session::set(&apos;code&apos;,$code); // 提示时间 $time = 10; $data = [$code, $time]; $result = $this-&gt;index-&gt;sendSMS($tel, $data, 1); return $result; &#125; /** * 发送模板短信 * @param to 手机号码集合,用英文逗号分开 * @param datas 内容数据 格式为数组 例如：array(&apos;Marry&apos;,&apos;Alon&apos;)，如不需替换请填 null * @param $tempId 模板Id */ function sendSMS($to,$datas,$tempId) &#123; // 初始化REST SDK $rest = new REST(&apos;app.cloopen.com&apos;,&apos;8883&apos;,&apos;2013-12-26&apos;); // var_dump($rest);die; $rest-&gt;SetAccount(&apos;8a216da86a58af8b016a900b55cd1cb3&apos;,&apos;e4360fc2cfee49f6a5c1cb2c2fab73de&apos;); $rest-&gt;setAppId(&apos;8a216da86a58af8b016a900b56181cb9&apos;); // 发送模板短信// echo &quot;Sending TemplateSMS to $to &lt;br/&gt;&quot;; $result = $rest-&gt;sendTemplateSMS($to,$datas,$tempId); if($result == NULL ) &#123; echo &quot;result error!&quot;; return false; &#125; if($result-&gt;statusCode!=0) &#123;// echo &quot;error code :&quot; . $result-&gt;statusCode . &quot;&lt;br&gt;&quot;;// echo &quot;error msg :&quot; . $result-&gt;statusMsg . &quot;&lt;br&gt;&quot;; //TODO 添加错误处理逻辑 return $result; &#125;else&#123;// echo &quot;Sendind TemplateSMS success!&lt;br/&gt;&quot;; // 获取返回信息// $smsmessage = $result-&gt;TemplateSMS;// echo &quot;dateCreated:&quot;.$smsmessage-&gt;dateCreated.&quot;&lt;br/&gt;&quot;;// echo &quot;smsMessageSid:&quot;.$smsmessage-&gt;smsMessageSid.&quot;&lt;br/&gt;&quot;; //TODO 添加成功处理逻辑 return $result; &#125; &#125; 注意: 默认echo发送的消息可能干扰前端判断发送状态,推荐全部注释, 前端根据返回的statusCode和statusMsg来做做自己的逻辑 上线时注意要将extends 目录中的ignore文件删掉 , 不然上传不到git 1.3引入邮件验证功能 安装swiftmail ​ composer require &quot;swiftmailer/swiftmailer:^6.0&quot; 前台ajax请求发送邮件 1234567891011121314151617181920function sendMail()&#123; mail = $(&apos;#name&apos;).val(); //console.log(mail); $.ajax(&#123; method: &apos;get&apos;, url: &quot;&#123;:url(&apos;index/index/sendMail&apos;)&#125;?mail=&quot; + mail, dataType: &apos;json&apos;, success: function (data) &#123; console.log(data); if (data==1) &#123; toastr.success(&apos;确认邮件发送成功&apos;); &#125; else &#123; toastr.error(&apos;确认邮件发送失败&apos;); &#125; &#125;, error: function () &#123; alert(&apos;AJAX 执行失败&apos;); &#125; &#125;);&#125; 后台处理请求 123456789101112131415161718192021// ajax请求发送邮件public function sendMail($mail)&#123; $transport = new \Swift_SmtpTransport(&apos;smtp.163.com&apos;, 25); // 邮箱服务器 $transport-&gt;setUsername(&apos;xxx@163.com&apos;) // 邮箱用户名 -&gt;setPassword(&apos;abc123456&apos;); // 邮箱密码，有的邮件服务器是授权码 $code = mt_rand(1000,9999); Session::set(&apos;code&apos;,$code); $mailer = new \Swift_Mailer($transport); $message = (new \Swift_Message(&apos;您的验证码如下:&apos;.$code)) // 邮件标题 -&gt;setFrom([&apos;xxx@163.com&apos; =&gt; &apos;xxx有限责任公司&apos;]) // 发送者 -&gt;setTo([$mail =&gt; &apos;用户&apos;]) //发送对象，数组形式支持多个 -&gt;setBody($code); //邮件内容 $result = $mailer-&gt;send($message); return $result;&#125; 有许多网上的教程都是使用require_once来加载autoload文件, 通过composer安装后, 插件在/vendor文件夹下,不需要require/include 即可使用. 但在new的时候需要加 \ . 上线后由于阿里云服务器默认封禁25端口,就算在规则配置打开也没作用, 使用465端口, encryption 改用 ssl ,之后邮件服务才能正常实现 6.第三方登录实现1.微博https://www.bilibili.com/video/av14869349/?p=2 1.前往微博开放平台注册开发者,创建应用,获取api key和secret 2.https://open.weibo.com/wiki/SDK 下载SDK 3.拆分基础类, 放在vendor/sina/目录下, 符合tp5的命名规范 [SaeTClientV2.php] 和 [SaeTOAuthV2.php] 4.配置文件定义常量key/secret: 将其放在public/index.php 中 composer.json中写入sina路径, 执行composer dump-autoload 5.在调用微博登录的页面声明模板变量 123456use sina\SaeTClientV2;use sina\SaeTOAuthV2; $sina = new SaeTOAuthV2(WB_AKEY,WB_SKEY); $codeUrl = $sina-&gt;getAuthorizeURL(WB_CALLBACK_URL); $this-&gt;assign(&apos;code_url&apos;,$codeUrl); 页面上应用该变量 6.写接受回调函数 1234567891011121314151617 public function callback() &#123; $sina = new SaeTOAuthV2(WB_AKEY,WB_SKEY); $keys = array(); $param = Request::instance()-&gt;param();// dump($param); $keys[&apos;code&apos;] = $param[&apos;code&apos;]; $keys[&apos;redirct_uri&apos;]=WB_CALLBACK_URL; $token = $sina-&gt;getAccessToken(&apos;code&apos;,$keys);// halt($token); if ($token) &#123; Session::set(&apos;token&apos;,$token); return $this-&gt;fetch(); &#125;else&#123; return $this-&gt;error(&apos;登录授权失败&apos;); &#125; &#125; 7.铺设回调页面,获取当前用户信息,处理登录注册逻辑 123456789public function findUser()&#123; $sina = new SaeTClientV2(WB_AKEY,WB_SKEY,Session::get(&apos;token&apos;)[&apos;access_token&apos;]); $ms = $sina-&gt;home_timeline(); $uid_get = $sina-&gt;get_uid(); $uid = $uid_get[&apos;uid&apos;]; $user_message = $sina-&gt;show_user_by_id($uid); return $user_message;&#125; 2.qq1.在 QQ互联 注册开发者账号,2.创建应用,​ 审核通过后获取APPid 和 APPkey, 回调地址 3.下载PHP sdk开发包​ SDK下载 4.配置在wamp环境运行D:\wamp\www\Connect2.1\index.php 并配置 配置完成后会生成API/comm/inc.php文件, 有用 5.修改类文件将Connect2.1\API\class中的五个php类文件按照TP5的命名方式改造后放入TP5extend/qq文件夹 123- 添加namespace- 去除require_once- 文件名改为类名 6.应用12345use qq\QC; $qq = new QC(); $qqUrl = $qq-&gt;qq_login(); $this-&gt;assign(&apos;qq_code_url&apos;,$qqUrl); 7.报错处理​ 1.使用后点击报错,未定义的ROOT常量, 查看源码 , 可以看出该处是读取我们开头配置生成的comm/inc.php配置文件, 我们直接将其内容赋予Recorder类 2.点击按钮不跳转, 查看源码发现,qq_login方法是直接重定向到指点登录网址, 而不是返回url, 修改之 8.处理回调3.微信7.支付1.支付宝 2.微信支付: 用户提交订单, 商户服务器接受信息, 向微信服务器发送请求订单详情信息+商户信息(含回调) 微信服务器返回商户服务器一段字符串 商户利用qrcode生成二维码, 供用户扫码支付 用户扫码, 请求微信服务器完成订单支付 微信服务器返回支付成功或支付失败信息给商户服务器回调地址(异步)]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>接口</tag>
        <tag>TP5</tag>
        <tag>第三方登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五分钟配置好一台阿里云服务器]]></title>
    <url>%2F2018%2F10%2F27%2F%E4%BA%94%E5%88%86%E9%92%9F%E9%85%8D%E7%BD%AE%E5%A5%BD%E4%B8%80%E5%8F%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[准备工作购买阿里云服务器 , 使用微柳lamp安装环境, 选择centos6.9/php7.0 向浏览器输入IP地址 , 即可查看到微柳首页 配置cd oneinstack/ 进入文件目录 ./change_php_version.sh 执行修改PHP版本, 选择7.0 mysql配置./reset_db_root_password.sh 执行修改mysql默认密码 iptables -nvL 查看防火墙安全配置 iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT 打开3306端口 service iptables save 保存防火墙配置 mysql -u root -p 进入mysql环境 grant all privileges on *.* to NI9NE@&#39;%&#39; identified by &#39;123456&#39;; 添加mysql数据库控制用户 flush privileges; 刷新权限 exit 退出mysql 使用Navicat使用非root账户登录云服务器数据库 安装composercurl -sS https://getcomposer.org/installer | php mv composer.phar /usr/local/bin/composer composer self-update composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ 使用阿里云源 composer config -g -l 查看全局配置 安装tp5cd /data/wwwroot/default/ 移动到默认页面地址 composer create-project topthink/think=5.0.* tp5 --prefer-dist 安装tp5项目文件夹 同步本地和云端代码配置服务器Git环境git config --global user.name &quot;NI9NE&quot; 配置全局变量 git config --global user.email &quot;ni9ne@outlook.com&quot; git config -l 检查是否设置完成 cd ~/.ssh/ 进入公钥文件夹 ssh-keygen -t rsa -C &quot;ni9ne@outlook.com&quot; 生成公钥 cat id_rsa.pub 查看并复制公钥, 并添加到github账号中 ssh -T git@github.com 检测是否链接成功 提交到Gitgit init 初始化 git remote add origin git@github.com:NI9NE/thinkphp5.git 链接仓库分支 git remote -v 查看链接情况 git add . git commit -m &quot;部署tp5&quot; git push origin master 下拉代码到本地端在本地环境目录打开cmd git clone git@github.com:NI9NE/thinkphp5.git tp5 cd tp5 composer install 安装依赖 thinkphp由于被添加进ignore目录,所以没有在git中上传 , 也无法拉到本地, 所以需要重新安装依赖 配置虚拟主机]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP接口开发常用API]]></title>
    <url>%2F2018%2F10%2F25%2FPHP%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[1 接口 API接口一 返回 json 新闻接口 API地址 天行数据 http://api.tianapi.com/keji/?key=你的APIKEY&amp;num=20 请求参数: 必须参数: apikey: 必须有API密钥(url参数) num: 返回文章数量 默认10(url参数) 可选参数: rand: 是否随机获取 默认0为不随机 word: 关键字 page: 分页 默认1接口二 返回 xml 最新影讯信息 API 地址 聚合数据文档: https://www.juhe.cn/docs/api/id/942 curlcurl_init()curl_setopt()curl_exec()curl_close() 3.1 json处理json_decodejson_encode 3.2 xml处理 parseXML (XML解析器) XMLReader DOM SimpleXML 4 框架处理接口https://blockchain.info/api/exchange_rates_api 5 范例1234567891011121314151617181920212223242526272829303132eg1 -- json 数据处理: // CURL $curl = curl_init(); // var_dump($curl); $apikey = &apos;请使用你自己的APIKEY&apos;; // url 编码数据 $word = urlencode(&apos;大米&apos;); // var_dump($word);exit; $url = &apos;http://api.tianapi.com/keji/?key=&apos;.$apikey.&apos;&amp;num=20&amp;word=&apos;.$word; // URL 设置 curl_setopt($curl, CURLOPT_URL, $url); // 将curl_exec()获取的信息以字符串返回，而不是直接输出。 curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE); // CURL 执行 $data = curl_exec($curl); curl_close($curl); // 判断 处理结果 $data... // var_dump($data); // 处理 JSON 数据 $jsonObj = json_decode($data); // var_dump($jsonObj); // 提取文章信息 $newslist = $jsonObj-&gt;newslist; // var_dump($newslist); 1234567891011121314151617181920212223242526eg2 -- xml数据处理:$movieName = empty($_GET[&apos;m&apos;])?&apos;&apos;:$_GET[&apos;m&apos;];$movie = urldecode($movieName);$key = &apos;请使用自己的APIKEY&apos;;$url = &apos;http://op.juhe.cn/onebox/movie/video?key=&apos;.$key.&apos;&amp;dtype=xml&amp;q=&apos;.$movie;// CURL$curl = curl_init();// URL 设置curl_setopt($curl, CURLOPT_URL, $url);// 将curl_exec()获取的信息以字符串返回，而不是直接输出。curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);// CURL 执行$data = curl_exec($curl);$obj = simplexml_load_string($data);echo &apos;&lt;pre&gt;&apos;; // print_r($data); // print_r($obj); // var_dump($obj);echo &apos;&lt;/pre&gt;&apos;;curl_close($curl); API平台阿里云云市场: https://market.aliyun.com/天行数据: https://www.tianapi.com/聚合数据: https://www.juhe.cn/易源数据: https://www.showapi.com/百度API Store平台: http://apistore.baidu.com/七牛云: https://www.qiniu.com阿里大于(通信): https://dayu.aliyun.com/容联云通讯: http://www.yuntongxun.com/ 地图SDK:高德地图开放平台: http://lbs.amap.com/百度地图开放平台: http://lbsyun.baidu.com/ BAT:微信开放平台: https://open.weixin.qq.com/腾讯开放平台: http://open.qq.com/百度开发者中心: https://developer.baidu.com/淘宝开放平台: http://open.taobao.com/阿里云开发者平台: https://dev.aliyun.com/search.html 支付接口:支付宝开放平台(蚂蚁金服): https://open.alipay.com微信支付: https://pay.weixin.qq.com/wiki/doc/api/index.html 登录/应用类:QQ互联: https://connect.qq.com新浪微博开放平台: http://open.weibo.com/优酷开放平台: https://open.youku.com/饿了么开放平台: http://openapi.eleme.io/百度AI开放平台: https://ai.baidu.com/讯飞开放平台: http://www.xfyun.cn/百度翻译开放平台: http://api.fanyi.baidu.com/ 工具:百度富文本编辑器(UEditor):http://ueditor.baidu.com/website/ECharts 百度Javascript的图表库:http://echarts.baidu.com/蚂蚁金服数据可视化:https://antv.alipay.com/zh-cn/index.htmlBizCharts 数据可视化:https://github.com/alibaba/BizCharts PS. 精美图标 支持搜索http://www.easyicon.net/ 极验验证http://www.geetest.com/ Amaze UIhttp://amazeui.org/ MUIhttp://dev.dcloud.net.cn/mui/ zui性感的框架http://www.zui.sexy Layuihttp://www.layui.com/doc/http://layer.layui.com/]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架开发 TP5-助手函数]]></title>
    <url>%2F2018%2F10%2F21%2F%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%20TP5-%E5%8A%A9%E6%89%8B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ThinkPHP helper函数 函数 功能 参数 返回值 import() 导入所需要的类库 类库命名空间字符串($class),起始路径$$baseURL,导入文件扩展$ext bool值 load_trait() 快速导入trait trait库$class,类库扩展名$ext bool值 exception() 抛出异常 异常消息$msg,异常代码$code=0,异常类$exception 异常对象 debug() 记录时间(微秒)和内存使用情况 开始标签$start,结束标签$end,小数位$dec(等于m代表统计内存占用) 混合数据 lang() 获取语言变量值 语言变量名$name,动态变量值$vars=[],语言$lang=’’ 混合数据 config() 获取和设置配置参数 参数名$name=’’,参数值$value=null,作用域$range=’’ 混合数据 input() 获取输入数据,支持默认值和过滤 获取的变量名$key=’’,默认值$default=null,过滤方法$filter=’’ 混合数据 widget() 渲染输出 widget名称$name,传入的参数$data=[] 混合数据 model() 实例化 Model名称$name=’’,业务层名称$layer=’model’,是否添加类名后缀$appendSuffix=false \think\Model validate() 实例化验证器 验证器名称$name=’’,业务层名称$layer=’validate’,是否添加类名后缀$appendSuuffix=false \think\Validate db() 实例化数据库 操作的数据表名称(不含前缀)$name=’’,数据库配置参数$config=[],是否强制重新连接$force=false \think\db\Query controller() 实例化控制器 资源地址$name,控制层名称$layer=’controller’,是否添加类名后缀$appendSuffix=false \think\Controller action() 调用模块的操作方法 调用地址$url,调用参数(数组/字符串)$vars=[],要调用的控制层名称$layer=’controller’,是否添加类名后缀$appendSuffix=false 混合数据 vendor() 快速导入第三方框架类库,多有第三方框架的类库文件统一放到系统的vendor目录下 类库$class,类库后缀$ext=EXT bool值 dump() 浏览器良好的变量输出 变量$var,是否输出$echo=true,标签$label=null void|string url() 生成url 路由地址$url=’’,变量$vars=’’,生成的URL后缀$suffix=true,域名$domain=false url字符串 session() Session管理 session名称$name(如果为数组表示进行session设置),session值$value=’’,前缀$prefix=null 混合数据 cookie() Cookie管理 cookie名称$name(如果为数组表示进行cookie设置),cookie值$value=’’,参数$option=null 混合数据 cache() 缓存管理 缓存名称$name(如果为数组表示进行缓存设置),缓存值$value=’’,缓存参数$option=null,缓存标签$tag=null 混合数据 trace() 记录日志信息 log信息(支持字符串和数组)$log=’[think]’,日志级别$level=’log’ void|array request() 获取当前Request对象实例 输出数据$data=[],状态码$code=200,头信息$header=[],类型$type=’html’ Response view() 渲染模板输出 模板文件$template=’’,模板变量$var=[],模板替换replace=[],状态码$code=200 \think\response\View json() 获取\think\response\Json对象实例 返回的数据$data=[],状态码$code=200,头部$header=[],参数$options=[] \think\response\Json jsonp() \think\response\Jsonp 返回的数据$data=[],状态码$code=200,头部$header=[],参数$options=[] \think\response\Jsonp xml() 获取\think\response\Xml对象实例 返回的数据$data=[],状态码$code=200,头部$header=[],参数$options=[] \think\response\Xml redirect() 获取\think\response\Redirect对象实例 重定向地址$url=[],额外参数$params=[],状态码$code=302,隐式转换$with=[] \think\response\Redirect abort() 抛出HTTP异常 状态码或Response对象实例$code,错误信息$message=null,参数$header=[] halt() 调试变量并且中断输出 调试变量或信息$var token() 生成表单令牌 令牌名称$name=’token‘,令牌生成方法$type=’MD5’ 字符串 load_relation() 延迟预载入关联查询 数据集$resultSet,关联$relation 数组 collection() 数组转换为数据集对象 数据集数组$resultSet \think\model\Collection或者\think\Collection]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>ThinkPHP5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架开发-composer]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-composer%2F</url>
    <content type="text"><![CDATA[composer(依赖管理工具) 安装/使用1.1. composer下载12`https://getcomposer.org` [composer官网]`https://developer.aliyun.com/composer` [Composer 阿里镜像] 1.2. 环境检查1php -version 1.3. 安装1234567891011window: 下载并运行 Composer-Setup.exeLinux 和 Mac OS X 中运行如下命令: curl -sS https://getcomposer.org/installer | php mv composer.phar /usr/local/bin/composer 或: wget https://dl.laravel-china.org/composer.phar -O /usr/local/bin/composer chmod a+x /usr/local/bin/composer更新: composer self-update 1.4. 源地址设置12345678910111213141516171819添加镜像源配置: 阿里云 Composer 全量镜像（推荐） 镜像类型：全量镜像 更新时间：1 分钟 官方地址：https://developer.aliyun.com/composer 镜像说明：阿里云 CDN 加速，更新速度快，推荐使用 `composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/` 安畅网络镜像 镜像类型：全量镜像 更新时间：1 分钟 官方地址：https://php.cnpkg.org/ 镜像说明：此 Composer 镜像由安畅网络赞助，目前支持元数据、下载包全量代理。 `composer config -g repos.packagist composer https://php.cnpkg.org`删除镜像配置 `composer config -g --unset repos.packagist`查看配置 `composer config -g -l` 1.5. 使用composer​ https://packagist.org [composer包列表] 安装 ThinkPHP 5.0 Thinkphp官网http://www.thinkphp.cn 使用composer安装composer create-project topthink/think=5.0.* tp5 –prefer-dist 使用GIT安装ThinkPHP 远程仓库GitHub:应用项目：https://github.com/top-think/think 核心框架：https://github.com/top-think/framework码云:应用项目： https://gitee.com/liu21st/thinkphp5 核心框架： https://gitee.com/liu21st/framework.git ##]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架开发-TP5]]></title>
    <url>%2F2018%2F10%2F10%2F%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-TP5%2F</url>
    <content type="text"><![CDATA[一. 初识佳人 (ThinkPHP 5.0 基本)TP5 环境要求PHP &gt;= 5.4.0PDO PHP Extension PDO类MBstring PHP Extension 多字节字符串函数 查询文档手册中mb字符串函数 CURL PHP Extension 钩子/爬虫 目录结构1).部署框架 目录结构 12345678910111213tp5├─application 应用目录├─extend 扩展类库目录（可定义）├─public 网站对外访问目录├─runtime 运行时目录（可定义）(linux777权限)├─vendor 第三方类库目录（Composer）├─thinkphp 框架核心目录├─build.php 自动生成定义文件（参考）├─composer.json Composer定义文件├─LICENSE.txt 授权说明文件├─README.md README 文件└─think 命令行工具入口!(如果在linux环境下面的话,需要给runtime目录755权限) 1PS. 几个关键的路径: 123456目录 说明 常量tp5 项目根目录 ROOT_PATHtp5/application 应用目录 APP_PATHtp5/thinkphp 框架核心目录 THINK_PATHtp5/exend 应用扩展目录 EXTEND_PATHtp5/vendor Composer扩展目录 VENDOR_PATH 123-------2).核心框架 目录的结构 123456789101112131415161718├─thinkphp 框架系统目录(请只读)│ ├─lang 语言包目录│ ├─library 框架核心类库目录│ │ ├─think think 类库包目录│ │ └─traits 系统 traits 目录│ ├─tpl 系统模板目录(修改请保留源文件)│ ││ ├─.htaccess 用于 apache 的重写│ ├─.travis.yml CI 定义文件│ ├─base.php 框架基础文件│ ├─composer.json composer 定义文件│ ├─console.php 控制台入口文件│ ├─convention.php 惯例配置文件│ ├─helper.php 助手函数文件（可选）│ ├─LICENSE.txt 授权说明文件│ ├─phpunit.xml 单元测试配置文件│ ├─README.md README 文件│ └─start.php 框架引导文件 123-------3).默认应用 目录结构: 1234567891011121314├─application 应用目录（可设置）│ ├─index 模块目录(可更改)(可多模块)│ │ ├─config.php 模块配置文件│ │ ├─common.php 模块公共文件│ │ ├─controller 控制器目录│ │ ├─model 模型目录│ │ └─view 视图目录│ ││ ├─command.php 命令行工具配置文件│ ├─common.php 应用公共文件│ ├─config.php 应用配置文件│ ├─tags.php 应用行为扩展定义文件│ ├─database.php 数据库配置文件│ └─route.php 路由配置文件 架构总览生命周期入口文件 / 公共资源说明public/static中的gitignore文件声明了所有该文件中的数据全部不会上传到git 方便采用本地调试 , 远程部署的设计结构(CDN服务/OSS) URL访问调试模式配置: 编程过程中只需要关注应用配置和模块配置就够了 application/config.php中配置 ​ 开发过程中开启app_debug, app_trace(配置位置为console台), ​ 注意: 上线后必须将配置还原; 该配置打开可能会影响接口的调试和正常运行 phpstorm中可以完成git操作,并配合码云安装IDEA插件 控制器新建模块 php think build --module admin新建控制器 php think make:controller admin/User --plain 视图 PHPstorm快捷键: ​ 美化 :Ctrl+Alt+L ​ Ctrl+Alt+Shift+L 二. 尝试接近 (CURD 操作 Db类)数据库配置application/database.php 本地使用时使用服务器ip , 和服务器专用账号, 上传时修改为本地ip 3306 表前缀 查询数据1234567891011use think\Db; //原生sql$list = Db::query(&apos;select * from users&apos;);$list = Db::query(&apos;select * from users where id=?&apos;, [3]);//DB类$list = Db::table(&apos;users&apos;)-&gt;order([&apos;id&apos;=&gt;&apos;desc&apos;])-&gt;select();//助手函数(无需use think\Db 也可以使用)$list = db(&apos;users&apos;)-&gt;order([&apos;id&apos;=&gt;&apos;desc&apos;])-&gt;select(); 新增数据123456789101112//原生sql$list = Db::execute(&quot;insert into users (id, name, age) values (null,&apos;西格玛&apos;,&apos;22&apos;)&quot;);$list = Db::execute(&apos;insert into users (id, name, age) values (:id, :name, :age)&apos;, [&apos;id&apos; =&gt; null, &apos;name&apos; =&gt; &apos;tiger&apos;, &apos;age&apos; =&gt; 13]);//DB类$list = Db::table(&apos;users&apos;)-&gt;data([&apos;name&apos;=&gt;&apos;cat&apos;,&apos;age&apos;=&gt;22])-&gt;insert();$list = Db::table(&apos;users&apos;)-&gt;insert([&apos;name&apos;=&gt;&apos;cat&apos;,&apos;age&apos;=&gt;22]);$list = Db::table(&apos;users&apos;)-&gt;insertGetId([&apos;name&apos;=&gt;&apos;cat1&apos;,&apos;age&apos;=&gt;12]);//助手函数$list = db(&apos;users&apos;)-&gt;insert([&apos;name&apos;=&gt;&apos;cat1&apos;,&apos;age&apos;=&gt;12]);$list = db(&apos;users&apos;)-&gt;insertGetId([&apos;name&apos;=&gt;&apos;cat3&apos;,&apos;age&apos;=&gt;12]); 删除数据12345678910//原生sql$list = Db::execute(&apos;delete from users where name=&quot;cat1&quot;&apos;);//DB类$list = Db::table(&apos;users&apos;)-&gt;delete(80); #主键才可以这么玩$list = Db::table(&apos;users&apos;)-&gt;where([&apos;name&apos;=&gt;&apos;cat&apos;])-&gt;delete();$list = Db::table(&apos;users&apos;)-&gt;where(&apos;name&apos;,&apos;cat&apos;)-&gt;delete();//助手函数$list = db(&apos;users&apos;)-&gt;where(&apos;name&apos;,&apos;tiger&apos;)-&gt;delete(); 更新数据123456789//原生sql$list = Db::execute(&apos;update users set age=33 where name=&quot;西格玛&quot;&apos;);//DB类$list = Db::table(&apos;users&apos;)-&gt;where([&apos;id&apos;=&gt;&apos;77&apos;])&gt;update([&apos;name&apos;=&gt;&apos;daboluo&apos;,&apos;age&apos;=&gt;&apos;11&apos;]);$list = Db::table(&apos;users&apos;)-&gt;where(&apos;id&apos;,77)-&gt;update([&apos;name&apos;=&gt;&apos;dalao&apos;,&apos;age&apos;=&gt;&apos;11&apos;]);//助手函数 $list = db(&apos;users&apos;)-&gt;where(&apos;id&apos;,77)-&gt;update([&apos;name&apos;=&gt;&apos;dalao01&apos;,&apos;age&apos;=&gt;&apos;11&apos;]); 若设置了表前缀功能 , 将table替换为name即可正常使用 三. 探索深入 (路由)1.默认的URL规则2.路由文件​ 1.配置文件目录 ​ application/config.php 12345推荐使用强制路由模式,配置后不再使用pathinfo格式的路径模式 // 是否开启路由 &apos;url_route_on&apos; =&gt; true, // 是否强制使用路由&apos;url_route_must&apos; =&gt; true, ​ 2.路由设置目录 ​ application/route.php 123use think\Route//设置路由格式Route::get(&apos;/&apos;,&apos;index/index/index&apos;); 3.路由概念/规则1234567从规则上区分 路由分为: 动态路由 和 静态路由 两种从设置方式上 路由分为: 动态注册 和 静态注册 两种路由规则中 包含变量的 就是动态路由,没有包含任何变量的称为静态路由.在路由文件中 return数组的 路由形式, 称之为 静态注册使用Route类的方法 注册的路由 称之为 动态注册(5.0推荐)以上两者 可同时使用. 3.定义路由12345678910111213141516use think\Route//设置路由格式Route::get(&apos;/&apos;,&apos;index/index/index&apos;); Route::post(&apos;ppp&apos;,&apos;index/index/ppp&apos;);//无参数模式Route::get(&apos;/user&apos;,&apos;index/index/user&apos;);//必须传参数模式Route::get(&apos;/user/:id&apos;,&apos;index/index/user&apos;);//可有可无参数模式Route::get(&apos;/user/[:id]&apos;,&apos;index/index/user&apos;);//匹配参数(只能匹配指定的参数,多了报错)Route::get(&apos;/user/[:id]$&apos;,&apos;index/index/user&apos;);//闭包Route::get(&apos;/user:id&apos;,function($id)&#123; //执行体&#125;); 4.闭包定义5.路由参数123// 动态注册// Route::rule(&apos;路由表达式&apos;,&apos;路由地址&apos;,&apos;请求类型&apos;,&apos;路由参数(数组)&apos;,&apos;变量规则(数组)&apos;);Route::get(&apos;/userlist&apos;,&apos;admin/user/index&apos;,[&apos;ext&apos;=&gt;&apos;html|shtml&apos;]); #限制后缀名 6.变量规则​ php think make:controller index/Blog --plain 12345678910111213若使用非路由模式,真实访问路径为:http://www.tp5.com/index/blog/index/id/123http://www.tp5.com/index/blog/read/name/naxxhttp://www.tp5.com/index/blog/article/year/2015/month/11/day/20使用路由控制Route::get(&apos;/blog/:id$&apos;,&apos;index/blog/index&apos;,[],[&apos;id&apos;=&gt;&apos;\d+&apos;]);Route::get(&apos;blog/:name$&apos;,&apos;index/blog/read&apos;,[],[&apos;name&apos;=&gt;&apos;\w+&apos;]);Route::get(&apos;/blog/:year/:month/:day&apos;,&apos;index/blog/article&apos;,[],[&apos;year&apos;=&gt;&apos;\d&#123;4&#125;&apos;,&apos;month&apos;=&gt;&apos;\d&#123;2&#125;&apos;,&apos;day&apos;=&gt;&apos;\d&#123;2&#125;&apos;]);之后的路由路径变为:http://www.tp5.com/blog/22http://www.tp5.com/blog/annahttp://www.tp5.com/blog/2015/12/12 解决路由拦截的方法有两种 , 一种是将拦截范围越大的路由越向后移, 一种是在路由路径后加 $ 截断 7.路由分组123456789101112131415161718192021// 路由分组用来处理同一个模块下的不同路由Route::group(&apos;blog&apos;, [ &apos;:id$&apos; =&gt; [ &apos;index/blog/index&apos;, [&apos;get&apos;], [&apos;id&apos; =&gt; &apos;\d+&apos;] ], &apos;:name$&apos; =&gt; [ &apos;index/blog/read&apos;, [&apos;get&apos;], [&apos;name&apos; =&gt; &apos;\w+&apos;] ], &apos;:year/:month/:day&apos; =&gt; [ &apos;index/blog/article&apos;, [&apos;get&apos;], [&apos;year&apos; =&gt; &apos;\d&#123;4&#125;&apos;, &apos;month&apos; =&gt; &apos;\d&#123;2&#125;&apos;, &apos;day&apos; =&gt; &apos;\d&#123;2&#125;&apos;] ],]); 8.生成URL地址 使用函数方法url() 或Url::bulid() 123456789101112use think\Url;echo Url::build(&apos;index/index/user&apos;,&apos;id=4444&apos;); # /user/4444.htmlecho Url::build(&apos;index/index/user&apos;,[&apos;id&apos;=&gt;&apos;43&apos;]); # /user/43.html// 多参数模式echo Url::build(&apos;index/blog/read&apos;,[&apos;name&apos;=&gt;&apos;annakalina&apos;],&apos;xhtml&apos;,true); # http://www.tp5.com/blog/annakalina.xhtmlecho Url::build(&apos;index/blog/read&apos;,[&apos;name&apos;=&gt;&apos;annakalina&apos;],&apos;xhtml&apos;,&apos;www.hao123.com&apos;); # http://www.hao123.com/blog/annakalina.xhtmlecho Url::build(&apos;index/blog/read@www.hao123.com&apos;,[&apos;name&apos;=&gt;&apos;annakalina&apos;],&apos;xhtml&apos;); # http://www.hao123.com/blog/annakalina.xhtml 第一个参数为pathinfo路径 , 第二个参数为参数 , 第三个参数为扩展名 , 第四个参数为域名(true表示当前域名 , 也可以写入其他域名) 四. 正式交往 (控制器)控制器概念 接收路由分配过来的请求 接收各种的参数 调用模型 取得数据 调用模版 输出页面 业务逻辑 流程控制/分支/循环. 业务分层 控制器的定义控制器初始化 __construct()可能覆盖掉继承的父类同名方法, 应使用tp5中的_initialize()方法 前置操作: $beforeActionList 12345678// [&apos;except&apos; =&gt; &apos;方法名,方法名&apos;] #除了指定的方法之外都执行// [&apos;only&apos; =&gt; &apos;方法名,方法名&apos;] #只有指定的方法可以执行// 实例:protected $beforeActionList = [ &apos;first&apos;, &apos;second&apos; =&gt; [&apos;except&apos;=&gt;&apos;hello&apos;], &apos;third&apos; =&gt; [&apos;only&apos;=&gt;&apos;hello,data&apos;],] 跳转和重定向 页面 跳转(存在缓冲时间)jump 123use think\Controller;return $this-&gt;success(&apos;程序执行成功&apos;,&apos;admin/user/index&apos;);return $this-&gt;error(&apos;程序执行失败&apos;,&apos;admin/user/index&apos;); 第二个参数在路由表中包含指定路由的情况下可以直接写pathinfo路径 12345678910更改固有模板模板路径: thinkphp/tpl/dispatch_jump.tpl复制到模板所在目录,修改模板所在目录config.php文件//配置文件return [ &apos;dispatch_error_tmpl&apos; =&gt; APP_PATH . &apos;admin/view/index/jump.html&apos;,//默认成功跳转对应的模板文件 &apos;dispatch_success_tmpl&apos; =&gt; APP_PATH . &apos;admin/view/index/jump.html&apos;,];即完成了更换模块模板文件的操作 重定向(直接转)redirect 123use think\Controller;return $this-&gt;redirect(&apos;index/index/user&apos;,&apos;id=5&apos;);return $this-&gt;redirect(&apos;http://bilibili.com&apos;); 空操作空控制器 对于混合路由有效 , 访问到不存在的方法和类时触发 五. 执子之手 (增删改查 用户管理实例 RESTful资源控制器) 生成 rest模块的 User资源控制器php think build --module restphp think make:controller rest/User RESTful架构说明www.ruanyifeng.com/blog/2011/09/restful.htmlwww.ruanyifeng.com/blog/2014/05/restful_api.htmlwww.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html 注册资源路由12在路由表中添加Route::resource(&apos;users&apos;,&apos;rest/user&apos;); 123456789101112131415161718192021// 动态注册// Route::rule(&apos;路由表达式&apos;,&apos;路由地址&apos;,&apos;请求类型&apos;,&apos;路由参数（数组）&apos;,&apos;变量规则（数组）&apos;); 路由规则:URL访问规则（包括静态规则和动态规则）,只有符合规则的路由才能正确访问; 路由地址:实际访问的地址（可以是控制器操作、类的方法或者闭包）; 请求类型:表示当前路由生效使用的请求类型,包括GET/POST/PUT/DELETE等,如果希望任何请求都能访问使用*号（默认值）。 路由参数:路由匹配的条件约束或设置参数（用于检测或者解析）; 路由变量:路由规则里面的动态变量以及PATH_INFO里面的参数都称之为路由变量; 变量规则:路由规则中的变量的匹配规则（正则表达式）; 支持任意请求规则 Route::rule(&apos;new/:id&apos;,&apos;News/update&apos;); 定义GET请求路由规则 Route::get(&apos;new/:id&apos;,&apos;News/read&apos;); 定义POST请求路由规则 Route::post(&apos;new/:id&apos;,&apos;News/update&apos;); 定义PUT请求路由规则 Route::put(&apos;new/:id&apos;,&apos;News/update&apos;); 定义DELETE请求路由规则 Route::delete(&apos;new/:id&apos;,&apos;News/delete&apos;); 所有请求都支持的路由规则 Route::any(&apos;new/:id&apos;,&apos;News/read&apos;); RESTful实例 index 显示资源列表 create 显示创建资源表单页 save 保存新建的资源 read 显示指定的资源 edit 显示编辑资源表单页 update 保存更新的资源 delete 删除指定资源 使用实例12345678910111213141516// 在User.php中获取数据,并使用模板 $list = Db::name(&apos;user&apos;) -&gt;field([&apos;id&apos;, &apos;name&apos;]) -&gt;order(&apos;id&apos;, &apos;asc&apos;) -&gt;select(); return view(&apos;user/index&apos;, [ &apos;title&apos; =&gt; &apos;用户列表&apos;, &apos;list&apos; =&gt; $list, ]);// 在本模块view目录下创建模板(view/user/index.html)// 引入css,js文件 &#123;css href=&quot;./static/css/bootstrap.min.css&quot;&#125; &#123;css href=&quot;__INDEX__rest.css&quot;&#125; &#123;js href=&quot;__JS__jquery.min.js&quot;&#125; &#123;js href=&quot;__JS__bootstrap.min.js&quot;&#125; 12345678 #引入文件时或在配置中定义常量// 视图输出字符串内容替换 &apos;view_replace_str&apos; =&gt; [ &apos;__INDEX__&apos; =&gt; &apos;/static/index/&apos;, &apos;__CSS__&apos; =&gt; &apos;/static/index/css/&apos;, &apos;__JS__&apos; =&gt; &apos;/static/index/js/&apos;, ], 则变为&#123;css href=&quot;__CSS__bootstrap.min.css&quot;&#125; 注意: 在模板中使用PHP函数时需要在其前添加冒号 ​ {:url()} 遍历 {volist name=&quot;list&quot; key=&quot;k&quot; id=&quot;v&quot;}{/volist} 12345678phpstorm快捷键Alt+J 快速多选后面的选中元素Ctrl+Alt+L 快速格式化代码Ctrl+D 复制指定代码行Ctrl+Shift+↑/↓ 上下移动代码位置Alt+←/→ 切换代码窗口Alt+↑/↓ 快速切换方法 六. 人造人计划 (数据库 Db类)数据库使用的补充使用框架开发应用，一般不需要 直接操作数据库，而是通过 框架封装好的 数据库中间层 对数据库进行操作。这样的好处 主要有两个：一是简化数据库操作，二是做到跨数据库的一致性。 这种设计的中间层 通常称之为 数据库访问抽象层，简称数据访问层（DAL），ThinkPHP5的数据访问层 是基于PHP内置的PDO对象实现。一般抽象层本身 并不直接操作数据库，而是通过 驱动来实现具体的数据库操作。 php think make:controller admin/Test –plain 查询相关2.1. 快捷查询2.2. 批量查询2.3. 区间查询2.4. 多表查询 1). 手动多表 2). JOIN 3). 视图2.5. 聚合查询2.6. 子查询 1.fetchSql 方式 2.buildSql 方式 七. 新生 (模型 Model)ThinkPHP5.0的模型是一种对象-关系映射（Object/Relation Mapping，简称ORM）的封装，并且提供了简洁的ActiveRecord实现。一般来说，每个数据表会和一个“模型”对应。 ORM的基本特性就是表映射到模型，记录映射到模型对象实例，字段映射到对象属性。 模型是一种对象化的操作封装，而不是简单的CURD操作，简单的CURD操作直接使用前面提过的Db类即可。 模型类和Db类的区别主要在于对象及业务逻辑的封装，Db类的查询默认返回的是数组（或者集合），而模型类返回的是当前的模型对象实例（或者集合），模型是比Db类更高级的数据封装，支持模型关联、模型事件和业务（逻辑）方法。 php think make:model rest/User]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>ThinkPHP5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架开发-PSR/命名空间/trait/smarty]]></title>
    <url>%2F2018%2F09%2F30%2F%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-PSR%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%20trait%2F</url>
    <content type="text"><![CDATA[PSR 编码规范12PHP编码规范PSR（中文版）https://github.com/PizzaLiu/PHP-FIG ==================================== PDO 复习 PDO 实例化PDO DSN: mysql:host=127.0.0.1;dbname=xx 设置PDO的连接属性: setAttribute() 是否自动提交属性PDO::ATTR_AUTOCOMMIT值0 关闭 / 1 开启 SQL错误处理方式属性PDO::ATTR_ERRMODE值PDO::ERRMODE_SILENT 无提示(默认) PDO::ERRMODE_WARNING 报错WARNING PDO::ERRMODE_EXCEPTION 抛出异常 返回结果集的形式属性PDO::ATTR_DEFAULT_FETCH_MODE值PDO::FETCH_ASSOC 关联 PDO::FETCH_NUM 索引 PDO::FETCH_OBJ 对象 PDO::FETCH_BOTH 混合 PDO的增删改查exec() 返回受影响行数 用于增删改query() 返回PDOStatement的实例 用于查询处理查询结果集fetch() 单条数据/一维数组 fetchAll() 所有数据/二维数组 使用foreach遍历PDOStatement对象 PDO对象setAttribute() 设置连接属性getAttribute() 获取连接属性exec() 返回受影响行数query() 返回查询结果集对象lastInsertId() 返回自增ID PDOStatement对象fetch() 单条数据fetchAll() 所有数据rowCount() 受影响行数 预处理 预处理的优点 对用户的数据 进行过滤 提高安全性 提高批量操作的性能 SQL的占位符 ? : 绑定参数 bindValue() bindParam() execute() 结果集的预处理 bindColumn() 1234567891011- 事务操作 将多条 SQL操作(增删改),作为一个 整体单元 来操作. 都执行成功 则成功,有一条失败 则都失败. InnoDB 支持事务 / 行锁机制 begin 开启一个事务的回滚点 rollback 回滚一个事务,回到begin前的状态 commit 提交一个事务,只有被提交的事务,才会被写入表中 MySQL 默认是开启 自动提交的. ==================================== 命名空间 (php 5.3 +) 命名空间概述 定义命名空间 语法 namespace 命名空间名称;特点 1. namespace 需要 php 5.3 + 2. namespace 前面不允许有任何的代码(除了namespace自己) 它的作用范围 到下一个命名空间开始 或 脚本结束 为止 3. namespace 只对本脚本起作用 4. 文件里如果没有定义命名空间,则默认在全局空间之中 定义子命名空间 namespace a\b\c\d… 在同一个文件中 定义多个命名空间 不推荐 一般一个文件中只有一个命名空间 万不得已 建议使用 {} 将对应的代码包裹 使用命名空间：基础 非限定名称 直接使用函数/类/常量,没有命名空间成分限定名称 有命名空间成分,但是不以反斜线开头的. (类似于相对路径)完全限定名称 以反斜线开头,又有命名空间成分. (类似于绝对路径) 命名空间 和 动态语言特征 如果把 函数名/类名/常量名 赋值给变量使用在命名空间里 必须使用完全限定名称PS. 注意完全限定名称时,必须使用单引号. namespace 关键字 和 NAMESPACE 常量 namespace 关键字 定义命名空间 用来简化调用 NAMESPACE 常量 获取本命名空间的名字 ::class 自 PHP 5.5 起，关键词 class 也可用于类名的解析。 使用 ClassName::class 你可以获取一个字符串，包含了类 ClassName 的完全限定名称。 这对使用了 命名空间 的类尤其有用。 使用命名空间：别名/导入别名 use 命名空间 [as 别名];导入 use 命名空间\类名 [as 别名]; 只能导入类 不能导入函数 全局空间 namespace {} 使用命名空间：后备全局函数/常量 命名空间的实用 ============================================== Trait (php 5.4 +) Trait的概述Trait 是 PHP5.4 中的新特性，是 PHP 多重继承的一种解决方案。例如，需要同时继承两个类或抽象类，这将会是件很麻烦的事情，Trait 就是为了解决这个问题。 Trait的简单使用格式: trait 名字 { 属性 + 方法}特点: 1. 不能有常量 2. 不能被实例化的 3. 在类中 使用use关键字 来混入trait 多个Trait的引用 use A,B; Trait之间的嵌套 一个trait可以由多个trait组成可以在trait中 使用use … Trait的属性 在trait中 可以定义属性并且可以使用但是在使用了use 的类中,不允许重复定义与trait同名的属性 Trait的方法优先级 class 中 如果有和trait重名的方法 则class附带trait继承时,trait方法会覆盖class的同名方法 Trait的修饰符static 静态的属性只能静态读取,静态的方法可以 动/静 态调用abstract 如果在trait中有抽象方法 则 在use的类中必须实现才可使用 Trait冲突 代替insteadof 指定替代的方法 起别名使用 as 给方法起别名 模版引擎 什么是模板引擎 1.1 定义 模板引擎实现 前后端的分离1.2 优势 分工明确 程序灵活性 代码可读性 提高开发效率1.3 问题 会降低执行效率1.4 模板引擎分类 编译型 解释型 置换型 选择 smarty 模板引擎 2.1 为什么选择smarty 1). 编译型 速度较快 2). php 官方推荐2.2 smarty 优势 1). 开源 2). 插件机制 3). 模板继承 4). 缓存控制 安装smarty及初始化配置 3.1 获取smarty http://www.smarty.net/3.2 搭建smarty入口文件 1). 导入smarty 2). 实例化smarty 3). 初始化 配置 配置 模板文件 目录 配置 编译文件 目录 配置 配置文件 目录 配置 缓存文件 目录 配置 模板变量的定界符 配置 缓存控制 (开启缓存/缓存时间) 4). 分配变量 assign() 5). 加载模板 display() smarty的基本应用 4.1 程序员(PHP) 1). smarty初始化配置 2). 运算操作： 数据库 文件， 数据计算... 3). 缓存控制， 插件扩展...4.2 美工(模版) 1). 把模板变量放在指定的位置 2(). 其他操作： 遍历数据、 模板函数... smarty设计的基本语法 5.1 注释 `{**}`5.2 模板中路径问题 模版文件中所有的相对路径 都相对于 PHP定位 link/script/img/a5.3 模板中读取变量 输出规则 同 echo 一致5.4 在模板中定义变量 {assign var=&quot;&quot; value=&quot;&quot;} {assign &quot;param&quot; &quot;value&quot;} {$param = value}5.5 忽略解析 {literal}{/literal} smarty模板中的变量应用 6.1 在模板中遍历 数组 {foreach}{/foreach} {section}{/section}6.2 模板中读取内置变量(保留变量) 12345678910111213&#123;smarty.post&#125; POST&#123;smarty.get&#125; GET&#123;smarty.request&#125; 请求数据&#123;smarty.session&#125; SESSION&#123;smarty.cookies&#125; COOKIE&#123;smarty.server&#125; 服务器信息&#123;smarty.const&#125; 常量&#123;smarty.version&#125; Smarty版本&#123;smarty.template&#125; 模板文件&#123;smarty.current_dir&#125; 模板文件目录&#123;smarty.now&#125; 当前时间&#123;smarty.ldelim&#125; 左定界符&#123;$smarty.rdelim&#125; 右定界符 缓存控制 7.1 缓存的配置 caching 是否开启缓存 cache_lifetime 缓存时间 cache_dir 缓存目录7.2 默认 一个模板 对应一个缓存 7.3 一个模板 产生 多个缓存 display(url, 缓存号); 12345677.4 为缓存 减少开销 isCached(url, 缓存号);7.5 清除缓存 clearCache(url, 缓存号); clearCache(url); clearAllCache(); 模板继承{extends file=””}{block name=””}{/block} 内置函数9.1 内置函数 {include} {config_load} {extends}9.2 内置块状函数 {foreach}{/foreach} {if}{/if} {block}{/block} smarty模板引擎 版本不同,对于PHP的支持也不相同 , 推荐使用3.1.10版本 新建工作目录: 123/emplates/i.html/emplates/.htaccess(Apache的分布式配置文件)/libs(smarty库) 配置.htaccess文件,闲置用户直接访问模板引擎 1deny from all 创建基础配置文件init.php 123456789101112131415161718192021222324// 1). 导入smartyrequire &apos;./libs/Smarty.class.php&apos;;// 2). 实例化smarty$smarty = new Smarty();// var_dump($smarty);// 3). 初始化 配置// 配置 模板文件 目录$smarty-&gt;template_dir = &apos;./templates&apos;;// 配置 编译文件 目录$smarty-&gt;compile_dir = &apos;./templates_c&apos;;// 配置 配置文件 目录$smarty-&gt;config_dir = &apos;./configs&apos;;// 配置 缓存文件 目录$smarty-&gt;cache_dir = &apos;./caches&apos;;// 配置 模板变量的定界符 // 原有定界符为&#123;&#125;,可能会和css及js使用冲突,建议修改// 通常使用&#123;&#123; &#125;&#125;或&lt;&#123; &#125;&gt; 甚至&lt;!-- --&gt; 或 &lt;&lt; &gt;&gt;$smarty-&gt;left_delimiter = &apos;&#123;&#123;&apos;;$smarty-&gt;right_delimiter = &apos;&#125;&#125;&apos;;// 配置 缓存控制 (开启缓存/缓存时间) #不设置时间默认一个小时$smarty-&gt;caching = false; #默认false关闭$smarty-&gt;cache_lifetime = 10; #设置10s 创建入口文件index.php 123456789require &apos;./init.php&apos;;// 4). 分配变量 assign()$smarty-&gt;assign(&apos;title&apos;,&apos;标题&apos;);$smarty-&gt;assign(&apos;content1&apos;,&apos;内容1&apos;);$smarty-&gt;assign(&apos;content2&apos;,&apos;内容2&apos;);$smarty-&gt;assign(&apos;content3&apos;,&apos;内容3&apos;);$smarty-&gt;assign(&apos;content4&apos;,&apos;内容4&apos;);// 5). 加载模板 display()$smarty-&gt;display(&apos;./1.html&apos;); 注释: {* 注释内容 *} 路径问题: 加载css或图片路径为当前入口位置(index.php)为基准 但在加载的css文件中引用图片路径时, 是以当前css文件为基准的 输出类型 模板中所有assign输出都是echo 机制 , true被解析为1 , false被解析为空字符串 , 不能输出数组 和 对象数据 对于数组, 可以使用 {var_dump($arr)} 的格式输出 , 也可以使用 {$arr[2]} 或 {$arr.2} 读取 对于obj对象 , 首先需要$smarty-&gt;assign(&#39;obj&#39;,new User()); , 然后在html模板中使用&lt;p&gt;{$obj-&gt;name}&lt;/p&gt; 或 &lt;p&gt;{$obj-&gt;demo()}&lt;/p&gt; 调用]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>trait</tag>
        <tag>smarty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis-常用操作]]></title>
    <url>%2F2018%2F09%2F24%2FRedis%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[php操作redis常用方法1.connect 描述：实例连接到一个Redis.参数：host: string，port: int返回值：BOOL 成功返回：TRUE;失败返回：FALSE示例： 12345&lt;?php redis = new redis(); result = redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); var_dump(result); //结果：bool(true) ?&gt; 2，set描述：设置key和value的值参数：Key Value返回值：BOOL 成功返回：TRUE;失败返回：FALSE示例： 123456&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); result = redis-&gt;set(&apos;test&apos;,&quot;11111111111&quot;); var_dump($result); //结果：bool(true) ?&gt; 3，get描述：获取有关指定键的值参数：key返回值：string或BOOL 如果键不存在，则返回 FALSE。否则，返回指定键对应的value值。范例： 123456&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); result = redis-&gt;get(&apos;test&apos;); var_dump($result); //结果：string(11) &quot;11111111111&quot; ?&gt; 4，delete 描述：删除指定的键参数：一个键，或不确定数目的参数，每一个关键的数组：key1 key2 key3 … keyN返回值：删除的项数范例： 12345678&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;set(&apos;test&apos;,&quot;1111111111111&quot;); echo redis-&gt;get(&apos;test&apos;); //结果：1111111111111 redis-&gt;delete(&apos;test&apos;); var_dump(redis-&gt;get(&apos;test&apos;)); //结果：bool(false) ?&gt; 5，setnx描述：如果在数据库中不存在该键，设置关键值参数参数：key value返回值：BOOL 成功返回：TRUE;失败返回：FALSE范例： 12345678910&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;set(&apos;test&apos;,&quot;1111111111111&quot;); redis-&gt;setnx(&apos;test&apos;,&quot;22222222&quot;); echo redis-&gt;get(&apos;test&apos;); //结果：1111111111111 redis-&gt;delete(&apos;test&apos;); redis-&gt;setnx(&apos;test&apos;,&quot;22222222&quot;); echo redis-&gt;get(&apos;test&apos;); //结果：22222222 ?&gt; 6，exists描述：验证指定的键是否存在参数key返回值：Bool 成功返回：TRUE;失败返回：FALSE范例： 123456&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;set(&apos;test&apos;,&quot;1111111111111&quot;); var_dump(redis-&gt;exists(&apos;test&apos;)); //结果：bool(true) ?&gt; 7，incr描述：数字递增存储键值键.参数：key value：将被添加到键的值返回值：INT the new value实例： 1234567&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;set(&apos;test&apos;,&quot;123&quot;); var_dump(redis-&gt;incr(&quot;test&quot;)); //结果：int(124) var_dump($redis-&gt;incr(&quot;test&quot;)); //结果：int(125) ?&gt; 8，decr描述：数字递减存储键值。参数：key value：将被添加到键的值返回值：INT the new value实例： 1234567&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;set(&apos;test&apos;,&quot;123&quot;); var_dump(redis-&gt;decr(&quot;test&quot;)); //结果：int(122) var_dump($redis-&gt;decr(&quot;test&quot;)); //结果：int(121) ?&gt; 9，getMultiple描述：取得所有指定键的值。如果一个或多个键不存在，该数组中该键的值为假参数：其中包含键值的列表数组返回值：返回包含所有键的值的数组实例： 12345678&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;set(&apos;test1&apos;,&quot;1&quot;); redis-&gt;set(&apos;test2&apos;,&quot;2&quot;); result = redis-&gt;getMultiple(array(&apos;test1&apos;,&apos;test2&apos;)); print_r($result); //结果：Array ( [0] =&gt; 1 [1] =&gt; 2 ) ?&gt; 10，lpush描述：由列表头部添加字符串值。如果不存在该键则创建该列表。如果该键存在，而且不是一个列表，返回FALSE。参数：key,value返回值：成功返回数组长度，失败false实例： 1234567&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); var_dump(redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;)); //结果：int(1) var_dump($redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;)); //结果：int(2) ?&gt; 11，rpush描述：由列表尾部添加字符串值。如果不存在该键则创建该列表。如果该键存在，而且不是一个列表，返回FALSE。参数：key,value返回值：成功返回数组长度，失败false范例： 123456789&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); var_dump(redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;)); //结果：int(1) var_dump(redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;)); //结果：int(2) var_dump(redis-&gt;rpush(&quot;test&quot;,&quot;333&quot;)); //结果：int(3) var_dump($redis-&gt;rpush(&quot;test&quot;,&quot;444&quot;)); //结果：int(4) ?&gt; 12，lpop描述：返回和移除列表的第一个元素参数：key返回值：成功返回第一个元素的值 ，失败返回false范例： 12345678910&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;); redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;); redis-&gt;rpush(&quot;test&quot;,&quot;333&quot;); redis-&gt;rpush(&quot;test&quot;,&quot;444&quot;); var_dump(redis-&gt;lpop(&quot;test&quot;)); //结果：string(3) &quot;222&quot; ?&gt; 13，lsize,llen描述：返回的列表的长度。如果列表不存在或为空，该命令返回0。如果该键不是列表，该命令返回FALSE。参数：Key返回值：成功返回数组长度，失败false范例： 12345678910&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;); redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;); redis-&gt;rpush(&quot;test&quot;,&quot;333&quot;); redis-&gt;rpush(&quot;test&quot;,&quot;444&quot;); var_dump(redis-&gt;lsize(&quot;test&quot;)); //结果：int(4) ?&gt; 14，lget描述：返回指定键存储在列表中指定的元素。 0第一个元素，1第二个… -1最后一个元素，-2的倒数第二…错误的索引或键不指向列表则返回FALSE。参数：key index返回值：成功返回指定元素的值，失败false范例： 12345678910&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;); redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;); redis-&gt;rpush(&quot;test&quot;,&quot;333&quot;); redis-&gt;rpush(&quot;test&quot;,&quot;444&quot;); var_dump(redis-&gt;lget(&quot;test&quot;,3)); //结果：string(3) &quot;444&quot; ?&gt; 15，lset描述：为列表指定的索引赋新的值,若不存在该索引返回false.参数：key index value返回值：成功返回true,失败false范例： 12345678910&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;); redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;); var_dump(redis-&gt;lget(&quot;test&quot;,1)); //结果：string(3) &quot;111&quot; var_dump(redis-&gt;lset(&quot;test&quot;,1,&quot;333&quot;)); //结果：bool(true) var_dump(redis-&gt;lget(&quot;test&quot;,1)); //结果：string(3) &quot;333&quot; ?&gt; 16，lgetrange描述：返回在该区域中的指定键列表中开始到结束存储的指定元素，lGetRange(key, start, end)。0第一个元素，1第二个元素… -1最后一个元素，-2的倒数第二…参数：key start end返回值：成功返回查找的值，失败false范例： 12345678&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;); redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;); print_r(redis-&gt;lgetrange(&quot;test&quot;,0,-1)); //结果：Array ( [0] =&gt; 222 [1] =&gt; 111 ) ?&gt; 17,lremove描述：从列表中从头部开始移除count个匹配的值。如果count为零，所有匹配的元素都被删除。如果count是负数，内容从尾部开始删除。参数：key count value返回值：成功返回删除的个数，失败false范例： 123456789101112&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;lpush(&apos;test&apos;,&apos;a&apos;); redis-&gt;lpush(&apos;test&apos;,&apos;b&apos;); redis-&gt;lpush(&apos;test&apos;,&apos;c&apos;); redis-&gt;rpush(&apos;test&apos;,&apos;a&apos;); print_r(redis-&gt;lgetrange(&apos;test&apos;, 0, -1)); //结果：Array ( [0] =&gt; c [1] =&gt; b [2] =&gt; a [3] =&gt; a ) var_dump(redis-&gt;lremove(&apos;test&apos;,&apos;a&apos;,2)); //结果：int(2) print_r(redis-&gt;lgetrange(&apos;test&apos;, 0, -1)); //结果：Array ( [0] =&gt; c [1] =&gt; b ) ?&gt; 18，sadd描述：为一个Key添加一个值。如果这个值已经在这个Key中，则返回FALSE。参数：key value返回值：成功返回true,失败false范例： 12345678&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); var_dump(redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;)); //结果：bool(true) var_dump(redis-&gt;sadd(&apos;test&apos;,&apos;333&apos;)); //结果：bool(true) print_r(redis-&gt;sort(&apos;test&apos;)); //结果：Array ( [0] =&gt; 111 [1] =&gt; 333 ) ?&gt; 19，sremove描述：删除Key中指定的value值参数：key member返回值：true or false范例： 123456789&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;); redis-&gt;sadd(&apos;test&apos;,&apos;333&apos;); redis-&gt;sremove(&apos;test&apos;,&apos;111&apos;); print_r($redis-&gt;sort(&apos;test&apos;)); //结果：Array ( [0] =&gt; 333 ) ?&gt; 20,smove描述：将Key1中的value移动到Key2中参数：srcKey dstKey member返回值：true or false范例 123456789101112&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;delete(&apos;test1&apos;); redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;); redis-&gt;sadd(&apos;test&apos;,&apos;333&apos;); redis-&gt;sadd(&apos;test1&apos;,&apos;222&apos;); redis-&gt;sadd(&apos;test1&apos;,&apos;444&apos;); redis-&gt;smove(&apos;test&apos;,&quot;test1&quot;,&apos;111&apos;); print_r(redis-&gt;sort(&apos;test1&apos;)); //结果：Array ( [0] =&gt; 111 [1] =&gt; 222 [2] =&gt; 444 ) ?&gt; 21，scontains描述：检查集合中是否存在指定的值。参数：key value返回值：true or false范例： 123456789&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;); redis-&gt;sadd(&apos;test&apos;,&apos;112&apos;); redis-&gt;sadd(&apos;test&apos;,&apos;113&apos;); var_dump($redis-&gt;scontains(&apos;test&apos;, &apos;111&apos;)); //结果：bool(true) ?&gt; 22,ssize描述：返回集合中存储值的数量参数：key返回值：成功返回数组个数，失败0范例： 12345678&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;); redis-&gt;sadd(&apos;test&apos;,&apos;112&apos;); echo redis-&gt;ssize(&apos;test&apos;); //结果：2 ?&gt; 23，spop描述：随机移除并返回key中的一个值参数：key返回值：成功返回删除的值，失败false范例： 123456789&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); var_dump($redis-&gt;spop(&quot;test&quot;)); //结果：string(3) &quot;333&quot; ?&gt; 24,sinter描述：返回一个所有指定键的交集。如果只指定一个键，那么这个命令生成这个集合的成员。如果不存在某个键，则返回FALSE。参数：key1, key2, keyN返回值：成功返回数组交集，失败false范例： 1234567891011&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); var_dump($redis-&gt;sinter(&quot;test&quot;,&quot;test1&quot;)); //结果：array(1) &#123; [0]=&gt; string(3) &quot;111&quot; &#125; ?&gt; 25,sinterstore描述：执行sInter命令并把结果储存到新建的变量中。参数：Key: dstkey, the key to store the diff into.Keys: key1, key2… keyN. key1..keyN are intersected as in sInter.返回值：成功返回，交集的个数，失败false范例: 123456789101112&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); var_dump(redis-&gt;sinterstore(&apos;new&apos;,&quot;test&quot;,&quot;test1&quot;)); //结果：int(1) var_dump(redis-&gt;smembers(&apos;new&apos;)); //结果:array(1) &#123; [0]=&gt; string(3) &quot;111&quot; &#125; ?&gt; 26,sunion描述：返回一个所有指定键的并集参数：Keys: key1, key2, … , keyN返回值：成功返回合并后的集，失败false范例： 1234567891011&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); print_r($redis-&gt;sunion(&quot;test&quot;,&quot;test1&quot;)); //结果：Array ( [0] =&gt; 111 [1] =&gt; 222 [2] =&gt; 333 [3] =&gt; 444 ) ?&gt; 27,sunionstore描述：执行sunion命令并把结果储存到新建的变量中。参数：Key: dstkey, the key to store the diff into.Keys: key1, key2… keyN. key1..keyN are intersected as in sInter.返回值：成功返回，交集的个数，失败false范例: 123456789101112&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); var_dump(redis-&gt;sinterstore(&apos;new&apos;,&quot;test&quot;,&quot;test1&quot;)); //结果：int(4) print_r(redis-&gt;smembers(&apos;new&apos;)); //结果:Array ( [0] =&gt; 111 [1] =&gt; 222 [2] =&gt; 333 [3] =&gt; 444 ) ?&gt; 28,sdiff描述：返回第一个集合中存在并在其他所有集合中不存在的结果参数：Keys: key1, key2, … , keyN: Any number of keys corresponding to sets in redis.返回值：成功返回数组，失败false范例： 1234567891011&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); print_r($redis-&gt;sdiff(&quot;test&quot;,&quot;test1&quot;)); //结果：Array ( [0] =&gt; 222 [1] =&gt; 333 ) ?&gt; 29,sdiffstore描述：执行sdiff命令并把结果储存到新建的变量中。参数：Key: dstkey, the key to store the diff into.Keys: key1, key2, … , keyN: Any number of keys corresponding to sets in redis返回值：成功返回数字，失败false范例： 123456789101112&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); var_dump(redis-&gt;sdiffstore(&apos;new&apos;,&quot;test&quot;,&quot;test1&quot;)); //结果：int(2) print_r(redis-&gt;smembers(&apos;new&apos;)); //结果:Array ( [0] =&gt; 222 [1] =&gt; 333 ) ?&gt; 30,smembers, sgetmembers描述：返回集合的内容参数：Key: key返回值：An array of elements, the contents of the set.范例： 12345678&lt;?php redis = new redis(); redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); redis-&gt;delete(&apos;test&apos;); redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); print_r(redis-&gt;smembers(&apos;test&apos;)); //结果:Array ( [0] =&gt; 111 [1] =&gt; 222 ) ?&gt;]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信开发]]></title>
    <url>%2F2018%2F09%2F23%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[微信开发前提: ​ 一台云服务器 分类: 服务号 | 订阅号 | 企业号 | 小程序(Vuejs封装) ​ 订阅号 –账号主体:个人(仅仅文章,发说说)(推送一天一条消息) ​ –账号主体:公司 ​ 服务号 –单独一个聊天框 , 不在订阅号标签内(推送一个月四条) ​ 企业号 –内部管理沟通的平台 两个接口 ​ 微信支付接口 , 微信登录接口 后台: mp.weixin.qq.com 开发： 百度搜索 微信开放平台 微信登陆相关接口 微信公众平台 微信开发 ​ 认证 - 300/年 ​ 微信测试号（不认证测试开发）(一年有效期) 功能： ​ 1.自定义菜单 ​ 2.自动回复 3.展示页面高级接口: ​ 语音识别: 微信对外开放了语音识别的接口 ​ 客服接口: 可在12小时内持续对发消息用户沟通 ​ 网页授权: 可使用qq,微信登录 ​ 生成参数二维码: 分析用于来源或用户绑定 ​ 获取用户基本信息: openid 获取用户头像,名称,性别等 ​ 获取关注者列表: 获取所有关注者 ​ 用户分组接口: 为关注者分组 ​ 上传下载文件: 可将内容在自己的服务器中上传下载 环境搭建 ​ 打通自己的云服务器和微信接口平台的通道 ​ token:可以表明自己身份的令牌(同一个服务器同时支持多个微信平台) ​ 为保障安全,使用的是https协议 第三方网络服务: ​ 百度bae , 新浪sae , 腾讯云 , 各种云服务器 , 租用虚拟主机 , 自己传服务器 ​ 应用引擎(一键创建应用环境) ​ 版本控制(SVN/Git) 测试号管理： ​ 测试号信息：id+pass ​ 接口配置: 服务器url + 令牌验证token PHP编辑开发: 123456789数据交换: get/post使用的是XML/json格式 xml优势:既可以存数据,又可以存格式;可做数据交换(各种语言均可以解析) PHP函数: simplexml_load_string() 函数 作用: 将XML数据转成PHP对象 simplexml_load_string(&apos;xml字符串&apos;,&apos;对象名&apos;,&apos;参数&apos;) simlpexml_load_string($str,&apos;SimpleXMLElement&apos;,LIBXML_NOCDATA) --第三个参数为了解析传过来的xml对象数据,全部是包裹在&lt;!CDATA[]&gt;中 1234567信息格式(msgtype): 文本--text 语音--voice 视频--video 图片--image 位置--location 链接--link 12345671.上传接口代码到自己的服务器代码: 定义了tokenchangliang 将三个参数字典排序拼接为一个字符串,sha1加密,之后与第四个参数对比 返回结果给请求方2.完成接口配置3.消息管理 客服消息 php curl (在PHP中模拟浏览器发起http请求–get/post) 手册–聚合代码 代码:curl_setopt方法 12345678910111213141516171819202122232425function https_request(url,data=null)&#123; //初始化 //判断get/post //执行&#125;用处:模拟登陆|爬取数据//获取access_token(全局唯一接口调用凭据)$turl = &apos;&apos;;()接口文档模板$tres = https_request($turl);//提取返回的json数据$data = json_decode($tres,true);$access_token = $data[&apos;access_token&apos;];客服发消息接口$url = &apos;&apos;;$data=&#123; &apos;touser&apos;:&apos;OPENID&apos;, &apos;msgtype&apos;:&apos;text&apos;, &apos;text&apos;:&#123; &apos;content&apos;:&apos;内容&apos; &#125;&#125;$res=https_request($url,$data); API数据:聚合科技(www.juhe.cn) 模板消息 12345671.设置模板 &#123;&#123;first.DATA&#125;&#125; 商品名:&#123;&#123;keword1.DATA&#125;&#125; 价格:&#123;&#123;keword2.DATA&#125;&#125; 订单日期:&#123;&#123;keword3.DATA&#125;&#125; &#123;&#123;remark.DATA&#125;&#125;2.修改模板程序,填写参数 自定义菜单 3个以及菜单 , 每个一级菜单最多包含5个二级菜单 , 4 - 7 个汉字 点击事件: click 跳转url: view 扫码: scancode_push scancode_waitmsg 发送图片: pic_sysphoto 拍照/本地发送: pic_phpoto_or_album pic_weixin 弹出地理位置: location_select 发送消息: media_id 跳转图文消息: view_limited 作业: 聚合-&gt;查快递, 天气 token 提取出来 ps:代码资料1.验证token 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//define your tokendefine(&quot;TOKEN&quot;, &quot;s86&quot;); // 定义常量$wechatObj = new wechatCallbackapiTest();$wechatObj-&gt;valid();class wechatCallbackapiTest&#123; public function valid() &#123; $echoStr = $_GET[&quot;echostr&quot;]; //valid signature , option if($this-&gt;checkSignature())&#123; echo $echoStr; exit; &#125; &#125; public function responseMsg() &#123; //get post data, May be due to the different environments $postStr = $GLOBALS[&quot;HTTP_RAW_POST_DATA&quot;]; //extract post data if (!empty($postStr))&#123; /* libxml_disable_entity_loader is to prevent XML eXternal Entity Injection, the best way is to check the validity of xml by yourself */ libxml_disable_entity_loader(true); // xml 保护模式开启 $postObj = simplexml_load_string($postStr, &apos;SimpleXMLElement&apos;, LIBXML_NOCDATA); $fromUsername = $postObj-&gt;FromUserName; $toUsername = $postObj-&gt;ToUserName; $keyword = trim($postObj-&gt;Content); $time = time(); $textTpl = &quot;&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt; &lt;FuncFlag&gt;0&lt;/FuncFlag&gt; &lt;/xml&gt;&quot;; if(!empty( $keyword )) &#123; $msgType = &quot;text&quot;; $contentStr = &quot;Welcome to wechat world!&quot;; $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr); echo $resultStr; &#125;else&#123; echo &quot;Input something...&quot;; &#125; &#125;else &#123; echo &quot;&quot;; exit; &#125; &#125; private function checkSignature() &#123; // you must define TOKEN by yourself if (!defined(&quot;TOKEN&quot;)) &#123; throw new Exception(&apos;TOKEN is not defined!&apos;); &#125; $signature = $_GET[&quot;signature&quot;]; $timestamp = $_GET[&quot;timestamp&quot;]; $nonce = $_GET[&quot;nonce&quot;]; $token = TOKEN; // 加密/校验流程如下：// 1）将token、timestamp、nonce三个参数进行字典序排序 // 2）将三个参数字符串拼接成一个字符串进行sha1加密 // 3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 $tmpArr = array($token, $timestamp, $nonce); // use SORT_STRING rule sort($tmpArr, SORT_STRING); $tmpStr = implode( $tmpArr ); $tmpStr = sha1( $tmpStr ); if( $tmpStr == $signature )&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125; 2.接受数据/回复数据 123456789101112131415161718192021222324252627282930313233343536373839// 全局接收 psot数据 一般情况 禁用 因为不安全// $postStr = $GLOBALS[&quot;HTTP_RAW_POST_DATA&quot;];// 使用 php://input$postStr = file_get_contents(&apos;php://input&apos;);// 把微信请求到的数据 poststr// 存入文件file_put_contents(&apos;./s.txt&apos;, $postStr);libxml_disable_entity_loader(true); // xml 保护模式开启// 把xml 转为对象$postObj = simplexml_load_string($postStr, &apos;SimpleXMLElement&apos;, LIBXML_NOCDATA);$fromUsername = $postObj-&gt;FromUserName; // 用户id$toUsername = $postObj-&gt;ToUserName; // 商户id$keyword = trim($postObj-&gt;Content); // 内容$time = time();// 根据用户 不同的点击菜单 进行不同的回复// 是事件// 判断是 哪一个key$evevnt = $postObj-&gt;Event;$eventKey = $postObj-&gt;EventKey;if ( $event == &apos;CLICK&apos; ) &#123; switch (variable) &#123; case &apos;value&apos;: # code... break; default: # code... break; &#125; echo $tpl;&#125; 微信开发原理 环境搭建 : ​ - 服务器 ​ sae(新浪云应用) - 权限受限 ​ bae(百度云应用) ​ -虚拟主机+域名解析(Apache-.vhost/Nginx-whereis nginx) ​ sftp(sublime插件 , 服务器即时代码变化) 日志记录: ​ 1. 查看服务器传入内容 - wwwlog 创建日志记录 file_put_content(‘log.txt’,$str); 动态查看日志tail -F log.txt]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis-使用]]></title>
    <url>%2F2018%2F09%2F22%2FRedis%20%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装apt-get install redis-server```1234## 进入cli控制台```redis-cli str命令讲解set key value```12setnx 设置k 防止重复 .如果重复会直接返回0 setnx key value 123setex 设置一个k 并且给有效期 expire用法: setex k 生成时间(秒单位) v setex key int(秒单位) value 12345ttl 以秒为单位返回 key的剩余生存时间 key 不存在 -2 key 存在没有设定时间 -1 key 存在设定过期时间 返回剩余时间 ttl key 12 127.0.0.1:6379&gt; set name yinkaiOK 127.0.0.1:6379&gt; get name“yinkai” 127.0.0.1:6379&gt; set yinkai(error) ERR wrong number of arguments for ‘set’ command127.0.0.1:6379&gt; set name anjingOK127.0.0.1:6379&gt; get name“anjing”127.0.0.1:6379&gt; setnx name yinkai(integer) 0127.0.0.1:6379&gt; get name“anjing”127.0.0.1:6379&gt; setnx age 18(integer) 0127.0.0.1:6379&gt; setnx anage 18(integer) 1127.0.0.1:6379&gt; get anage“18”127.0.0.1:6379&gt; setex run 10 yinkaipaoyipaoOK127.0.0.1:6379&gt; get run“yinkaipaoyipao”127.0.0.1:6379&gt; get run(nil)127.0.0.1:6379&gt; setex action 30 macbookpro_2kuaiOK127.0.0.1:6379&gt; get action“macbookpro_2kuai”127.0.0.1:6379&gt; ttl action(integer) -2127.0.0.1:6379&gt; setex action 30 macbookpro_2kuaiOK127.0.0.1:6379&gt; ttl action(integer) 28127.0.0.1:6379&gt; ttl action(integer) 27127.0.0.1:6379&gt; ttl action(integer) 26127.0.0.1:6379&gt; ttl action(integer) 25127.0.0.1:6379&gt; ttl action(integer) 24127.0.0.1:6379&gt; ttl name(integer) -1127.0.0.1:6379&gt; 12345678------批量设置 mset k1 v1 k2 v2 k3 v3........批量获取mget k1 k2 k3 k4....... 127.0.0.1:6379&gt; mset name luo age 18 sex 110OK127.0.0.1:6379&gt; get sex“110”127.0.0.1:6379&gt; mget name sex age1) “luo”2) “110”3) “18” 1234567批量设置不存在的 键和值(当其中有key不存在,则直接失败.)msetnx k1 v1 k2 v2 k3 v3........#### 1.str命令**浏览量**(++ --) incr 自增+1 返回自增之后的结果decr 自减-1 返回自减之后的结果 incrby 键名 数值 (增加指定数量) (若该字段不存在,则会先创建默认值为0的字段) eg:incrby age 100decrby 键名 数值 (减去指定数量) eg:decrby age 100 del 键名 (删除指定键) 1234#### 2.hash命令**存放二维数组** hset 键名 字段 字段值hget 键名 字段 123456789**批量处理** hmset 键名 字段1 值1 字段2 值2 字段3 值3 ... hmget 键名 字段1 字段2 字段3 ...**批量获取** hkeys 键名 (返回指定键名中的所有字段名) hvals 键名 (返回指定键名中的所有字段值) hlen 键名 (返回指定键值对中含有的段数量) hgetall 键名 (返回指定键中所有的字段名+字段值) 1234**增删** hincrby 键名 字段名 数值 (给hash键红指定的整形字段添加数值) eg:hincrby 001 age 10 hdel 键名 字段1 字段2 字段3 ….(删除指定字段) eg: hdel 001 age name 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748------**del 和 hdel 区别** del 删除一整个价值对​ hdel 只删除某个键值对的一个字段hash小结hsethmsethdel delhget hmget hgetall hkeys hvalshincrby判断:hexists hexists 键名 字段名 (查询指定键值对中是否存在该字段, 存在返回1,不存在返回0)&lt;hr/&gt;list 是链表特点是 : 有序 队列先进后出------#### 3.链表命令**创建插入** lpush 从队列左边插入数据 rpush 从队列右边插入数据**从左到右显示** lrange 键名 起始下标 终止下标 (从队列中获取指定的值,从左边开始)------**下标指定**: 0 第一个 1 第二个​ -1 最后一个 -2 倒数第二个**指定位置插入** linsert 键名 after|before 原值 新值**删除指定元素**​ lrem 键名 数量&amp;方向 值 (删除指定数量的指定值,返回删除的数量) n &gt; 0 从头向尾搜索,删除 n 个元素n &lt; 0 从尾向头搜索,删除 n 的绝对值个元素n = 0 删除所有指定值得元素 12345------**提取链表中信息** lindex 键名 下标 (提取列表中指定下标的元素的值) llen 键名 (获取列表的长度) 1234567**设置链表信息** lset 键名 下标 内容 (设置指定下标内容,返回ok)**删除元素(首尾)** lpop 键名 (左边删除一个元素,返回被删除的元素) rpop 键名 (右边删除一个元素,返回被删除的元素) ltrim 键名 起始下标 截止下标 (截取指定首尾下标的元素) rpoplpush 键名 源队列 目标队列 (从源队列右边移除最后一元素, 放入一个另一个队列的首部)eg: 127.0.0.1:6379&gt; lrange list 0 -1 7 6 5 4 3 127.0.0.1:6379&gt; lrange rlist 0 -1 1 2 3 4 5 6 127.0.0.1:6379&gt; rpoplpush list rlist 3 127.0.0.1:6379&gt; lrange rlist 0 -1 3 1 2 3 4 5 6 127.0.0.1:6379&gt; lrange list 0 -1 7 6 5 4 123&lt;hr/&gt;set 集合(string类型的无序集合,成员唯一) 集合中包含交集,并集,差集(适用于推荐算法的实现) 123456789101112131415161718192021222324####4.set命令sadd 集合名 元素1 元素2 元素3 ... (将一个或多个成员元素添加入集合)smembers 集合名 (显示集合中所有的子元素)srem 集合名 元素1 元素2 ... (删除指定集合中一个或多个元素)spop 集合名 (随机删除一个元素,并且返回删除的元素名)sismember 集合名 元素 (判断指定元素是否在集合中,返回0/1)scard 集合名 (统计集合元素的个数)smove 来源集合 目标集合 元素 (将一个集合中的元素移动到另一个集合)srandmember 集合名 [count] (返回一个或指定个随机元素组成的集合)##### set 无序集合1. **差集** sdiff 集合1 集合2 返回 集合1 集合2 的差集 以集合1 为主 127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; sadd s85 1 2 3 4 5 6 7(integer) 7127.0.0.1:6379&gt; sadd s86 6 7 8 9(integer) 4127.0.0.1:6379&gt; sdiff s85 s861) “1”2) “2”3) “3”4) “4”5) “5”127.0.0.1:6379&gt; sdiff s86 s851) “8”2) “9”127.0.0.1:6379&gt; sdiffstore diff_s s85 s86(integer) 5127.0.0.1:6379&gt; smembers diff_s1) “1”2) “2”3) “3”4) “4”5) “5”127.0.0.1:6379&gt; 12345------2. **并集** sunion 集合1 集合2 并集 127.0.0.1:6379&gt; sunion s85 s861) “1”2) “2”3) “3”4) “4”5) “5”6) “6”7) “7”8) “8”9) “9”127.0.0.1:6379&gt; sunionstore uni_s s85 s86(integer) 9127.0.0.1:6379&gt; smembers uni_s1) “1”2) “2”3) “3”4) “4”5) “5”6) “6”7) “7”8) “8”9) “9”127.0.0.1:6379&gt; 12345------3. **交集** sinter 集合1 集合2 交集 127.0.0.1:6379&gt; smembers s851) “1”2) “2”3) “3”4) “4”5) “5”6) “6”7) “7”127.0.0.1:6379&gt; smembers s861) “6”2) “7”3) “8”4) “9”127.0.0.1:6379&gt; sinter s85 s861) “6”2) “7”127.0.0.1:6379&gt; sinter s86 s851) “6”2) “7”127.0.0.1:6379&gt; sinterstore inter_s s85 s86(integer) 2127.0.0.1:6379&gt; smembers inter_s1) “6”2) “7”127.0.0.1:6379&gt; 123456789101112131415161718192021222324252627282930------4. store 存储结果集合sdiffstore 新集合 集合1 集合2把返回结果 写入新集合sinterstore 新集合 集合1 集合2把返回结果 写入新集合sunionstore 新集合 集合1 集合2把返回结果 写入新集合smove 原集合 目标集合 值把指定的值 从源集合 中 移动到目标集合------##### zset 有序集合**区别**: set 无序 zset 有序有序是如何有序的? 使用 &quot;分数&quot; . 有序集合 给每一个元素 设定 &quot;分数&quot;zadd key 分数1 v1 分数2 v2 分数3 v3 ......zrange 集合 起始下标 截止下标 [withscores] 0 第一个 -1 最后一个得到所有 0 -1 返回集合中 指定下标区间内元素如果 加了 withscores 则 连分数一起返回 按照分数排序 从小到大 12 127.0.0.1:6379&gt; zadd z85 120 yinkai 160 jq 170 xin 175 kui(integer) 4127.0.0.1:6379&gt; zrange z85 0 -11) “yinkai”2) “jq”3) “xin”4) “kui”127.0.0.1:6379&gt; zrange z85 0 -1 withscores1) “yinkai”2) “120”3) “jq”4) “160”5) “xin”6) “170”7) “kui”8) “175” 1234------zrevrange 集合 起始下标 截止下标 [withscores] 0 第一个 -1 最后一个得到所有 0 -1 返回集合中 指定下标区间内元素如果 加了 withscores 则 连分数一起返回 按照分数排序 从大到小 ------ zrem key 值1 [值2 .....] 删除 集合中 指定的值 zincrby key 增量 值 给 集合中指定值得分数(score) 加上 增量 zrank key 值 返回集合中指定值的下标 按照 (score)从小到大排序 zrevrank key 值 返回集合中指定值的下标 按照 (score)从大到小排序 zcount key 起始分数 截至分数 统计 该集合 score 在给定分数区间内的元素个数 zcard key 返回集合元素个数 zinterstore key 取交集集合个数 集合1 集合2 [集合3....] 交集 存新集合 zunionstore 取并集集合个数 集合1 集合2 [集合3....] 并集存新集合 总结 : 1. **区别** 是否允许重复元素 是否有序 有序的实现方式 应用场景 集合 F F null 社交 好友推荐等 有序集合 F T 分数 排行榜 列表 T T 索引下标 队列 抽奖 2. **使用场景** string 计数器 系统缓存(把对象 数组 串行化再存入string) list 队列 最新N个数据 实时分析正在发生的情况 数据统计 防止垃圾邮件(set) hash 用户数据 set unique 操作 获取某段时间内所有数据的排重值 共同好友 推荐好友 统计网站访问的所有 独立IP(唯一性) 实时反垃圾系统 zset 排行榜(取 top N操作) 需要 精准设定过期的应用(时间戳 score ) ------ 公司想要使用reids?怎么做? 第一步: 安装配置 redis 第二步: 安装配置 phpredis 第三步: 得知道基本的语句 5种数据类型 CURD操作]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis-简介]]></title>
    <url>%2F2018%2F09%2F15%2FRedis%20%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Redis1.非关系型数据库 NoSQL1234567NoSQL（NoSQL = Not Only SQL），意即“不仅仅是SQL”，指的是非关系型的数据库。是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。 Nosql特点1234567891011它们可以处理超大量的数据。它们运行在便宜的PC服务器集群上。 PC集群扩充起来非常方便并且成本很低，避免了“sharding”操作的复杂性和成本。它们击碎了性能瓶颈。 通过NoSQL架构可以省去将Web或Java应用和数据转换成SQL友好格式的时间，执行速度变得更快。 “SQL并非适用于所有的程序代码，” 对于那些繁重的重复操作的数据，SQL值得花钱。 但是当数据库结构非常简单时，SQL可能没有太大用处。没有过多的操作。 虽然NoSQL的支持者也承认关系数据库提供了无可比拟的功能集合， 而且在数据完整性上也发挥绝对稳定，他们同时也表示，企业的具体需求可能没有那么多。 NoSQL适用场景1231. 对数据高并发读写2. 对海量数据的高效率存储和访问3. 对数据的高可扩展性和高可用性 2.Redis123456Redis is an open source, advanced key-value store.It is often referred to as a data structure server since keys can containstrings, hashes, lists, sets and sorted sets. Redis是一个开源的，先进的key-value存储。它通常被称为数据结构服务器，因为键可以包含字符串，哈希，链表，集合和有序集合。 Redis 简介12345Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。Redis 与其他 key - value 缓存产品有以下三个特点：Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。Redis支持数据的备份，即master-slave模式的数据备份。 Redis 优势1234性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Redis与其他key-value存储有什么不同？123456Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。 Redis 安装Window 下安装12345678910111213下载地址：https://github.com/MSOpenTech/redis/releases。Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip压缩包到 C 盘，解压后，将文件夹重新命名为 redis。打开一个 cmd 窗口 使用cd命令切换目录到 C:\redis 运行 redis-server.exe redis.windows.conf 。如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。切换到redis目录下运行 redis-cli.exe -h 127.0.0.1 -p 6379 。设置键值对 set myKey abc取出键值对 get myKey Linux 下安装下载地址：http://redis.io/download，下载最新文档版本。 本教程使用的最新文档版本为 3.0.0，下载并安装： 12345$ wget http://download.redis.io/releases/redis-3.0.0.tar.gz -O redis-3.0.0.tar.gz$ tar xzf redis-3.0.0.tar.gz$ cd redis-3.0.0$ make$ make PREFIX=/usr/local/redis install （非必需） 如果失败可能为gcc没有安装。make完后目录下会出现编译后的redis服务程序redis-server。 注意：这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。 配置redis使用环境：12345678新建目录 /usr/local/redis/etc ,把原redis.conf 复制到该目录下vim redis.conf将 daemonize no 改为 yes 意为后台启动启动服务$ /usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf Redis 数据类型Redis常用的五种数据类型： string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set 有序集合)。 详细格式看手册 String（字符串）string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。 string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。 string类型是Redis最基本的数据类型，一个键最大能存储512MB。 set get setnx setex setrange getrange mset mget msetnx getset incr incrby decr decrby append strlen Hash（哈希）Redis hash 是一个键值对集合，一个string类型的field和value的映射表，hash特别适合用于存储对象。 hset hget hsetnx hmset hmget hgetall hexists hlen hkeys hvals hincrby hdel List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 lpush lrange rpush linsert lset lrem ltrim lpop rpop rpoplpush lindex llen Set（无序集合）Set是string类型的无序集合，通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 sadd smembers srem spop srandmember scard sismember sdiff sdiffstore sinter sinterstore sunion sunionstore smove zset(sorted set：有序集合)zset 和 set 一样也是string类型元素的集合,且不允许重复的成员，不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。 zadd zrange zrevrange zrangebyscore zrevrangebyscore zrem zcard zcount zincrby zrank zrevrank zremrangebyrank zremrangebyscore zinterstore zunionstore zscore Others keys exists del expire persist ttl select move randomkey rename type ping echo quit save bgsave dbsize config get info flushdb flushall Redis命令（截至到3.2.8）共174个，此文只介绍常用的，还有很多的不常用命令在《Redis命令补充》中说明，此处不提]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Memcache存放SESSION]]></title>
    <url>%2F2018%2F09%2F07%2FMemcache%E5%AD%98%E6%94%BESESSION%2F</url>
    <content type="text"><![CDATA[Memcached 什么是Memcached? 免费并且开源，高性能的分布式内存对象缓存系统，通过减轻数据库负载来加速动态web应用程序的使用。 一种内存中的键值存储，用于从数据库调用、API调用或页面呈现的结果中获得少量任意数据(字符串、对象) PHP 的扩展(服务名) 优点 简单而强大 促进了快速部署，简化了开发 解决大型数据缓存面临的许多问题 它的API适用于大多数流行语言 支持 binary protocol 协议 支持对同一key的多进程的并发处理问题 安装 12345678910111213141516171819201. 安装phpize apt-get install php7.0-dev2. 安装memcached&amp;依赖 apt-get install memcached apt-get install libmemcached11 libmemcached-dev libmemcachedutil23. 安装memcached拓展 1. apt-cache search -n php7.0 # 查看 php7.-0 的软件包 2. git clone https://github.com/php-memcached-dev/php-memcached.git # 下载 memcached 到本地仓库，并切换到 php7 版本 3. cd php-memcached/ # 进入memcached目录 4. git checkout php7 # 切换分支 5. phpize 6. ./configure --disable-memcached-sasl 7. apt-get install pkg-config (如果第六步有报错执行该步骤在执行第六步,如果没有则直接跳过) 8. make &amp;&amp; make install # 编译安装(编译安装完成后会返回 buil completed 提示信息以及你的扩展地址,记住该路径) 9. vi /etc/php/7.0/fpm/conf.d/memcached.ini #把扩展添加进php中 10. extension=/usr/lib/php/20151012/memcached.so #完成第9步之后写入该步骤的内容 11. vi /etc/php/7.0/apache2/php.ini # 把扩展添加进php中 12. extension=/usr/lib/php/20151012/memcached.so #完成第11步之后写入该步骤的内容(写入到差不多866行左右的位置) 13. 重启Apache2 14. 访问phpinfo看是否有memcached拓展 Memcache 什么是Memcache? 免费并且开源，高性能的分布式内存对象缓存系统，通过减轻数据库负载来加速动态web应用程序的使用。 一种内存中的键值存储，用于从数据库调用、API调用或页面呈现的结果中获得少量任意数据(字符串、对象) PHP 的扩展(服务名) 优点 简单而强大 促进了快速部署，简化了开发 解决大型数据缓存面临的许多问题 它的API适用于大多数流行语言 支持对同一key的多进程的并发处理问题 安装 1234567891011121314151. 安装phpize(如果已经安可直接跳过) apt-get install php7.0-dev2. 安装memcache 1. git clone https://github.com/websupport-sk/pecl-memcache memcache # # 下载 memcached 到本地 2. cd memcache # 进入memcache目录 3. phpize 4. whereis php-config # 查找php-config目录 php-config: /usr/bin/php-config /usr/share/man/man1/php-config.1.gz 5. ./configure --enable-memcache --with-php-config=/usr/bin/php-config --with-zlib-dir # 编译 6. make &amp;&amp; make install # 编译安装(编译安装完成后会返回 buil completed 提示信息以及你的扩展地址,记住该路径) 7. vi /etc/php/7.0/apache2/php.ini # 把扩展添加进php中 8. extension=/usr/lib/php/20151012/memcached.so #完成第7步之后写入该步骤的内容(写入到差不多866行左右的位置) 9. 重启Apache2 10. 访问phpinfo看是否有memcached拓展 Memcache存放SESSION 修改php.ini配置文件 1231. vi /etc/php/7.0/apache2/php.ini # 打开php.ini配置文件2. 找到session.save_handler，并设为 session.save_handler = memcache，把session.save_path前面的分号去掉，并设置为 session.save_path = “tcp://127.0.0.1:11211″3. 重启服务sudo service apache2 restart .htaccess 12php_value session.save_handler “memcache”php_value session.save_path “tcp://127.0.0.1:11211″ 临时生效 12ini_set(“session.save_handler”, “memcache”);ini_set(“session.save_path”, “tcp://127.0.0.1:11211″);]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Memcache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Memcache]]></title>
    <url>%2F2018%2F09%2F05%2FMemcache%2F</url>
    <content type="text"><![CDATA[1.背景:随着计算机性能的发展 , 内存空间的加大 , 原本被存储在硬盘中的数据库数据可以被存入读取速度更快的内存当中 管理服务器数据存入内存的软件—&gt;memcache 2.流程安装—&gt;启动(memcached)—&gt;链接(port:11211)—-&gt;发送命令(get/set) 存储格式:hash键值对 key(键) value(值) length time(存活时间) 注: memcache重启,内存中数据也就消失. ​ 使用内存较多 , CPU使用少 , 与Apache相反 使用:缓存sql语句 , 会话控制机制 3.安装Windows 32x 64x Linux 4.启动Windows: 常用参数: -p&lt;num&gt; 设置链接端口号(默认不设置为11211) -U&lt;num&gt; UDP监听端口(默认11211,0时关闭) -l&lt;ip_address&gt; 绑定地址(默认无论内外网或本地ip都允许,有安全隐患,若设置为127.0.0.1就只能本机访问) -d 独立进程运行 -d start 启动memcached服务 -d restart 重启memcached服务 -d stop|shutdown 关闭正在运行的memcached服务 -d install 安装memcached服务 -d uninstall 卸载memcached服务 -u &lt;username&gt; 绑定使用指定用户运行进程 -m &lt;num&gt; 允许最大内存使用量 , 单位M (默认为64M) -P &lt;file&gt; 将PID写入文件&lt;file&gt;,配合 -d 一起使用 -M 内存耗尽时返回错误 , 而不是删除项 -c 最大同时连接数 , 默认是1024 -f 块大小增长因子 , 默认是1.25 -n 最小分配空间 , key+value+flags默认是48 -h 显示帮助 12#/usr/local/memcached/bin/memcached -d -m 256 -p 11211 -u www -l 127.0.0.1#/usr/local/memcached/bin/memcached -d -m 1024 -p 11211 -u root -c 1000 5.基础常用命令(客户端)–stats : 当前所有memcached服务器运行的状态信息 –add : 添加一个数据到服务器 –set : 替换一个已经存在的数据 , 如果数据不存在 , 则和add命令相同 –get : 从服务器端提取指定的数据 –delete : 删除指定的单个数据 , 如果要清除所有的数据 , 请使用flush_all指令 客户端链接直接操作memcached telnet localhost 11211 添加数据 add 键名(key) 标志(flag) 存活时间(time) 长度(length) 输出数据(长度与设定长度相同) eg: add name x1 30 5 回车换行 tomey 注 : 时间设为0永久存在 删除所有数据 flush_all stats 得到memcached 的运行状态 stats items 显示各 item 的数目和最老 item 的年龄 stats cachedump 2(item后数字) n(0-得到全部) 展示某个slab中的前n个key列表 6.PHP操作memcache 函数库(基于php开发)(面向对象和面向过程)​ memcache_add() 或者 memcache_obj-&gt;add() ​ memcached 函数库(基于c++开发)(只有面向对象使用) 安装memcache 和memcached扩展: …. 123456789101112131415161718192021222324252627282930313233&lt;?php // 创建一个memcache对象 $mem = new Memcache; // 链接memcache服务器 $mem-&gt;connect(&apos;127.0.0.1&apos;,11211); // 操作(增删改查) //add添加 $mem-&gt;add(&apos;one&apos;,&apos;test code string&apos;,MEMCACHE_COMPRESSED,60*60*24*7); #时间不能设置超过30天,否则会变成时间戳格式,推荐使用time()+秒数 #设置为0则永久存在 $mem-&gt;add(&apos;two&apos;,array(&apos;111&apos;,&apos;222&apos;,&apos;333&apos;),MEMCACHE_COMPRESSED,0) #数组/对象会在memcache中以序列化的方式存在 //set设置(==replace覆盖) $mem-&gt;set(&apos;one&apos;,&apos;demo&apos;,MEMCACHE_COMPRESSED,0); //get取值(存进去是什么类型数据,取出来还是什么类型) var_dump($mem-&gt;get(&apos;one&apos;)); var_dump($mem-&gt;get(array(&apos;one&apos;,&apos;two&apos;))); //delete删除 $mem-&gt;delete(&apos;one&apos;); $mem-&gt;delete(&apos;two&apos;,10); #10秒后删除,0为立即删除 //flush删库 $mem-&gt;flush(); // 关闭链接 $mem-&gt;close();?&gt; 其他常用函数: ​ 自增: increment(key [, num]); ​ 查看状态: getStats(type); 7.分布式配置​ 多服务器机器利用哈希算法共同分担压力 , 共同提供数据库服务 ​ addServer(‘主机名’,端口号,[持久链接],[权重],[超时时间],[重试间隔]) ​ $mem-&gt;addServer(&#39;192.168.14.112&#39;,11211) 8.安全防护 内网访问 memcached -d -m 1024 -u root -l 192.168.xx.xx(内网ip) -p 11211 -c 1024 start 设置防火墙 12345指定访问类型iptables -Fiptables -P INPUT DROPiptables -A INPUT -p tcp -s 192.168.xx.xx --dport 11211 -j ACCEPTiptables -A INPUT -p udp -s 192.168.xx.xx --dport 11211 -j ACCEPT ​ 9.实际使用memcache读取数据​ 多用户大批量访问下 , 重复读取数据 , 服务器压力太大 , 使用memcache在查询时 , 缓存一份 , 以后的查询可以从memcache缓存中获取 , 当数据有变化时在更新缓存内容 , 以减轻负载压力 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php // 创建memcache对象 $mem = new Memcache; // 连接memcache数据库 $mem-&gt;addServer(&apos;192.168.14.48&apos;,&apos;11211&apos;); $mem-&gt;addServer(&apos;192.168.14.49&apos;,&apos;11211&apos;); // 设置sql语句和mem缓存的键 $sql = &apos;select id,name,sex,age,email from users order by id&apos;; $key = md5($sql); //从mem内存中获取数据 $data = $mem-&gt;get($key); //数据库操作 if (empty($data)) &#123; //链接 try &#123; $pdo = new PDO(&apos;mysql:host=localhost;dbname=test&apos;,&apos;root&apos;,&apos;123456&apos;); &#125; catch (Exception $e) &#123; echo &apos;数据库链接失败:&apos;.$e-&gt;getMessage(); &#125; // 获取数据 , 执行查询语句 $PDOstatement = $pdo-&gt;prepare($sql); $PDOstatement-&gt;exec(); $data = $PDOstatement-&gt;fetchAll(PDO::FETCH_ASSOC); //将查询到的数据存入mem缓存 $mem-&gt;set($key,$data,MEMCACHE_COMPRESSED,10); &#125; print_r($data); // 关闭链接 $mem-&gt;close(); ?&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Memcache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 版本控制]]></title>
    <url>%2F2018%2F08%2F20%2FGit%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Git 版本控制1. 什么是 Git Git 是当今世界上最先进/最好用的分布式版本控制系统，没有之一 2. 什么是版本控制系统? 版本控制 — 《维基百科》版本控制是一种软件工程技巧，能在软件开发的过程中，确保由不同人所编辑的同一个代码文件都得到同步.版本控制能使项目的设计者，将项目恢复到之前任意的状态，这种选择权在设计过程中特别重要.理论上所有的信息记录都可以加上版本控制:利用版本控制来追踪、维护源码、文件以及配置文件等等的改动 3. 版本控制发展史3.1 文件名方式早年的软件开发过程，代码管理以手动和邮件等形式，文件命名及保存存在问题 如图 : 文件命名方式 如图 : 毕业论文版本 3.2 集中式包括库和工作区两部分：在工作区编码，然后上传至库的方式，完成多人协作。问题：工作机与库机，需要联网才能控制版本，传输速度较慢。 3.2 分布式每台电脑都有，工作区和库，可以自己控制版本。数据更加安全，有逻辑上的中心。 4. 常见版本控制系统 如图 : 版本管理器的发展史 这张图上，分成了四个时期 : ● 史前时期：1982年的RCS。现在你可能还能在Unix的发布包中找到它。 ● 古典时期：1990年的CVS自身缺陷已经过时；1985年的PVCS、1992年的clearcase（费用昂贵、功能复杂沿用至今）；微软VVS反人类；Perforace（广泛，谷歌内部最大代码管理器） ● 中世纪时期：SVN解决了CVS的问题，集中式领域王者。AccuRev（支持分支合并让很多公司拜托cvs和clearcase）。 ● 文艺复兴：BitKeeper（SUN公司大量使用），2002年Linux内核使用BitKeeper，2005年闭源时有人试图破解BitKeeper，于是出现了Git。 Git 问世Git的第一个版本是Linux之父Linus Torvalds亲手操刀设计和实现的（两周内 用C写完），Linus不仅仅给出一个原始设计，并在向世人介绍Git时强烈批评了CVS和SVN等，Git消除了分支和合并的恐惧。很多大型开源项目由SVN迁移至Git。 2008年GitHub也成为世界最大的SCM系统(软件配置管理)，它使用的就是Git版本库的技术.从此Git成为版本控制系统的主流。 GitHub上的著名项目 :Linux内核、安卓、jQuery、Bootstrap、Ruby … 5. Git 的安装 和 基本配置5.1 安装 Linux 安装 二进制包（在线）yum -y install git // RedHat系列apt-get git install // Debian系列源码包（官网下载） Windows 安装 Git 在 Windows 使用模拟环境 msysgit下载地址：https://git-for-windows.github.io/注意：如果想让 windows 作为 git 服务器则需要搭建ssh服务。 本教程使用 windows 版本来做演示 :安装步骤: (如果你不熟悉每个选项的意思，请保持默认的选项) 以管理员方式运行安装包,选择 是 安装 同意协议条款 选择安装选项: 安装Git Bash和Git GUI，创建图标(可选) 选择 Git 的默认编辑器 (默认为vim,可选取自己熟悉的编辑器) 选择: git form the command line and also form 3rd-party software (GIT命令行和第三方软件) 选择: 选择 OpenSSL 传输 HTTPS 的信息 选择 : 换行符默认为 windows 环境为主 选择 : MinTTY 默认终端 选择 : 系统文件缓存 和 git 的管理器(需要.net v4.5.1) 实验选项，暂不选择 点击 Install 安装，开始安装 安装完成，选择运行git bash工具 Git 运行界面 (命令行提示的是 你电脑的用户名) 5.2 配置 无论 Linux 还是 Windows，安装完成后都要初始化 12345678910111213141516171819# 查看 git 版本git --version# 查看配置git config -l# 设置用户名和邮箱git config [--global] user.name "Your Name"git config [--global] user.email "your@email.com"# 中括号内的参数:# --local 本地# --system 系统# --global 全局# 无参，则为当前库配置身份# 如:git config --global user.name "seeker"git config --global user.email "3300696254@qq.com" 6. Git常用操作6.1 生成新的版本库 新建空目录 进入该目录—单击右键—选择 Git Bash Here 弹出 git 的命令行工具 初始化该目录为版本仓库，键入 git init 显示 Initialized empty Git repository in xxxxxx ls -a 查看该目录下出现.git的隐藏目录，即版本库 初始化完成 6.2 添加文件到版本库 新建文件 1.txt 查看当前版本状态 12# 查看当前版本状态git status 红字提示有文件未跟踪（未加入版本控制） 在命令行内输入以下，添加文件至版本库： 1234567891011121314151617181920212223242526272829# 添加文件至缓存区git add 1.txt# 再次查看版本库状态git status# 提示有要提交的修改，有一个新增的文件# 提交文件至版本库 # 直接提交 # 回车后，会打开指定的编辑器编写描述信息 git commit # 填写完描述信息，保存关闭即可 # 或者带参数 -m 直接写入提交的描述信息 git commit -m "新增1.txt"# 新建 2.txt / 3.txt# 多文件添加git add 2.txt 3.txt# 将缓存区的多次添加一次提交git commit -m "新增2.txt+3.txt"# ps:# 添加所有改动过的和新增的文件到缓存区 (不包括被删除的文件)git add .# 添加所有文件到缓存区git add --allgit add -A 执行完后，提示提交完成 查看提交后的版本库状态： 123$ git statusOn branch masternothing to commit, working tree clean 至此，最简单的添加文件，到版本库的操作已完成 — PS部分: Git 实现原理 — 工作区 : 就是程序员日常编写代码的文件夹 版本库 : 负责代码版本控制，就是.git隐藏目录 版本库原理图 : 版本库包括：暂存区（index/stage），HEAD（指针），分支（默认为 master 主分支）等。 文件提交至版本库总共分两步： git add filename # 添加至 stage 缓存区 git commit -m &quot;描述&quot; # 将 stage 的内容提交至版本库的 master 分支 实验： 修改文件 &gt;&gt;&gt; 查看状态 添加到缓存区 &gt;&gt;&gt; 查看状态 再次修改 &gt;&gt;&gt; 提交 &gt;&gt;&gt; 查看状态 实验过程如下，观察理解 Git 实现机制： 修改文件 &gt;&gt;&gt; 查看状态： 修改1.txt文件的内容，添加一行111，查看状态：git status 提示：Changes not staged for commit: (工作区的修改，还没有提交到缓存区) 显示红字，modified: 1.txt 添加到缓存区 &gt;&gt;&gt; 查看状态： 添加到缓存区git add . 查看状态：git status 提示：Changes to be committed (要提交的修改。表示已提交到缓存区，待提交到版本库) 显示绿字：modified: 1.txt 再次修改 &gt;&gt;&gt; 提交 &gt;&gt;&gt; 查看状态 继续修改文件：1.txt文件的内容,添加一行222 提交版本库：git commit -m &quot;第1次修改 1.txt&quot; 再次查看状态：git status 提示：Changes not staged for commit(表示工作区中，还有修改记录，没有被提交到版本库之中) 显示红字：modified: 1.txt 说明： 第 3 步的提交，只是提交了缓存区内，已经缓存过的内容（即，第二步的add .操作) 第 3 步中的第二次修改文件内容的记录，并没有添加到缓存区，所以版本库与工作区文件不一致 此时需要将第二次的修改记录，添加到缓存区，再次提交即可 123git add.git commit -m '第2次修改 1.txt'git status 6.3 查看文件修改状态相关12# 查看当前版本状态（是否修改）git status 修改文件，测试区别: 12345678# 当 工作区/缓存区/版本库 都一致时，使用以下命令不会有任何提示git diff # 工作区 与 缓存区的区别git diff --cached # 缓存区 与 版本库的区别git diff HEAD # 工作区 与 版本库的区别# 更改工作区的 1.txt，并将更改添加到缓存区# 然后再次更改工作区的 1.txt，并保存文件的更改# 再次测试以上三条命令 6.4 Git 日志123456789# 查看提交历史git log# 以简短的方式查看提交日志git log --oneline# 行为日志，显示所有提交，回滚等..git reflog# 显示缓存区的所有文件git ls-files 6.5 版本回退123456789# 将当前版本重置为 HEAD（通常用于清空缓存区，或 merge 失败回退）git reset --hard HEADgit reset --hard HEAD^ # 回退上一个版本git reset --hard HEAD^^ # 回退上两个版本git reset --hard HEAD~n # 回退上n个版本# 回退到指定版本，commitid 可根据日志获取，'&lt;&gt;'内的id必填git reset --hard &lt;commitid&gt; 6.6 撤销 目的：将尚未提交至版本库的修改撤回 情况一 : 文件修改后，尚未添加至缓存区 1234# 修改 1.txt 的内容：添加一行# 在工作区撤销文件的修改git checkout -- filename# 注意'--'不可缺少。没有'--'，就变成了“切换到另一个分支”的命令 情况二 : 文件修改后，已添加至缓存区 123# 修改 1.txt 的内容：添加一行，并添加到缓存区# 撤回添加至缓存区的修改git checkout HEAD filename 6.7 Git 删除 删除文件和版本库记录 1234567891011# `rm`命令只会删除工作区的文件，不会删除记录rm 2.txtgit status # 提示2.txt 被删除，是否需要提交到版本库# 如果删错文件，则可以撤回删除(因为此时的删除操作，还未写入到缓存区)git checkout -- 2.txt# 将 2.txt 的删除记录写入到缓存区，并删除文件git rm 2.txt# 如果还未提交，想要撤回，可使用 `git checkout HEAD 2.txt`# 提交 2.txt 的删除记录到版本库中git commit -m '删除2.txt' 删除缓存区的文件 12345678910# 新建 demo.html 文件，并加入到缓存区git add demo.htmlgit status # 提示有新文件等待提交# 将 demo.html 文件移出缓存区，但不删除(文件还会保留在工作区)git rm --cached demo.htmlgit status # 提示工作区有文件等待 add# 重新将 demo.html 加入到缓存区# 将缓存区中的 demo.html 文件移出并删除(工作区不保留文件)git rm -f demo.html 其他删除 12345678# 新建 aaa/111.txt# 新建 aaa/bbb/111.txt# 将文件添加到版本库中git add .git commit -m '添加aaa目录及文件'# 递归删除目录(删除的是，已被记录到版本库的目录)git rm -r 目录名git commit -m '删除aaa目录' 6.8 Git 流程图 7. 远程仓库7.1 得到远程的版本库 可以使用两种方式来得到远程版本库: 在某个指定的文件夹下使用，即可得到远端版本库及代码 1git clone &lt;远端版本库url&gt; &lt;本地存放该库的文件夹名&gt; 手动添加版本库,并拉取文件 12345678910111213141516# 初始化本地仓库git init# 添加远程版本库 &lt;remote&gt;可自行取名,默认origingit remote add &lt;remote&gt; &lt;url&gt;# 查看远程版本库信息git remote -v# 查看指定远程版本库信息git remote show &lt;remote&gt;# 删除远程remote链接git remote remove &lt;remote&gt;# 下载代码及快速合并git pull &lt;remote&gt; &lt;branch&gt; 7.2 推送分支代码得到远端版本库后,可以在本地按正常的步骤编辑 :新建或改动文件–&gt;添加至缓存区–&gt;提交到版本库 此时,要想将本地版本库发给远端,只有commit提交是不够的.还需要下面的操作 : 12git push &lt;remote&gt; &lt;branch&gt;# 上传代码及快速合并 执行以上代码,会有报错 : 无法直接推送到远端的主分支此时,可以曲线救国，推送自己的分支到远端即可 : 1git push origin master:dev 此时,推送成功! 8. Git 分支管理8.1 查看版本库分支123456# 显示本地分支git branch# 显示所有分支git branch -a# 切换到指定分支或标签git checkout 分支名/标签名 8.2 创建分支/删除分支1234567# 新建分支git branch 分支名# 创建并切换到dev分支git checkout -b dev# 删除本地分支 -D 强制删除git branch -d 分支名 8.3 合并分支要将 B分支 合并到 A分支里请切换到A分支内,合并B分支的操作在A分支内进行 12# 合并分支到当前分支git merge 分支名 8.4 解决合并冲突 多分支修改同一文件，合并可能出现冲突。冲突部分用&lt;&lt;&lt;===&gt;&gt;&gt;表示 解决方法：先手动修改冲突部分，再次提交即可。 8.5 分支管理策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 8.6 多人协作多人协作的工作模式通常是这样： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改；如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;这就是多人协作的工作模式，一旦熟悉了，就非常简单。 9. 使用代码托管系统市面上有名的Git托管系统 : GitHub 码云 CODING 9.1 码云 生成SSH密钥及使用 本地打开git bash ,cd切换到用户的家目录 使用pwd来查看目录是否正确 使用 ssh-keygen.exe -t rsa 来生成SHA256的SSH密钥(按回车确认即可) cd .ssh/ 切换至ssh目录 ls 查看目录下文件 cat id_rsa.pub 查看生成的密钥,并复制 打开码云,登录自己的账户.点选个人资料 选择SSH公钥 在添加公钥界面,将刚刚复制好的密钥粘贴进来,再自己取一个该密钥的名字,以便于区分管理 本地新建一个目录,用于拉取远端版本库 使用 git init初始化该目录 使用git remote add origin &lt;SSH地址&gt; 来添加远程版本库 使用git remote -v 来查看远程版本库信息 使用git pull origin marster来拉取版本库及代码 9.2 GitHub 生成SSH密钥及使用 运行 git Bash 客户端，输入如下代码： $ cd ~/.ssh $ ls 这两个命令就是检查是否已经存在 id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，那么你可以跳过步骤2，直接进入步骤3 创建一个 SSH key $ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 代码参数含义： -t 指定密钥类型，默认是 rsa ，可以省略。 -C 设置注释文字，比如邮箱。 -f 指定密钥文件存储文件名。 添加你的 SSH key 到 github上面去 $ cat ~/.ssh/id_rsa.pub 测试一下该SSH key 在git Bash 中输入以下代码 $ ssh -T git@github.com 显示类似如下,表示成功: Hi username! You&#39;ve successfully authenticated git clone 远程git仓库地址 10. 文件忽略想要工作区的某些文件，不受版本的控制，可使用.gitignore文件进行忽略.!(注意, .gitignore文件 是没有名字的文件.) 规则: 以斜杠 / 开头表示目录 以星号 * 通配多个字符 以问号 ? 通配单个字符 以方括号 [] 包含单个字符的匹配列表 以叹号 ! 表示不忽略(跟踪)匹配到的文件或目录 配置文件是按行 从上到下 进行规则匹配的，这就意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效. 11. 使用 TortoiseGit 操作 Git TortoiseGit 俗称 [ GIT小乌龟 ] Git 常用命令速查 master 默认主分支 dev 默认开发分支 创建版本库 1234567891011121314# 初始化本地git版本库（创建新仓库）git init# 配置用户名git config --global user.name "xxx"# 配置邮件git config --global user.email "xxx@xxx.com"#查看当前配置列表git config --list# clone远程仓库git clone &lt;url&gt; 修改、提交、删除 1234567891011121314151617181920212223# 添加index.php文件到缓存区git add index.php# 添加所有改动过的文件到缓存区git add .# 添加所有文件到缓存区git add --all# 提交缓存区内的文件(回车后需要键入描述:wq保存退出)git commit# 提交缓存区内的文件,并提供描述git commit -m "描述"# 将add和commit合为一步git commit -am '描述'# 合并最后一次提交(用于反复修改)git commit --amend -m 'xxx'# 删除index.php文件git rm index.php# 将index.php文件移出缓存区,但不删除( -r * 递归目录)git rm --cached index.php# 将缓存区中的1.html文件移出并删除git rm -f 1.html 查看 12345678910111213141516171819# 查看当前版本状态（是否修改）git status# 查看所有添加到缓存区的变更(工作区与版本库的区别)git diff# 查看工作区文件和库文件区别git diff index.php# 查看所有已添加到缓存区,但还未commit的变更(缓存区与版本库的区别)git diff --cached# 查看提交历史git log# 以简短的方式查看提交日志git log --oneline# 行为日志,显示所有提交,回滚等..git reflog# 显示缓存区的所有文件git ls-files 回退 与 撤销 1234567891011121314# 将当前版本重置为HEAD（通常用于merge失败回退）git reset --hard HEADgit reset --hard HEAD^ # 回退上一个版本git reset --hard HEAD^^ # 回退上两个版本git reset --hard HEAD~n # 回退上n个版本# 回退指定版本，commitid根据log获取git reset --hard &lt;commitid&gt;# 在工作区撤销文件的修改git checkout --filename# 撤回添加至缓存区的修改,不指定filename则撤回所有git checkout HEAD [filename] 分支操作 1234567891011121314# 获取远程分支master并merge到当前分支git pull origin master# 显示本地分支git branch# 显示所有分支git branch -a# 切换到指定分支或标签git checkout 分支名/标签名# 新建分支git branch 分支名# 删除本地分支 -D 强制删除git branch -d 分支名 远程协作 12345678910111213141516171819202122# 添加远程版本库git remote add &lt;remote&gt; &lt;url&gt;# 查看远程版本库信息git remote -v# 查看指定远程版本库信息git remote show &lt;remote&gt;# 删除远程remote链接git remote remove &lt;remote&gt;# 重命名远程链接名git remote rename &lt;old&gt; &lt;new&gt;# 下载代码及快速合并git pull &lt;remote&gt; &lt;branch&gt;# 上传代码及快速合并git push &lt;remote&gt; &lt;branch&gt;# 将本地的远端库合并git merge origin master# 将远端库获取本地但不合并git fetch origin 黄超.Seeker更多信息，详见： Pro Git（中文版）]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-Express]]></title>
    <url>%2F2018%2F07%2F15%2FJavaScript%20Express%2F</url>
    <content type="text"><![CDATA[Express1.Express框架基于 Node.js 平台，快速、开放、极简的 web 开发框架。它是用于后台NodeJs的框架,与JQuery/Bootstrap/vue.js/AngularJs这类前端框架是不一样的!Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单。 对比原生Node.js 使用原生Node.js开发,会发现有很多问题: - 呈现静态页面很不方便,需要处理每个HTTP请求,还要考虑304缓存问题. - 路由处理代码不直观清晰,需要写很多正则表达式和字符串函数. - 开发者不能集中精力写业务,要考虑很多其他的东西. 官网：http://expressjs.com/中文官网：http://www.expressjs.com.cn/ 2.安装npm install express –save #即可安装最新版本的Express Express4.x与3.x版本的差别非常大，我们使用4.x 2.1. 基本使用1234567891011121314151617181920212223242526272829303132333435363738394041// 引入express 框架var express = require(&apos;express&apos;);// console.log(express);// 创建 express 的 HTTP服务器var app = express();// 指定框架的模版引擎,无需导入app.set(&apos;view engine&apos;, &apos;ejs&apos;);// 指定静态化的目录app.use(&apos;/static&apos;, express.static(&apos;./static&apos;));// 设置路由规则app.get(&apos;/&apos;, function(req, res)&#123; // 响应输出 res.send(&apos;Hello Express~~~&apos;);&#125;);app.get(&apos;/test&apos;, function(req, res)&#123; // 响应输出 res.send(&apos;这是test页面&apos;);&#125;);app.get(&apos;/user&apos;, function(req, res)&#123; // 绑定并输入数据 res.render(&apos;user&apos;, &#123; &apos;userlist&apos; : [ &apos;钢铁侠 屎大颗&apos;, &apos;绿巨人 浩克&apos;, &apos;美队 史蒂文&apos;, &apos;雷神 托尔&apos;, &apos;邪神 洛基&apos;, &apos;蜘蛛侠 彼得帕克&apos; ] &#125;);&#125;);// 设置请求监听app.listen(3000); 2.2. 路由处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 引入express 框架var express = require(&apos;express&apos;);// 创建 express 的 HTTP服务器var app = express();// 支持所有的请求方式, 实现中间件的功能app.all(&apos;/t&apos;, function(req, res, next)&#123; console.log(new Date().toString()); next();&#125;);// 设置路由规则app.get(&apos;/&apos;, function(req, res)&#123; // 响应输出 res.send(&apos;Hello Express~~~&apos;);&#125;);// GETapp.get(&apos;/t&apos;, function(req, res)&#123; // 响应输出 res.send(&apos;GET 请求&apos;);&#125;);// POSTapp.post(&apos;/t&apos;, function(req, res)&#123; // 响应输出 res.send(&apos;POST 请求&apos;);&#125;);// DELETEapp.delete(&apos;/t&apos;, function(req, res)&#123; // 响应输出 res.send(&apos;DELETE 请求&apos;);&#125;);// 路由方法默认匹配 pathnameb部分,忽略get参数// 对大小写不敏感app.get(&apos;/aaa&apos;, function(req,res)&#123; console.log(req.query); res.send(&apos;3A页面 &apos;);&#125;);// 路由路径 默认express path-to-regexp 匹配路由路径// 正则路由 /stu/1234567890/tomapp.get(/^\/stu\/(\d&#123;10&#125;)\/(\w+)$/, function(req,res)&#123; console.log(req.params); res.send(&apos;学员的学号是: &apos;+ req.params[0]);&#125;);// 路由参数// :xx 表示参数占位,使用req.params读取参数app.get(&apos;/tch/:tid&apos;, function(req,res)&#123; console.log(req.params); res.send(&apos;老师的工号是: &apos;+req.params.tid);&#125;);// 多个路由参数app.get(&apos;/goods/:name/:num&apos;, function(req,res)&#123; // 参数限制 var name = req.params.name; var num = req.params.num; if (/\d+/.test(num)) &#123; res.send(&apos;商品名: &apos; + name + &apos;, 入库: &apos; + num + &apos;件&apos;); &#125; else &#123; res.send(&apos;请填写正确的数量&apos;); &#125;&#125;);// 设置请求监听app.listen(3000); 2.3. 对模版引擎的支持 2.4. 静态文件/目录处理 3.路由3.1. 路由的访问方式 3.2. 路由路径 3.3. 响应方法 res.download() 提示下载文件。 res.end() 终结响应处理流程。 res.json() 发送一个JSON格式的响应。 res.jsonp() 发送一个支持JSONP的JSON格式的响应 res.redirect() 重定向请求。 res.render() 渲染视图模板。 res.send() 发送各种类型的响应。 res.sendFile() 以八位字节流的形式发送文件。 res.sendStatus() 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。 12345678910111213141516171819202122232425262728293031323334var express = require(&apos;express&apos;);var app = express();// 路由重名// 路由中间件app.get(&apos;/kk&apos;,function(req,res,next)&#123; console.log(1); next();&#125;);app.get(&apos;/kk&apos;,function(req,res)&#123; console.log(2); res.send(&apos;响应完成&apos;);&#125;);// 匹配冲突app.get(&apos;/:goods/:num&apos;,function(req, res, next)&#123; // 做查询/匹配... if (false) &#123; console.log(1); res.send(&apos;商品&apos; + req.params.goods + &apos;数量:&apos;+req.params.num); &#125; else &#123; next(); &#125;&#125;);app.get(&apos;/admin/login&apos;,function(req,res)&#123; console.log(2); res.send(&apos;登录界面&apos;);&#125;);app.listen(3000); 4.中间件4.1. 中间件概念 4.2. express路由 具有的中间件特性 4.3. app.use()的特性 app.use() 就是一个中间件,与get()/post()..方法不用的是,它的URL不是精确匹配,而是模糊匹配 4.4. app.use()使用 12345678910111213141516171819var express = require(&apos;express&apos;);var app = express();// 全局中间件app.use(function(req, res, next)&#123; console.log(new Date().toString()); next();&#125;);// 中间件app.use(&apos;/admin&apos;,function (req, res) &#123; res.write(req.originalUrl + &apos;\n&apos;); // 完整的URL res.write(req.baseUrl + &apos;\n&apos;); // 基础URL res.write(req.path + &apos;\n&apos;); // 除去基础以外的URL res.end(&apos;后台...&apos;);&#125;);app.listen(3000); 4.5. 静态资源服务的说明 4.6. 404 页面的说明 5.模版引擎,渲染页面5.1. 模版引擎 的设置和使用 5.2. 原生的 end() 与express的 send() 的区别 5.3. 设置响应头 和 状态码 和 MIME类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344var express = require(&apos;express&apos;);var app = express();// 指定框架的模版引擎,无需导入app.set(&apos;view engine&apos;, &apos;ejs&apos;);// 提供静态资源服务// app.use(express.static(&apos;./static&apos;));// 默认使用 .ejs 为模版文件,目录views// app.set(&apos;views&apos;, &apos;./pages&apos;);app.get(&apos;/&apos;, function (req,res)&#123; // 绑定数据并渲染视图 res.render(&apos;user&apos;, &#123; &apos;userlist&apos; : [ &apos;钢铁侠 屎大颗&apos;, &apos;绿巨人 浩克&apos;, &apos;美队 史蒂文&apos;, &apos;雷神 托尔&apos;, &apos;邪神 洛基&apos;, &apos;蜘蛛侠 彼得帕克&apos; ] &#125;);&#125;);app.get(&apos;/hh&apos;, function (req,res)&#123; // node.js end() // express send() // 二进制 // res.send(new Buffer(&apos;HOOH~&apos;)); // str // res.send(&apos;HOOH~&apos;); // JSON // res.send(&#123;name:&quot;静静&quot;, sec:0&#125;); // ARRAY res.send([15,168,19681,9681,98,986884,true]); &#125;);app.listen(3000); 6.GET 与 POST6.1 GETGET请求的参数在URL中.原生node中,要想得到get参数,需要借助于url模块来识别参数字符串.在Express中，不需要使用url模块了.可以直接使用req.query对象得到GET参数 6.2 POSTGET请求的参数是隐蔽传参(在请求体中).POST请求在Express中不能直接获得,必须使用body-parser模块.使用后,将可以用req.body得到参数.但是如果表单中含有文件上传,那么还是需要使用formidable模块. 1234567891011121314151617181920212223242526272829303132var express = require(&apos;express&apos;);var bodyParser = require(&apos;body-parser&apos;);var app = express();// 指定框架的模版引擎,无需导入app.set(&apos;view engine&apos;, &apos;ejs&apos;);// parse application/x-www-form-urlencoded// 解析 post数据app.use(bodyParser.urlencoded(&#123; extended: false &#125;));//GET参数app.get(&apos;/&apos;, function (req,res)&#123; console.log(req.query); res.send(&apos;GET 完成&apos;);&#125;);app.get(&apos;/form&apos;, function (req,res)&#123; res.render(&apos;form&apos;);&#125;);// POSTapp.post(&apos;/&apos;, function (req,res)&#123; console.log(req.body); res.send(&apos;POST 完成&apos;);&#125;);app.listen(3000); 7.Express对数据库的支持7.1 数据库集成 7.2 连接mysql数据库 7.3 使用数据库 - 查/增/改/删 7.4 连接池 123456789101112131415161718192021222324252627282930313233var express = require(&apos;express&apos;);var mysql = require(&apos;mysql&apos;);var app = express();app.get(&apos;/&apos;, function(req,res)&#123; // 连接数据库 var connection = mysql.createConnection(&#123; host : &apos;127.0.0.1&apos;, user : &apos;root&apos;, password : &apos;123456&apos;, database : &apos;s86&apos; &#125;); // 开启数据库 connection.connect(); // var sql = &apos;SELECT * FROM user&apos;; var sql = &apos;UPDATE user SET age=&quot;19&quot; WHERE id=&quot;1&quot;&apos;; connection.query(sql, function (err, result) &#123; if (err) &#123; console.log(&apos;执行出错: &apos; + err); return; &#125; console.log(result); res.send(result); &#125;); connection.end();&#125;);app.listen(3000); 8.Web Socket和Socket.IO框架8.1. HTTP的问题HTTP无法轻松实现 实时应用： HTTP协议是无状态的，服务器只会响应来自客户端的请求，但是它与客户端之间不具备持续连接。(无法长时持续连接) 我们可以捕获浏览器上发生的事件（比如用户点击了button），这个事件可以产生与服务器的数据交互（比如Ajax）。但是，反过来却是不可能的：服务器端发生了一个事件，服务器无法将这个事件的信息实时主动通知它的客户端。只有在客户端查询服务器的当前状态的时候，所发生事件的信息才会从服务器传递到客户端。(无法主动输出信息) 但是,HTTP协议也能做聊天室这种’长连接’的东西,它是这么实现的: 长轮询：客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。 长连接：客户端只请求一次，但是服务器会将连接保持，不会返回结果（想象一下我们没有写res.end()时，浏览器的小菊花会一直转）。服务器有了新数据，就将数据发回来，又有了新数据，就将数据发回来，而一直保持挂起状态。这种做法的也造成了大量的性能浪费。 8.2. WebSocketWebSocket协议能够让浏览器和服务器全双工实时通信，互相的，服务器也能主动通知客户端了。 WebSocket的原理非常的简单：利用HTTP请求产生握手，HTTP头部中含有WebSocket协议的请求，所以握手之后，二者转用TCP协议进行交流（QQ的协议）。现在的浏览器和服务器之间，就是QQ和QQ服务器的关系了。所以WebSocket协议，需要浏览器支持，更需要服务器支持。 支持WebSocket协议的浏览器有：Chrome 4、火狐4、IE10、Safari5 支持WebSocket协议的服务器有：Node、Apache Tomcat/7.0.27、Nginx1.3 8.3. Socket.IO用原生Node搭建 WebSocket协议的服务 非常麻烦,我们使用写好的模块: Socket.IO它屏蔽了所有底层细节，让顶层调用非常简单。并且还为不支持WebSocket协议的浏览器(IE)，提供了长轮询的透明模拟机制。Node的单线程、非阻塞I/O、事件驱动机制，使它非常适合Socket服务器。 官网：http://socket.io/ chat_demo初始化:1npm init | 聊天室 | index.js 安装的组件:123npm install express --savenpm install ejs --savenpm install socket.io --save 说明:12Express与Socket.IOExpress框架可以和Socket.IO搭配使用，但是不能像通常的Express程序那样，用app.listen进行监听了，而是采用一种固定的模式. 官方 画板 示例:https://socket-io-whiteboard.now.sh/官方 聊天室 示例:https://socket-io-chat.now.sh/官方socket.io 仓库:https://github.com/socketio]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript jQuery]]></title>
    <url>%2F2018%2F07%2F13%2FJavaScript%20jQuery%2F</url>
    <content type="text"><![CDATA[jQuery1. jQuery 介绍1.1 什么是 jQueryjQuery 是 JavaScript 的类库 1.2 jQuery 特点write less,do more (写得少 干得多) 1.3 jQuery 优势 开源 便捷的选择器 方便的 dom 操作 丰富的动画操作 简单的 ajax 操作 兼容性 方便的插件机制 1.4 jQuery 缺点添加额外的 jQuery 文件，增加网络传输量 1.5 jQuery 版本 jQuery 1.X 支持IE jQuery 2.X IE9+ 其他… jQuery 3.X IE9+ 支持最新的浏览器 2. jQuery的基本语法https://www.jquery.com/ [官网.手册]http://www.jq22.com/chm/jquery/index.html 2.1 jquery 入口标准的使用方式12345678// 标准入口$(document).ready(function ()&#123; JS code&#125;);// 简写入口$(function ()&#123; JS CODE&#125;); 2.2 onload 与 ready 的区别 触发点 ready 文档中的 DOM 加载完, 就触发 onload 文档中的 一切加载完, 才触发 绑定逻辑 ready 可以绑定多个事件(事件监听) onload 后面的绑定会覆盖前的代码 1234567891011121314151617181920&lt;script&gt; // JS window.onload = function()&#123; console.log(&apos;onload1&apos;); // console.log(box); &#125; window.onload = function()&#123; console.log(&apos;onload2&apos;); &#125; // JQ的标准入口 $(document).ready(function()&#123; console.log(&apos;ready1&apos;); // console.log(box); &#125;); $(document).ready(function()&#123; console.log(&apos;ready2&apos;); &#125;);&lt;/script&gt; 2.3 链式操作风格JQDOM.css().attr().remove()…. 2.4 jQueryDOM 与 JSDOM 的区别 以及相互转化 区别 JQDOM 通过$()获取到一个数组对象 JSDOM 通过各种方法获取到一个元素标签对象 转换 JSDOM &gt;&gt;&gt; JQDOM $(JSDOM) JQDOM &gt;&gt;&gt; JSDOM JQDOM.get(index) 或 JQDOM[index] 123456789101112131415161718192021222324252627282930313233343536&lt;h1&gt;JQuery&lt;/h1&gt;&lt;hr&gt;&lt;div id=&quot;box&quot;&gt;123456&lt;/div&gt;&lt;hr&gt;&lt;img src=&quot;./1.jpg&quot; width=&quot;50&quot; id=&quot;myimg&quot; alt=&quot;&quot;&gt;&lt;script src=&quot;./jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; var box = document.getElementById(&apos;box&apos;); // JS DOM var $box = $(&apos;#box&apos;); // JQ DOM console.log(box); // console.log($box); box.style.backgroundColor = &apos;#f00&apos;; // $box.style.backgroundColor = &apos;#f90&apos;; // NO $box.css(&apos;background-color&apos;, &apos;#f90&apos;); // box.css(&apos;background-color&apos;, &apos;#09f&apos;); // NO myimg.width = 600; // $(&apos;#myimg&apos;).width = 4000; // NO $(&apos;#myimg&apos;).attr(&apos;width&apos;, &apos;1000&apos;); // 互相转化 // JSDOM ---&gt; JQDOM $(box).css(&apos;background-color&apos;, &apos;#09f&apos;); // JQDOM ---&gt; JSDOM console.log($box[0]); console.log($box.get(0)); $box.get(0).style.backgroundColor = &apos;#feeeed&apos;; &#125;);&lt;/script&gt; 2.5 jquery 命名冲突$ 是 jQuery 的别名 3. jQuery 选择器3.1 基本选择器12345* 通配符选择器#id ID选择器.class CLASS选择器tagName 标签选择器s1,s2,sN 组合/分组选择器 3.2 层级选择器1234selector selector 所有的后代元素selector&gt;selector 所有的子元素selector+selector 紧邻着的下一个同辈元素selector~selector 紧邻着的所有同辈元素 3.3 过滤选择器12345678910:first 首个:last 最后一个:eq(index) 指定第几个:lt(index) 索引小于:gt(index) 索引大于:even 索引为偶数的 0索引也算为偶数:odd 索引为奇数的:header 所有的h标签:not(selector) 排除指定选择器所选的元素:root 根元素 html 1.9+ 3.4 内容选择器1234:contains(text) 匹配包含指定文本的元素:has(selector) 匹配含有选择器 所选择的元素的 元素:parent 匹配含有子元素或文本的元素:empty 匹配所有不含有子节点的元素 3.5 可见性选择器12:visible 匹配所有可见元素:hidden 匹配所有不可见元素 3.6 属性选择器1234567selector[attribute] 选择有指定属性的元素selector[attribute=value] 选择值等于value的元素selector[attribute!=value] 选择值不等于value的元素selector[attribute^=value] 选择值以value开头的元素selector[attribute$=value] 选择值以value结尾的元素selector[attribute*=value] 选择值包含value的元素[][][][]... 属性选择器的进一步筛选 3.7 子元素选择器1234:first-child 选择首个子元素:last-child 选择最后一个子元素:only-child 选择唯一的子元素:nth-child(n) 选择指定的第N个子元素 3.8 表单选择器12345678910:input 选择所有 input, textarea, select 和 button 元素. :text :password :radio :checkbox :submit :image :reset :button :file 3.9 表单对象选择器1234:enabled 匹配所有的可用元素:disabled 匹配所有的禁用元素:checked 匹配所有的被选中的元素:selected 匹配所有的被选中option元素 4. 筛选4.1 过滤1234567891011eq(index) 过滤出指定的某个first() 过滤出首个last() 过滤出最后一个filter(selector) 满足指定选择器所选的元素not(selector) 过滤排除slice(start, end) 过滤出指定的一部分元素has(selector) 过滤出 含有指定选择器所选的元素的元素hasClass() 判断前面的集合中,是否包含有某个类is() 判断前面的集合中,是否有某个元素符合指定的条件map() 对JQdom的遍历,并且能取出一部分值出来 4.2 查找 都是具有破坏性,得到的对象,可能就不是前面集合的子集 12345678910111213141516171819往里找: children() 只找子元素 find() 找后代元素往外找: parent() 父元素 parents() 所有父级 parentsUntil() 找到父级们,到指定位置为止 offsetparent() 获取已定位的 父元素 closest() 逐级向上找父级,返回找到的父级往后找: next() 紧邻着的一个同级元素(后) nextAll() 紧邻着的所有同级元素(后) nextUntil() 紧邻着的所有同辈元素,直到某一个为止(后)往前找: prev() 紧邻着的一个同级元素(前) prevAll() 紧邻着的所有同级元素(前) prevUntil() 紧邻着的所有同辈元素,直到某一个为止(前)其他: siblings() 除了元素自己之外的所有同辈节点 4.3 串联1234add() 向集合内 追加元素andSelf() / addBack() 把之前选中的集合加入到当前集合内end() 返回最后一个 筛选操作之前的状态contents() 获取所有的子节点(包括文本) 5. 文档处理5.1 内部插入1234append() 内部最后appendTo() --prepend() 内部最前prependTo() -- 5.2 外部插入1234after() 外部之后insertAfter() --before() 外部之前insertBefore() -- 5.3 包裹1234wrap() 将集合内的每一个元素 包裹在指定的元素内wrapAll() 将整个集合元素 包裹在指定的元素内unwrap() 去掉包裹wrapInner() 将选中的元素里面的内容 包裹在一个标签内 5.4 替换12replaceWith() 替换谁replaceAll() 谁被替换 5.5 删除12remove() 删除指定的元素empty() 清空子节点 5.6 复制1clone() 复制 6. 属性6.1 属性操作12345attr() 读取/设置/修改 HTML属性 + 自定义属性removeAttr() 移除 HTML属性 + 自定义属性prop() 读取/设置/修改 HTML属性removeProp() 移除 HTML属性 6.2 CSS 类123addClass() 添加一个类属性removeClass() 移除一个类属性toggleClass() 以上俩 来回切换 6.3 HTML 代码/文本/值123html() 相当于 innerHTMLtext() 相当于 innerTextval() 相当于 .value 用于表单控件 7. CSS 操作7.1 CSS1234567891011// 设置样式$('div').css('color', '#f00').css(.....);// 多个样式,可用JSON作为参数传递多个样式$('div').css(&#123; "color" : "#f00", "font-size" : "100px"&#125;);// 读取样式$('div').css('color'); 7.2 位置12345offset() 获取/设置 元素相对于整个文档的位置, left/top属性position() 获取 已定位的父元素的位置scrollTop() 获取/设置 滚动条距离上边的位置scrollLeft() 获取/设置 滚动条距离左边的位置 7.3 尺寸1234567891011(不加 内边距/边框)width() 获取/设置 CSS设置的元素宽height() 获取/设置 CSS设置的元素高(不加边框)innerWidth() 获取/设置 内容+内边距的宽innerHeight() 获取/设置 内容+内边距的高(标准元素大小: 内容+内边距+边框)outerWidth() 获取/设置 实际的宽outerHeight() 获取/设置 实际的高 PS.1234567891011$(window).height() //浏览器时下窗口可视区域高度$(document).height() //浏览器时下窗口文档的高度$(document.body).height() //浏览器时下窗口文档body的高度$(document.body).outerHeight(true) //浏览器时下窗口文档body的总高度 包括border padding margin$(window).width() //浏览器时下窗口可视区域宽度$(document).width() //浏览器时下窗口文档对于象宽度$(document.body).width() //浏览器时下窗口文档body的高度$(document.body).outerWidth(true) //浏览器时下窗口文档body的总宽度 包括border padding margin$(document).scrollTop() //获取滚动条到顶部的垂直高度$(document).scrollLeft() //获取滚动条到左边的垂直宽度 8. 事件8.1 绑定事件 / 事件委派 简写方式 JQDOM.event(function(){}) 标准绑定方式 bind() / on() [支持事件委托] one() 绑定一次性 事件 8.2 解绑定 unbind() off() [支持 事件委派] 8.3 事件的自动触发trigger() 8.4 阻止默认事件 和 事件冒泡 阻止默认事件: 在事件内使用 return false 使事件不冒泡: 在冒泡的事件内 return false 9. 动画效果9.1 基本123show() 显示hide() 隐藏toggle() 切换 显示/隐藏 9.2 滑动效果123slideDown() 下滑动slideUp() 上滑动slideToggle() 切换 上/下滑动 9.3 淡入淡出1234fadeIn() 淡入fadeOut() 淡出fadeToggle() 切换 淡入/出fadeTo() 指定透明度 0: 透明; 1: 不透明 9.4 自定义动画123animate(JSON,time) 自定义动画stop() 停止delay() 延迟 10 ajax10.1 ajax 请求 JQDOM.load() 对象是 JQDOM $.get() 对象是 JQ本身 $.post() $.ajax() 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;h1&gt;JQ AJAX&lt;/h1&gt; &lt;button id=&quot;btn&quot;&gt;加载&lt;/button&gt; &lt;hr&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function ()&#123; $(&apos;#btn&apos;).click(function()&#123; // load() // $(&apos;#box&apos;).load(&apos;./php/1.php&apos;); // get // $.get(&apos;./php/1.php&apos;, function(data)&#123; // $(&apos;#box&apos;).html(data); // &#125;); // post // $.post(&apos;./php/1.php&apos;, function(data)&#123; // $(&apos;#box&apos;).html(data); // &#125;); // ajax $.ajax(&#123; // type : &apos;get&apos;, method : &apos;post&apos;, url : &apos;./php/1.php&apos;, success: function (data)&#123; $(&apos;#box&apos;).append(data +&apos;&lt;br&gt;&apos;); &#125;, error : function()&#123; alert(&apos;AJAX 执行失败&apos;); &#125; &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;h1&gt;JQ AJAX&lt;/h1&gt; &lt;button id=&quot;btn&quot;&gt;加载&lt;/button&gt; &lt;hr&gt; &lt;hr&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function ()&#123; $(&apos;#btn&apos;).click(function()&#123; /*// get $.get(&apos;./php/4.php&apos;, function(data)&#123; // eval() / JSON.parse() console.log(data); &#125;, &apos;json&apos;);*/ // ajax 店长推荐 $.ajax(&#123; // type : &apos;get&apos;, method : &apos;get&apos;, url : &apos;./php/4.php&apos;, dataType : &apos;json&apos;, success: function (data)&#123; console.log(data); for (var i = 0; i &lt; data.length; i++) &#123; $(&apos;&lt;li&gt;&apos;).html(data[i].name).appendTo(&apos;#box&apos;); &#125; &#125;, error : function()&#123; alert(&apos;AJAX 执行失败&apos;); &#125; &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt; 10.2 获取表单中数据serialize() 10.3 jsonp 处理$.getScript() 123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;h1&gt;JQ-JSONP&lt;/h1&gt; &lt;button onclick=&quot;loadHtml()&quot;&gt;加载&lt;/button&gt; &lt;hr&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function makedata(obj)&#123; // alert(obj); box.innerHTML = &apos;&apos;; // JSON.parse() // NO for (var i in obj) &#123; box.innerHTML += i + &apos; : &apos; + obj[i] + &apos;&lt;br&gt;&apos;; &#125; &#125; // JSONP 关键步骤 function loadHtml()&#123; // // 创建JS对象 // var js = document.createElement(&apos;script&apos;); // // 设置JS标签的src值 // js.src = &apos;http://127.0.0.1/s86/JS16-JQ03/php/7.php&apos;; // // 添加这个JS对象到页面之中 // document.body.appendChild(js); // $.getScript(&apos;http://127.0.0.1/s86/JS16-JQ03/php/7.php&apos;); &#125; &lt;/script&gt;&lt;/body&gt; 11. jQuery 其他方法123each() 遍历JQ DDM元素get() 获取某个索引的元素index() 当前元素的索引值 1234567891011121314151617181920212223&lt;body&gt; &lt;h1&gt;JQ-其他&lt;/h1&gt; &lt;hr&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;赠汪伦 - 李先生&lt;/li&gt; &lt;li&gt;李白乘舟将欲行，&lt;/li&gt; &lt;li&gt;忽闻岸上踏歌声。&lt;/li&gt; &lt;li&gt;桃花潭水深千尺，&lt;/li&gt; &lt;li&gt;不及汪伦送我情。&lt;/li&gt; &lt;/ul&gt; &lt;script src=&quot;./jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&apos;#list li&apos;).each(function (i, n)&#123; console.log(i, n, this, $(this).index()); &#125;); &lt;/script&gt;&lt;/body&gt; 特效-纵向导航条(手风琴)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; list-style: none; margin: 0; padding: 0; &#125; #nav&#123; margin: 40px; &#125; #nav h3&#123; width: 200px; line-height: 40px; padding: 0 20px; border: 1px solid #999; background-color: #abcdef; cursor: pointer; &#125; #nav ul&#123; width: 242px; display: none; &#125; #nav li&#123; width: 200px; height: 40px; line-height: 40px; padding: 0 20px; border: 1px solid #aaa; background-color: #f5f5f5; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;JQ 纵向导航条 手风琴效果&lt;/h1&gt; &lt;hr&gt; &lt;div id=&quot;nav&quot;&gt; &lt;h3&gt;用户管理&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a&gt;用户列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;添加用户&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;用户黑名单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;用户权限&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;分类管理&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a&gt;分类列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;添加分类&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;分类权限&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;商品管理&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a&gt;商品列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;添加商品&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;商品黑名单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;商品权限&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;订单管理&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a&gt;订单列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;添加订单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;订单权限&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;系统管理&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a&gt;系统列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;添加系统&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;系统黑名单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;系统权限&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;./jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $(&apos;#nav ul&apos;).eq(4).show(); // 事件 $(&apos;#nav h3&apos;).click(function()&#123; // 展开 /*$(this) .next(&apos;ul&apos;) .slideDown(1000) .siblings(&apos;ul&apos;) .slideUp(1000);*/ $(this) .next(&apos;ul&apos;).slideDown(1000) .siblings(&apos;ul&apos;).slideUp(1000); &#125;); &#125;); &lt;/script&gt; 特效-jq放大镜12345678910111213141516171819202122232425&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;放大镜&lt;/title&gt; &lt;script src=&apos;./jquery-1.8.3.min.js&apos;&gt;&lt;/script&gt; &lt;script src=&apos;jquery.jqzoom-core.js&apos;&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; //使用jqzoom $(&apos;.myclass&apos;).jqzoom(&#123; &#125;); &#125;) &lt;/script&gt; &lt;style&gt; &lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;jquery.jqzoom.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;./images/big01.jpg&quot; class=&apos;myclass&apos; title=&apos;大图&apos;&gt; &lt;img src=&quot;./images/small01.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt;&lt;/body&gt; PS:jQuyer常见插件总结 五星级评价插件 jRating 插件主页：http://www.myjqueryplugins.com/jquery-plugin/jrating 流行的图片展示插件 unSlider 插件主页： http://www.bootcss.com/p/unslider/ 相册插件 Galleriffic 插件主页：http://www.twospy.com/galleriffic/index.html 日期选取插件 Datepicker 插件主页：http://jqueryui.com/datepicker/ 事件日历插件 xGCalendar 主页 https://github.com/xuanye/xgcalendar 表单插件 JQuery.form 主页：http://plugins.jquery.com/form/ 表单验证插件 jQuery.validate 主页 http://plugins.jquery.com/validate/ 表格插件 jqGrid 和 Flexigird 主页： http://www.jqgrid.com/ 主页：http://flexigrid.info/ 树状列表插件 zTree 主页：http://www.ztree.me/v3/main.php#_zTreeInfo 对话框插件主页：http://www.fancybox.net/ 图片放大插件jQzoom主页： http://www.oschina.net/p/jqzoom 图片上传插件 jQuery File Upload 网站导航栏插件 jQuery.mmenu主页：http://mmenu.frebsite.nl/ 可拖放布局插件 gridster.js主页：http://gridster.net/15 页面便条插件 jStickyNode主页 http://tympanus.net/codrops/2009/10/30/jstickynote-a-jquery-plugin-for-creating-sticky-notes/]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-Node.js]]></title>
    <url>%2F2018%2F07%2F10%2FJavaScript%20Node.js%2F</url>
    <content type="text"><![CDATA[Node.js1.关于 Node.jsNode.js是一个让 JavaScript 运行在服务器端的开发平台. 1.1. 介绍1). Node.js 不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的”既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。 2). 与PHP、JSP等相比，Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP）有着很大的不同，可以提供强大的伸缩能力。 官网: https://nodejs.org/en/中文网: http://nodejs.cn/ 1.2. 特点1单线程 | 非阻塞I/O | 事件驱动 1). 单线程1234所有客户端请求的连接 都使用一个线程来处理.Node.js 不是给每个连接去创建新的 线程,而是仅仅使用一个线程来处理.单线程带来的好处,减少内存的损耗,提高并发量. 操作系统完全不再有线程创建和销毁的开销. 2). 非阻塞I/O123456I/O操作不会阻塞程序的运行I: Input 输入O: Output 输出在阻塞模式下,一个线程只能处理一项任务,想要提高吞吐率,必须通过多线程而非阻塞模式下,一个线程 永远在执行某种运算操作.这个线程的CPU 核心利用率永远是满载的 3). 事件驱动12客户端 请求建立连接，提交数据等行为，就会触发 相应的事件.在Node中，在一个时刻，只能执行 一个事件回调函数，但是在执行 一个事件回调函数的中途，（比如，又有新用户连接了）可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制. Node.js底层是C++(V8引擎也是C++写的).底层代码中，近半数都用于事件队列、回调函数队列的构建.用事件驱动 来完成服务器的 任务调度,是Node.js中 真正底层核心逻辑. 4). 三特点说明单线程 是为了减少内存的开销,操作系统的内存换页(创建/销毁) 但是,如果某一个请求 有I/O操作,单线程就会被阻塞了!非阻塞I/O 程序不会傻等I/O语句的执行结束,才继续后续代码的运行,而会直接运行后续代码. 但是,非阻塞就能完美的解决问题吗, 比如 小A的业务执行I/O过程中,有小C要新的请求,此时则么办?事件驱动(事件环) 不管是新用户的请求,还是老用户的I/O操作,都将以事件的方式加入到事件环之中,等待调度. Node.js 中所有的I/O都是异步的.回调函数 套 回调函数泡茶 : 洗茶壶 4 / 洗茶杯 3 / 用茶壶烧开水 8 / 准备茶叶 2 / 泡茶水 5 / 倒茶水 14 + 8 + 5 + 1 = 18 3 + 2 1.3 Node.js 的优缺点,适合开发什么?1). 优点​ 善于I/O,不善于 大量计算​ 处理高并发​ 服务器推送 2). 缺点​ 单线程的缺点: 单一线程 一旦奔溃则整个服务全奔溃​ 服务不是绝对可靠的. 3). 适用场景123456789不能完全替代 传统的后端语言,但在某些方面优于传统.当应用程序需要处理大量并发的I/O操作，而在发出响应之前，应用程序内部 并不需要进行非常复杂的计算处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。- 聊天室- 图文直播- 考试系统- 收集用户数据的表单- 提供JSON的API 2.安装使用node2.1 windows环境安装node -v查看版本 node 文件名 运行文件 2.2 搭建Node.js服务器​ – 首个nodejs页面页面 123456789101112131415161718192021// 搭建nodejs WEB服务器// 引入HTTP模版var http = require(&apos;http&apos;);var hostname = &apos;127.0.0.1&apos;;var port = 3000;// 创建服务器// req 表示请求(request) / res 表示响应(response)var server = http.createServer(function(req, res)&#123; // 设置HTTP头信息. 状态码 200; 文件类型是html; 字符集 utf-8 res.writeHead(200, &#123;&apos;Content-type&apos;:&apos;text/html;charset=UTF-8&apos;&#125;); // 服务器响应输出完成 res.end(&apos;Hi~ o(*￣▽￣*)ブ, 首个nodejs页面,您的积分为: &apos; + (50 + 10) + &apos;分&apos;); &#125;);// 运行服务器server.listen(port, hostname, function()&#123; console.log(`请访问: http://$&#123;hostname&#125;:$&#123;port&#125;`);&#125;); 如果修改了程序代码,必须中断当前的node服务,重新在node一次 node.js是服务器的程序,写好的JS代码,都将运行在服务器上.返回给客户端的, 都是已经处理好的结果 node就是一个JS的运行环境 js文件是不能直接拖入浏览器取运行的,必须靠node去执行 2.3 根目录 与 web容器11). Node.js没有根目录的概念，因为它根本没有任何的web容器！ ​ 12342). 静态页面的呈现URL和真实的物理文件之间 是没有关系的。URL是通过 Node 的路由设计之后，才呈现出 某一个静态文件的 13). HTTP运行原理 由此,我们可以看出,要是使用nodejs 搭建服务器,是需要写 各种回调函数,定义 各种路由规则,来实现 页面的显示.nodejs中就是 回调函数 套回调函数,每个回调函数 都是一个事件 由此就用到了 nodejs的三个特性: 单线程 | 非阻塞I/O | 事件驱动(事件环) URL路由规则,与实际的物理文件,不一定有直接的联系. 3.HTTP模块 Node.js将各种功能，都划分为了一个个mudule(模块) 需要用什么模块,就可以使用require(‘’)来引入使用 4.URL模块​ 解析URL 123456// GET 参数的处理 var getParams = url.parse(req.url, true).query; var name = getParams.name; var age = getParams.age; var sex = getParams.sex; res.end(&apos;服务器接收到了以下信息: &apos;+ name + &apos; | &apos; + age + &apos; | &apos; + sex); ​ 路由设计 12345678910111213141516171819202122232425262728293031323334353637383940414243var http = require(&apos;http&apos;);var url = require(&apos;url&apos;);var hostname = &apos;127.0.0.1&apos;;var port = 3000;// 创建服务器var server = http.createServer(function(req, res)&#123; // 跳过了 chrome 的收藏夹图标的请求 if (req.url == &apos;/favicon.ico&apos;) return; res.writeHead(200, &#123;&apos;content-type&apos;: &apos;text/html;charset=utf-8&apos;&#125;); // /stu/20190212007 查询学员 // /tch/00128 查询老师 // 获取URL中的path部分 var user = url.parse(req.url).pathname; // substr if (user.substr(0, 5) == &apos;/stu/&apos;) &#123; var stuid = user.substr(5); // console.log(stuid); if (/^\d&#123;11&#125;$/.test(stuid)) &#123; res.end(&apos;查询到的学号是: &apos; + stuid); &#125; else &#123; res.end(&apos;学员的学号有误!!!&apos;); &#125; &#125; else if (user.substr(0, 5) == &apos;/tch/&apos;) &#123; var tchid = user.substr(5); // console.log(tchid); if (/^\d&#123;5&#125;$/.test(tchid)) &#123; res.end(&apos;查询到的工号是: &apos; + tchid); &#125; else &#123; res.end(&apos;工号有误!!!&apos;); &#125; &#125; else &#123; res.end(&apos;URL有误,请检查重试!!!&apos;); &#125;&#125;);// 运行服务器server.listen(port, hostname); 5.文件系统​ 5.1. 新建文件夹 / 删除文件夹 / 文件状态信息 / 读取文件夹 ​ 5.2. 读取出 文件夹/文件 6.静态目录 文件加载 (web容器)7.模块的概念 在Node.js中,不可能用一个js文件去写全部的业务,肯定要有MVC. 它以模块为单位 划分所有功能,并且提供了一个 完整的模块加载机制,我们可以将应用程序 划分为各个不同的部分. 每一个JavaScript文件都是一个模块； 而多个JavaScript文件可以使用require引入,使他们共同实现了一个功能模块. 7.1 输出变量/函数​ Node.js中,JS文件中定义的变量、函数,都只在这个文件内部有效.​ 其他文件中需要引用变量、函数时,必须使用exports对象进行暴露(输出).​ 使用者要用require()命令,引用执行这个JS文件. 7.2 输出一个类(构造函数)​ 可以用module.exports = 构造函数名;的方式 向外输出一个类 7.3 模块关联关系 某一个js文件中,有函数或变量: exports.变量 = 变量; 某一个js文件中,有一个类: module.exports = 构造函数名; 7.4 模块封装8.npm (node package management) 这是一个工具名字.npm的主要职责是 安装开发包和管理依赖项. 安装开发包:安装 npm install命令；更新 npm update命令. 管理依赖项:借助 package.json 文件;最简单生成 package.json 的方法就是 npm init npm不需要单独安装,只要安装了 Node.js 环境,npm 就已经包含在里面了. 查看 npm 版本: npm -v 为什么要使用npm? 开发时,会使用到各种功能的组件,所有组件都由我们自己来写代码的话,开发效率就会很低.我们不要重复的去造轮子,要学会使用已有的工具,来完善我们的项目,站在巨人的肩膀上去工作. npm是js世界里的一个伟大的社区,能够让开发者更加轻松的共享代码和共用代码片段或模块组件. https://www.npmjs.com/ # npm官网 https://npm.taobao.org/ # 淘宝npm镜像 不要修改 [node_modules] + package-lock.json 这两个文件,因为它是使用npm去管理的 9.POST请求 相比较GET请求，POST请求比较复杂。 因为Node.js认为，使用POST请求时，数据量会比较多。 为了追求极致的效率，它将数据拆分成为了众多小的数据块(chunk)，然后通过特定的事件，将这些小数据块有序传递给回调函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243var http = require(&apos;http&apos;);var fs = require(&apos;fs&apos;);var querystring = require(&apos;querystring&apos;);var hostname = &apos;127.0.0.1&apos;;var port = 3000;var server = http.createServer(function(req,res)&#123; if (req.url == &apos;/form&apos;) &#123; // 读取表单加载页面 fs.readFile(&apos;./form.html&apos;, function(err, data)&#123; res.writeHead(200, &#123;&apos;content-type&apos;: &apos;text/html;charset=UTF-8&apos;&#125;); res.end(data); &#125;); &#125; else if (req.url == &apos;/dopost&apos; &amp;&amp; req.method.toLocaleLowerCase() == &apos;post&apos;) &#123; // 如果访问/dopost,且请求类型是post // 进行POST数据处理 var postData = &apos;&apos;; // node为了实现极致的效率,所以把post分成多个小份去传递 req.addListener(&apos;data&apos;, function (chunk)&#123; postData += chunk; &#125;); // 全部接收完毕 req.addListener(&apos;end&apos;, function()&#123; console.log(postData); // 将post字串转换为一个对象 var dataObj = querystring.parse(postData); console.log(dataObj); console.log(dataObj.name); res.end(&apos;POST DATA Success!&apos;); &#125;); &#125; else &#123; res.end(&apos;404&apos;); &#125;&#125;);server.listen(port, hostname); 10.文件上传处理原生写POST处理,比较复杂,要写两个监听. 文件上传业务比较麻烦.所以,用第三方模块: `formidable`12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var http = require(&apos;http&apos;);var fs = require(&apos;fs&apos;);var querystring = require(&apos;querystring&apos;);var formidable = require(&apos;formidable&apos;); // 处理表单数据var timestamp = require(&apos;time-stamp&apos;); // 时间var path = require(&apos;path&apos;); // 时间var hostname = &apos;127.0.0.1&apos;;var port = 3000;var server = http.createServer(function(req,res)&#123; if (req.url == &apos;/form&apos;) &#123; // 读取表单加载页面 fs.readFile(&apos;./form_file.html&apos;, function(err, data)&#123; res.writeHead(200, &#123;&apos;content-type&apos;: &apos;text/html;charset=UTF-8&apos;&#125;); res.end(data); &#125;); &#125; else if (req.url == &apos;/dopost&apos; &amp;&amp; req.method.toLocaleLowerCase() == &apos;post&apos;) &#123; // 如果访问/dopost,且请求类型是post // formidable 处理 parse a file upload var form = new formidable.IncomingForm(); // 设置上传目录 form.uploadDir = &quot;./uploads&quot;; // 该模块已经将 POST数据 和 文件数据 分离处理 // 当代码执行到parse()方法的回调函数时,表单中的数据 就都已经处理好了 form.parse(req, function(err, fields, files) &#123; // console.log(fields); // console.log(files); // 处理上传文件的存储 // 新文件名: 时间 + 随机数 + 后缀 var t = timestamp(&apos;YYYYMMDDHHmmss&apos;); var ran = parseInt(Math.random()* 100000); var extname = path.extname(files.myfile.name); // 旧文件名 var oldPath = &apos;./&apos; + files.myfile.path; // 新文件名 var newPath = &apos;./uploads/&apos; + t + ran + extname; console.log(oldPath); console.log(newPath); // 实现改名 fs.rename(oldPath, newPath, function (err)&#123; res.end(&apos;文件上传成功!!&apos;); &#125;); &#125;); &#125; else &#123; res.end(&apos;404&apos;); &#125;&#125;);server.listen(port, hostname); 11.ejs模版https://ejs.co/ #官网 https://www.npmjs.com/package/ejs #npm上的ejs包 ejs是Embedded JavaScript templates的简称,意思是嵌入式JavaScript模板.node中的后台模版. 123456789101112131415161718192021222324252627282930313233343536373839404142434445var http = require(&apos;http&apos;);var ejs = require(&apos;ejs&apos;);var fs = require(&apos;fs&apos;);var hostname = &apos;127.0.0.1&apos;;var port = 3000;var server = http.createServer(function (req, res) &#123; if (req.url == &apos;/&apos;) &#123; fs.readFile(&apos;./views/index.ejs&apos;, function (err, data) &#123; // 模版 // console.log(data); var template = data.toString(); // console.log(template); // 数据 var dict = &#123; title: &apos;EJS 模版的使用&apos;, content: &apos;我是段落内容....&apos;, pic: &apos;./imgs/1.jpg&apos;, songci : &#123; title: &apos;酒调歌头&apos;, list : [ &apos;12345&apos;, &apos;67890&apos;, &apos;09876&apos;, &apos;54321&apos; ] &#125; &#125; // 绑定数据 var html = ejs.render(template, dict); // 显示输出页面 res.writeHead(200, &#123;&apos;content-type&apos;:&apos;text/html&apos;&#125;); res.end(html); &#125;); &#125; else if (req.url == &apos;/imgs/1.jpg&apos;) &#123; fs.readFile(&apos;./imgs/1.jpg&apos;, function (err, data) &#123; res.writeHead(200, &#123;&apos;content-type&apos;:&apos;image/jpg&apos;&#125;); res.end(data); &#125;); &#125;&#125;);server.listen(port, hostname); 12345678910111213141516171819202122232425262728293031&lt;!--index.ejs--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;cn&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&gt;&lt;/h1&gt; &lt;hr&gt; &lt;p&gt;&lt;%= content %&gt;&gt;&lt;/p&gt; &lt;p&gt;&lt;%= content %&gt;&gt;&lt;/p&gt; &lt;p&gt;&lt;%= content %&gt;&gt;&lt;/p&gt; &lt;p&gt;&lt;%= content %&gt;&gt;&lt;/p&gt; &lt;hr&gt; &lt;br&gt; &lt;img src=&quot;&lt;%= pic %&gt;&quot; width=&quot;300&quot;&gt; &lt;hr&gt; &lt;h2&gt;&lt;%= songci.title %&gt;&lt;/h2&gt; &lt;ul&gt; &lt;% for (var i = 0; i &lt; songci.list.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= songci.list[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; PS:V8引擎说明​ V8 JavaScript引擎是 Google用于其Chrome浏览器的底层JavaScript引擎。​ Google使用V8创建了一个用C++编写的超快解释器，该解释器拥有另一个独特特征：​ 您可以下载该引擎并将其嵌入任何应用程序。​ V8 JavaScript引擎并不仅限于在一个浏览器中运行。​ 因此，Node.js实际上会使用Google编写的V8 JavaScript引擎，并将其重建为可在服务器上使用。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
        <tag>npm</tag>
        <tag>ejs</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Ajax]]></title>
    <url>%2F2018%2F06%2F28%2FJavaScript%20Ajax%2F</url>
    <content type="text"><![CDATA[1. Ajax Asyn Javascript And Xml “异步的 JS 和 xml” 请求: 客户端向服务器请求一个文件响应: 服务端把文件内容 返回给客户端，一般服务端有输出才算真真的响应. 传统的请求: 通过地址栏 刷新页面请求AJAX的请求: 通过技术 偷偷的请求 2. XMLHttpRequest对象 XHR2.1 概念XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。 XMLHttpRequest 可以同步或异步地返回 Web 服务器的响应，并且能够以文本或者一个 DOM 文档的形式返回内容。 2.2 常用属性1. readyState 请求响应状态 状态 名称 描述 0 Uninitialized 初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。 1 Open open() 方法已调用，但是 send() 2 Sent Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。 3 Receiving 所有响应头部都已经接收到。响应体开始接收但未完成。 4 Loaded HTTP 响应已经完全接收。 2. status 返回服务器的响应状态码 200 成功响应 404 文件不存在 304 文件来自缓存 500 服务器未知错误 503 服务器宕机 服务暂时不可用 3. responseText 获取服务器的响应文本 2.3 常用方法1. open() 初始化请求 参1 method 请求类型 GET/POST/HEAD 参2 url 请求主体 参3 是否同/异步: true(默认异步) / false(同步) 参4,5 认证的帐号和密码 2. send() 正式发送请求 GET 方式 无参 POST 方式 有可选参数 3. setRequestHeader() 设置POST请求头信息 xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;); 2.4 事件句柄 onreadystatechangereadyState 的值一变化就触发 3. Ajax+php 请求流程 创建对象 xml请求对象 初始化请求 发送请求 接收 并 处理响应 12345678910111213141516171819202122232425262728293031&lt;h2 id=&quot;box&quot;&gt;&lt;/h2&gt;&lt;script&gt;// 创建 XHR 对象var xhr = new XMLHttpRequest();// console.dir(xhr);// 捕获响应结果,绑定事件xhr.onreadystatechange = function()&#123; // console.log(xhr.readyState); if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; // 处理结果 // alert(xhr.responseText); box.innerHTML = xhr.responseText; &#125; &#125;&#125;// 请求初始化// 参1 method 请求类型 GET/POST/HEAD// 参2 url 请求主体// 参3 是否同/异步: true(默认异步) / false(同步)// 参4,5 认证的帐号和密码xhr.open(&apos;get&apos;, &apos;./php/1.php&apos;, true);// 正式发送请求xhr.send();&lt;/script&gt; 4. 处理json数据 PHP: json_encode() JS : eval() 或 JSON.parse() 5. 同步和异步open()方法的参3 决定了是否同异步默认参数为true,表示请求是异步的,AJAX不会影响到其他程序代码的执行参数为false时,表示请求是同步的,AJAX将会阻塞之后程序的运行,直到响应完全接收完毕为止. 123456789101112131415161718192021222324252627&lt;h1&gt;AJAX 同异步&lt;/h1&gt;&lt;button onclick=&quot;loadHtml(true)&quot;&gt;异步&lt;/button&gt;&lt;button onclick=&quot;loadHtml(false)&quot;&gt;同步&lt;/button&gt;&lt;hr&gt;&lt;script&gt; function loadHtml(b)&#123; var msg = &apos;我是来自于JS的值&apos;; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; msg = xhr.responseText; console.log(msg); &#125; &#125; &#125; xhr.open(&apos;get&apos;, &apos;./php/6.php&apos;, b); xhr.send(); alert(msg); &#125;&lt;/script&gt; 6. post 和 get POST方式 GET方式 7. Ajax 无法跨域 与 jsonp Ajax 无法跨域 为什么产生这个问题? (产生跨域的原因:)a. 发出的请求不是本域的,比如协议/域名/端口号,任何一个不一样都算是跨域.b. 浏览器的限制,不是服务器不让你跨域,是浏览器为了安全限制你不能随便跨域.c. XHR对象 不支持跨域. 如果你发送的不是XHR请求,就算是跨域,浏览器也不会报错 PS. 新建浏览器图标, [属性]–[目标] 新增以下: 关闭安全验证 –disable-web-security –user-data-dir=d:\temp1 JSONP 不受同源策略的影响 12PS. 九种跨域方式实现原理（完整版）`https://segmentfault.com/a/1190000018017118` 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 &lt;h1&gt;JSONP&lt;/h1&gt; &lt;button onclick=&quot;loadHtml()&quot;&gt;加载&lt;/button&gt; &lt;hr&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; function makedata(obj)&#123; // alert(obj); box.innerHTML = &apos;&apos;; // JSON.parse() // NO for (var i in obj) &#123; box.innerHTML += i + &apos; : &apos; + obj[i] + &apos;&lt;br&gt;&apos;; &#125; &#125; // JSONP 关键步骤 function loadHtml()&#123; // 创建JS对象 var js = document.createElement(&apos;script&apos;); // 设置JS标签的src值 js.src = &apos;http://127.0.0.1/s86/JS13/php/7.php&apos;; // 添加这个JS对象到页面之中 document.body.appendChild(js); &#125; /* function loadHtml()&#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; box.innerHTML = &apos;&apos;; var obj = JSON.parse(xhr.responseText); for (var i in obj) &#123; box.innerHTML += i + &apos; : &apos; + obj[i] + &apos;&lt;br&gt;&apos;; &#125; &#125; &#125; &#125; xhr.open(&apos;get&apos;, &apos;http://127.0.0.1/s86/JS13/php/7.php&apos;, true); xhr.send(); &#125;*/ &lt;/script&gt; &lt;!-- &lt;script&gt; // JS OBJ makedata(&#123;&quot;id&quot;:&quot;7&quot;,&quot;name&quot;:&quot;\u5929\u4f7f&quot;,&quot;sex&quot;:&quot;0&quot;,&quot;age&quot;:&quot;30&quot;,&quot;province&quot;:&quot;\u6c5f\u82cf&quot;&#125;) &lt;/script&gt; --&gt;&lt;/body&gt; 8. 封装Ajax123456789101112131415161718192021222324252627&lt;h1&gt;AJAX封装&lt;/h1&gt;&lt;hr&gt;&lt;button onclick=&quot;ajax(&apos;./php/8.php&apos;,fun1)&quot;&gt;封装&lt;/button&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt; function ajax(url,fun1)&#123; var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;,url,true); xhr.send(); xhr.onreadystatechange = function()&#123; if (xhr.readyState==4) &#123; if (xhr.status==200) &#123; res = xhr.responseText; fun1(res); &#125; &#125; &#125; &#125; function fun1(y)&#123; box.innerHTML=y; &#125;&lt;/script&gt; PS:状态码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152HTTP 状态 1xx: 信息 消息: 描述: 100 Continue 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 101 Switching Protocols 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。 2xx: 成功 消息: 描述: 200 OK 请求成功（其后是对GET和POST请求的应答文档。） 201 Created 请求被创建完成，同时新的资源被创建。 202 Accepted 供处理的请求已被接受，但是处理未完成。 203 Non-authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。 204 No Content 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 205 Reset Content 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。 206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它。 3xx: 重定向 消息: 描述: 300 Multiple Choices 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。 301 Moved Permanently 所请求的页面已经转移至新的url。 302 Found 所请求的页面已经临时转移至新的url。 303 See Other 所请求的页面可在别的url下被找到。 304 Not Modified 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取。 306 Unused 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。 307 Temporary Redirect 被请求的页面已经临时移至新的url。 4xx: 客户端错误 消息: 描述: 400 Bad Request 服务器未能理解请求。 401 Unauthorized 被请求的页面需要用户名和密码。 402 Payment Required 此代码尚无法使用。 403 Forbidden 对被请求页面的访问被禁止。 404 Not Found 服务器无法找到被请求的页面。 405 Method Not Allowed 请求中指定的方法不被允许。 406 Not Acceptable 服务器生成的响应无法被客户端所接受。 407 Proxy Authentication Required 用户必须首先使用代理服务器进行验证，这样请求才会被处理。 408 Request Timeout 请求超出了服务器的等待时间。 409 Conflict 由于冲突，请求无法被完成。 410 Gone 被请求的页面不可用。 411 Length Required &quot;Content-Length&quot; 未被定义。如果无此内容，服务器不会接受请求。 412 Precondition Failed 请求中的前提条件被服务器评估为失败。 413 Request Entity Too Large 由于所请求的实体的太大，服务器不会接受请求。 414 Request-url Too Long 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。 415 Unsupported Media Type 由于媒介类型不被支持，服务器不会接受请求。 416 服务器不能满足客户在请求中指定的Range头。 417 Expectation Failed 5xx: 服务器错误 消息: 描述: 500 Internal Server Error 请求未完成。服务器遇到不可预知的情况。 501 Not Implemented 请求未完成。服务器不支持所请求的功能。 502 Bad Gateway 请求未完成。服务器从上游服务器收到一个无效的响应。 503 Service Unavailable 请求未完成。服务器临时过载或当机。 宕机 504 Gateway Timeout 网关超时。 505 HTTP Version Not Supported 服务器不支持请求中指明的HTTP协议版本。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ajax</tag>
        <tag>Jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 特效]]></title>
    <url>%2F2018%2F06%2F21%2FJavaScript%20%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[特效扩展银行卡自动截断123456789101112131415161718192021222324252627282930313233343536&lt;h1&gt;请输入银行卡:&lt;/h1&gt;&lt;hr&gt;&lt;input type=&quot;text&quot; id=&quot;bankCard&quot; maxlength=&quot;23&quot;&gt;&lt;script&gt; var input = document.getElementById(&apos;bankCard&apos;); if (document.all) &#123; input.onpropertychange = ckInput; &#125; else &#123; input.oninput = ckInput; &#125; function ckInput()&#123; // 将输入范围限定在数字范围之内 // A: /*input.value = input.value .replace(/\D/g, &apos;&apos;) .replace(/(\d&#123;4&#125;)/g, &apos;$1-&apos;) .replace(/-$/g, &apos;&apos;);*/ // B: input.value = input.value .replace(/\D/g, &apos;&apos;) .replace(/(\d&#123;4&#125;)(?=\d)/g, &apos;$1-&apos;) &#125; /* (?:) 忽略子模式的匹配 (?=) 正向预查/先行断言 匹配过程中,需要用到这个子模式的条件 但是,获取匹配结果时,忽略该子模式的条件 */&lt;/script&gt; 轮播图(Banner)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;轮播图&lt;/title&gt; &lt;style&gt; *&#123; list-style:none; &#125; #box&#123; width: 400px; height: 300px; margin: 0 auto; border: 1px solid #000; &#125; #container&#123; position:relative; &#125; #imglist img&#123; width: 400px; height: 300px; &#125; #iconlist&#123; position: absolute; right:110px; bottom:10px; &#125; #iconlist ul li&#123; width: 30px; height: 30px; border-radius: 50%; float: left; background: rgba(0,200,255,0.4); line-height: 30px; text-align: center; margin-left: 10px; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;轮播图&lt;/h1&gt; &lt;hr&gt; &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;imglist&quot;&gt; &lt;img src=&quot;./imgs/mm041.jpg&quot; style=&quot;display:block&quot;&gt; &lt;img src=&quot;./imgs/mm042.jpg&quot; style=&quot;display:none&quot;&gt; &lt;img src=&quot;./imgs/mm043.jpg&quot; style=&quot;display:none&quot;&gt; &lt;img src=&quot;./imgs/mm044.jpg&quot; style=&quot;display:none&quot;&gt; &lt;img src=&quot;./imgs/mm045.jpg&quot; style=&quot;display:none&quot;&gt; &lt;/div&gt; &lt;div id=&quot;iconlist&quot;&gt; &lt;ul&gt; &lt;li style=&quot;color:red;background: rgba(0,255,255,1);&quot;&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;button onclick=&quot;previous()&quot;&gt;previous&lt;/button&gt; &lt;button onclick=&quot;next()&quot;&gt;next&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var imgs = imglist.children; var lis = document.getElementsByTagName(&apos;li&apos;); console.log(lis); var t = 0; function run()&#123; t++; if (t&gt;=imgs.length) &#123; t=0; &#125; showPic(t); showBtn(t); console.log(t); &#125; var cl1 = setInterval(run,1000); function showPic(t)&#123; for (var i = 0; i &lt; imgs.length; i++) &#123; imgs[i].style.display=&quot;none&quot;; &#125; imgs[t].style.display=&quot;block&quot;; &#125; function showBtn(t)&#123; for (var i = 0; i &lt; lis.length; i++) &#123; lis[i].setAttribute(&apos;style&apos;,&apos;&apos;); &#125; lis[t].setAttribute(&apos;style&apos;,&quot;color:red;background: rgba(0,255,255,1);&quot;); &#125; // 鼠标划入时,解除定时器 container.onmouseover = function()&#123; clearInterval(cl1); &#125; container.onmouseout = function()&#123; cl1 = setInterval(&apos;run()&apos;,1000); &#125; // 鼠标滑过按钮时,切换为绑定页面 for (var i = 0; i &lt; lis.length; i++) &#123; (function(i)&#123; lis[i].onmouseover = function()&#123; t=i; showPic(t); showBtn(t); &#125; &#125;)(i); &#125; // 按钮控制下一张上一张 function previous()&#123; clearInterval(cl1); console.log(t); t--; if (t&lt;0) &#123; t=(imgs.length-1); &#125; showPic(t); showBtn(t); cl1 = setInterval(run,1000); &#125; function next()&#123; clearInterval(cl1); t++; if (t&gt;(imgs.length-1)) &#123; t=0; &#125; showPic(t); showBtn(t); cl1 = setInterval(run,1000); &#125; &lt;/script&gt;&lt;/body&gt; 图片无缝轮滚1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #box&#123; width: 800px; height: 220px; margin: 0 auto; margin-top: 50px; border: 1px solid #000; /*overflow: auto;*/ overflow: hidden; &#125; #content&#123;width: 10000px;&#125; #imglist&#123;float: left;&#125; #imglist img&#123; width: 300px; height: 200px; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;图片无缝轮滚&lt;/h1&gt; &lt;hr&gt; &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;content&quot;&gt; &lt;div id=&quot;imglist&quot;&gt; &lt;img src=&quot;./imgs/mm041.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm042.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm043.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm044.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm045.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm046.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm047.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm048.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm049.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm050.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm051.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm052.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm053.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm054.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm055.jpg&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var width = imglist.offsetWidth; // console.log(width); // 将图片集合 复制一份,并追加到当前图片集合之后 content.appendChild(imglist.cloneNode(true)); // box.scrollLeft = 500; function scrollImage()&#123; if (box.scrollLeft &gt;= width) &#123; box.scrollLeft = 0; &#125; box.scrollLeft += 1; // console.log(box.scrollLeft); &#125; setInterval(scrollImage, 50); &lt;/script&gt;&lt;/body&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图片跑马灯儿&lt;/title&gt; &lt;style&gt; #show&#123; margin: 10px auto; width: 1202px; height: 302px; border: 1px solid #000; /*overflow: scroll;*/ overflow: hidden; &#125; #imgList&#123; height: 300px; width: 4800px; white-space:nowrap; &#125; img&#123; width: 400px; height: 300px; margin: 0; padding: 0; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;图片跑马灯儿&lt;/h1&gt; &lt;hr&gt; &lt;div id=&quot;show&quot;&gt; &lt;div id=&quot;imgList&quot;&gt; &lt;img src=&quot;./imgs/mm021.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm022.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm023.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm024.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm025.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm026.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm021.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm022.jpg&quot;&gt; &lt;img src=&quot;./imgs/mm023.jpg&quot;&gt; &lt;/div&gt; &lt;script&gt; setInterval(function()&#123; show.scrollLeft++; if (show.scrollLeft == 2400) &#123; show.scrollLeft = 0; &#125; &#125;,1) &lt;/script&gt;&lt;/body&gt; 下滑加载图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #imglist&#123; width: 90%; margin: 0 auto; &#125; #imglist img&#123; width: 600px; height: 400px; background: url(./imgs/loading.gif) no-repeat center center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;下滑加载图片&lt;/h1&gt; &lt;hr&gt; &lt;div id=&quot;imglist&quot;&gt; &lt;img data-src=&quot;./imgs/mm041.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm042.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm043.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm044.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm045.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm046.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm047.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm048.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm049.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm050.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm051.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm052.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm052.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm050.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm050.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm050.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm053.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm054.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm055.jpg&quot;&gt; &lt;img data-src=&quot;./imgs/mm055.jpg&quot;&gt; &lt;/div&gt; &lt;script&gt; var imgs = imglist.getElementsByTagName(&apos;img&apos;); // 获取 imglist 的宽度 var box_width = imglist.offsetWidth; // 获取 视口高度 var view_height = document.documentElement.clientHeight; // console.log(view_height); // 计算 横着 能加载几张图片 var x_number = Math.floor(box_width / imgs[0].offsetWidth); // console.log(x_number); // 首屏图片数量 // Math.ceil((视口的高度 - 首图到顶部的偏移量) / img的高度) * x_number var first_number = Math.ceil((view_height - imgs[0].offsetTop) / imgs[0].offsetHeight) * x_number; // console.log(first_number); // loadImage(0, 4); // loadImage(4, 2); // 全局计数的变量,用于记录加载到第几张 var m = 0; // 加载第一屏的图片 loadImage(m, first_number); // 更新加载记录数 m += first_number; /** * 加载图片 * @param start 从第几张开始加载 * @param length 加载几张图片 */ function loadImage(start, length)&#123; for (var i = start; i &lt; (start+length); i++) &#123; // 判断图片集合是否加载完毕 if (i &gt;= imgs.length) return; // console.log(i); (function (i)&#123; setTimeout(function()&#123; imgs[i].src = imgs[i].getAttribute(&apos;data-src&apos;); &#125;, 500); &#125;)(i); &#125; &#125; // 绑定滚动事件 window.onscroll = function ()&#123; // 判断图片集合是否加载完毕 if (m &gt;= imgs.length) return; // 获取 滚动条滚过的距离 var top= document.body.scrollTop || document.documentElement.scrollTop; // 还未加载的首图 到顶部的偏移量 var img_top = imgs[m].offsetTop; // console.log(top, img_top); // 判断加载下一批图片的临界点 if ((top + view_height) &gt;= img_top) &#123; // 加载下一批图片 loadImage(m, x_number); m += x_number; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 蛇形文字1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .strstyle &#123; font-size:20px; color: #f00; font-weight:700; position:absolute; top:-50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;蛇形文字&lt;/h1&gt;&lt;hr&gt; &lt;script&gt; //文字输出 var msg = &quot;JavaScript 蛇形文字...&quot;; for (var i = 0; i &lt; msg.length; i++) &#123; document.write(&apos;&lt;span id=&quot;str&apos;+i+&apos;&quot; class=&quot;strstyle&quot;&gt;&apos;); document.write(msg[i]); document.write(&apos;&lt;/span&gt;&apos;); &#125; //绑定鼠标移动事件,得到鼠标位置 document.onmousemove = function(e)&#123; e = e || window.event; document.title = &apos;X:&apos;+e.clientX+&apos;Y:&apos;+e.clientY; //让每个字之间 有延迟的统一行动! var m = 0; var timer = setInterval(function()&#123; // console.log(m); // 根据字数 控制次数 不能无限循环定时 if(m &lt; msg.length) &#123; // 调用文字运动轨迹函数 // x坐标,y坐标,第几个字 snake(e.clientX, e.clientY, m); m++; &#125;else&#123; //如果 次数大于等于字数,就清除定时 clearInterval(timer); &#125; &#125;,50); &#125; // 文字运动轨迹函数 function snake(x,y,i)&#123; //获得每一个span元素对象 var span = document.getElementById(&apos;str&apos;+i); // console.log(span); span.style.left = x + (i*25) + &apos;px&apos;; span.style.top = y + &apos;px&apos;; &#125; &lt;/script&gt;&lt;/body&gt; 模态框(Modal)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;模态框&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; list-style: none; text-decoration: none; &#125; a&#123; font-size: 40px; &#125; #modal &#123; width: 100%; height: 100%; display: none; position: fixed; left: 0;top: 0; right: 0;bottom: 0; background: rgba(55,55,55,0.55); &#125; #modalCeng&#123; width: 400px; height: 200px; background-color: #eee; border: 3px solid #f00; display: none; position: fixed; margin: 100px 50%; left: -200px; z-index: 99; &#125; #closeBtn&#123; position:absolute; right:5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;show()&quot;&gt;点击登录&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;modalCeng&quot;&gt; &lt;button onclick=&quot;dis()&quot; id=&quot;closeBtn&quot;&gt; X &lt;/button&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 密码: &lt;input type=&quot;password&quot; name=&quot;pass&quot;&gt; &lt;br&gt; &lt;button&gt;登录&lt;/button&gt; &lt;button onclick=&quot;dis()&quot;&gt;取消&lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;modal&quot;&gt;&lt;/div&gt; &lt;hr&gt; &lt;p&gt;line 1&lt;/p&gt; &lt;p&gt;line 2&lt;/p&gt; &lt;p&gt;line 3&lt;/p&gt; &lt;p&gt;line 4&lt;/p&gt; &lt;p&gt;line 5&lt;/p&gt; &lt;p&gt;line 6&lt;/p&gt; &lt;p&gt;line 7&lt;/p&gt; &lt;p&gt;line 8&lt;/p&gt; &lt;p&gt;line 9&lt;/p&gt; &lt;p&gt;line 10&lt;/p&gt; &lt;p&gt;line 11&lt;/p&gt; &lt;p&gt;line 12&lt;/p&gt; &lt;p&gt;line 13&lt;/p&gt; &lt;p&gt;line 14&lt;/p&gt; &lt;p&gt;line 15&lt;/p&gt; &lt;p&gt;line 16&lt;/p&gt; &lt;p&gt;line 17&lt;/p&gt; &lt;p&gt;line 18&lt;/p&gt; &lt;p&gt;line 19&lt;/p&gt; &lt;p&gt;line 20&lt;/p&gt; &lt;p&gt;line 21&lt;/p&gt; &lt;p&gt;line 22&lt;/p&gt; &lt;p&gt;line 23&lt;/p&gt; &lt;p&gt;line 24&lt;/p&gt; &lt;p&gt;line 25&lt;/p&gt; &lt;p&gt;line 26&lt;/p&gt; &lt;p&gt;line 27&lt;/p&gt; &lt;p&gt;line 28&lt;/p&gt; &lt;p&gt;line 29&lt;/p&gt; &lt;p&gt;line 30&lt;/p&gt; &lt;p&gt;line 31&lt;/p&gt; &lt;p&gt;line 32&lt;/p&gt; &lt;p&gt;line 33&lt;/p&gt; &lt;p&gt;line 34&lt;/p&gt; &lt;p&gt;line 35&lt;/p&gt; &lt;p&gt;line 36&lt;/p&gt; &lt;p&gt;line 37&lt;/p&gt; &lt;p&gt;line 38&lt;/p&gt; &lt;p&gt;line 39&lt;/p&gt; &lt;p&gt;line 40&lt;/p&gt;&lt;script&gt; var modal = document.getElementById(&apos;modal&apos;); var mc = document.getElementById(&apos;modalCeng&apos;); function show () &#123; modal.style.display = &apos;block&apos;; mc.style.display = &apos;block&apos;; &#125; function dis () &#123; modal.style.display = &apos;none&apos;; mc.style.display = &apos;none&apos;; &#125;&lt;/script&gt;&lt;/body&gt; 自定义输出表格(节点方式)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;XML DOM Table - 自定义&lt;/h1&gt; &lt;hr&gt; 行:&lt;input type=&quot;text&quot; name=&quot;num1&quot; id=&quot;num1&quot;&gt; 列&lt;input type=&quot;text&quot; name=&quot;num1&quot; id=&quot;num2&quot;&gt; &lt;button onclick=&quot;createTab()&quot; id=&quot;tabshow&quot;&gt;建立表格&lt;/button&gt; &lt;div id=&quot;tables&quot;&gt;&lt;/div&gt;&lt;script&gt; function createTab () &#123; //获取要生成的行列数 var rows = document.getElementById(&apos;num1&apos;).value; var cols = document.getElementById(&apos;num2&apos;).value; //创建table 和 tr节点 var tab = document.createElement(&apos;table&apos;); var tr = document.createElement(&apos;tr&apos;); tab.width = &apos;800&apos;; tab.border = &apos;1&apos;; tab.cellSpacing = &apos;0&apos;; tables.appendChild(tab);//添加节点 table tab.appendChild(tr);//添加节点 tr //th 表头部分 for (var i = 0; i &lt; cols; i++) &#123; var th = document.createElement(&apos;th&apos;); tr.appendChild(th); th.innerHTML = i; &#125; //rows x cols 创建表格内容 for (var i = 0; i &lt; rows; i++) &#123; tr = document.createElement(&apos;tr&apos;); tab.appendChild(tr); if (i%2 == 0 ) &#123; tr.style.backgroundColor=&apos;#f90&apos;; &#125; for (var j = 0; j &lt; cols; j++) &#123; var td = document.createElement(&apos;td&apos;); tr.appendChild(td); td.innerHTML = i +&apos;-&apos;+ j; &#125; &#125; &#125;&lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 基础05-JS DOM]]></title>
    <url>%2F2018%2F06%2F21%2FJavaScript%20%E5%9F%BA%E7%A1%8005-DOM%2F</url>
    <content type="text"><![CDATA[DOM1. DOM基本介绍DOM 是 Document Object Model 文档对象模型 HTML DOM XML DOM 2. HTML DOM 对象参考 2.1 document 对象 属性: domain lastModified referrer URL cookie 集合属性all 获取所有元素(IE中为true,非IE为false) 方法: 2.2 form 对象属性: 12-length 元素个数-elements 元素数组 方法: - submit() 提交指定的表单 - reset() 重置指定的表单事件: -onsubmit=&quot;return false&quot; 阻止提交表单,submit()方法可绕过 -onreset=&quot;return false&quot; 阻止重置表单,reset()方法可绕过 2.3 image 对象 2.4 anchor 对象 2.5 base 对象 2.6 canvas 对象http://echarts.baidu.com/ 2.7 Event 对象 2.8 input 系列对象 blur() focus() select()复制 flash或clipboard.js组件 2.9 select 对象 2.10 option 对象 2.11 style 对象 2.12 table 对象 2.13 tableRow 对象 2.14 tableCell 对象 3.XML DOM 节点1.节点介绍 1.1 什么是节点 node HTML 文档中 所有的组成部分 称之为节点 doucment 文档 element 标签 attr 属性 (attribute) comment 注释 text 文本 1.2 节点树子节点父节点同辈节点后代节点先辈节点 1.3 节点的访问 得到节点 doucment 文档document element 标签ByID… attr 属性 (attribute)getAttributeNode(attrname) comment 注释子节点 text 文本子节点 获取子节点childNodes 获取子元素节点children 获取第一个子节点firstChild 获取最后一个子节点lastChild 获取父节点parentNode 获取父元素节点parentElement 获取前一个节点previousSibling 获取后一个节点nextSibling 1.4 节点属性 nodeName doucment #document element 标签名 attr 属性名 text #text comment #comment nodeValue doucment null element null attr 属性值 text 文本内容 comment 注释内容 nodeType doucment 9 element 1 attr 2 text 3 comment 8 2.节点操作2.1 获取节点 element ById/子节点/父节点/同辈节点/后代 attr getAttributeNode(‘attrname’); 获取属性节点element.attr; 获取属性值 getAttribute(&apos;attrname&apos;); 获取属性值 2.2 改变节点(改变节点的值) nodeValue element 无意义 attr setAttribute(&apos;attrname&apos;, &apos;value&apos;); element.attr = value; 2.3 删除节点 attr removeAttribute(‘attrname’); element 把值赋值为空 或 removeChild(node) 需要找到父节点 2.4 替换节点 attr setAttribute(‘attrname’, ‘value’); element replaceChild(new_node, old_node) 需要找到父节点 2.5 插入节点 attr setAttribute(&apos;attrname&apos;, &apos;value&apos;); setAttributeNode(&apos;attrname&apos;); element appendChild(node) 追加 insertBefore(new_node, old_node) 指定位置 2.6 创建节点 attr document.createAttribute(attrname); element document.createElement(‘tagName’); 2.7 克隆节点 cloneNode() 参数默认为false / 可选 true 3. XML 对象 node nodeList document element attr text comment 4. HTMLElement对象1234567891011121314151617181920212223className 类名scrollLeft 滚动条至 左边界像素scrollTop 滚动条至 上边界像素offsetLeft 距离已定位父元素的 左偏移量offsetTop 距离已定位父元素的 上偏移量innerHTML 元素内部的内容(不含标签)innerText 元素内部所有的文本内容outerHTML 元素的内容(含标签)offsetWidth 盒子模型,实际的宽: 内容+内边距+边框offsetHeight 盒子模型,实际的高: 内容+内边距+边框clientWidth 宽 + 内边距clientHeight 高 + 内边距scrollWidth 宽 + 内边距 + 计算里面元素的大小scrollHeight 高 + 内边距 + 计算里面元素的大小document.documentElement.clientHeight 视口高度document.documentElement.scrollHeight 文档高度 PS. 补充 PS1. DOM 元素对象的 属性和方法http://www.runoob.com/jsref/dom-obj-all.html PS2. MDN文档 Mozilla 开发者社区(MDN):https://developer.mozilla.org/zh-CN/ JavaScript MDN文档https://developer.mozilla.org/zh-CN/docs/Web/JavaScript 特效-全选复制按钮1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;h1&gt;input&lt;/h1&gt;&lt;hr&gt;&lt;input type=&quot;text&quot; id=&quot;s&quot;&gt; &lt;button&gt;百度一下&lt;/button&gt;&lt;hr&gt;&lt;br&gt;&lt;button onclick=&quot;selectAll()&quot;&gt;全选&lt;/button&gt;&lt;button onclick=&quot;copyAll()&quot;&gt;全选复制&lt;/button&gt;&lt;button class=&quot;btn&quot; data-clipboard-target=&quot;#content&quot;&gt;全选复制(clip)&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;textarea name=&quot;weibo&quot; id=&quot;content&quot; cols=&quot;40&quot; rows=&quot;10&quot;&gt;诗人对宇宙人生，须入乎其内，又须出乎其外。入乎其内，故能写之。出乎其外，故能观之。入乎其内，故有生气。出乎其外，故有高致。美成能入而不出。白石以降，于此二事皆未梦见。&lt;/textarea&gt;&lt;script src=&quot;./clipboard.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;s.focus();function selectAll()&#123; content.select();&#125;function copyAll()&#123; // 判断 剪切板对象 是否可用 if (window.clipboardData) &#123; // IE window.clipboardData.setData(&apos;text&apos;, content.value); alert(&apos;已复制到剪切板!&apos;); &#125; else &#123; // 非IE content.select(); alert(&apos;请按 Ctrl + C 复制!&apos;); &#125;&#125;var clipboard = new ClipboardJS(&apos;.btn&apos;);clipboard.on(&apos;success&apos;,function(e)&#123; console.log(e); alert(&apos;已复制到剪切板(clip)&apos;);&#125;);&lt;/script&gt; 特效-瀑布流效果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 &lt;h1&gt;瀑布流效果&lt;/h1&gt; &lt;hr&gt; &lt;div id=&quot;imglist&quot;&gt; &lt;img c-src=&quot;./imgs/mm021.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm022.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm023.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm024.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm025.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm026.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm027.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm028.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm029.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm030.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm031.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm032.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm033.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm034.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm035.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm036.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm037.jpg&quot;&gt; &lt;img c-src=&quot;./imgs/mm038.jpg&quot;&gt; &lt;/div&gt; &lt;script&gt; var picNum = 3 setTimeout(&apos;loadPic(picNum)&apos;,1000); var imgs = imglist.children;function loadPic(x)&#123; // 获取所有图片节点 console.log(cl); var i = 0; var cl = setInterval(function()&#123; imgs[i].setAttribute(&apos;src&apos;,imgs[i].getAttribute(&apos;c-src&apos;)); console.log(i); i++; if (i &gt;= x) &#123; clearInterval(cl); &#125; &#125;,10) &#125; // if (true) &#123;&#125; window.onscroll = function()&#123; var clientY = document.documentElement.clientHeight; var scrollY = document.documentElement.scrollHeight; var top = document.documentElement.scrollTop; console.log(top); if (scrollY-clientY-1000 &lt;= top) &#123; picNum+=1; console.log(picNum); loadPic(picNum); &#125; &#125; &lt;/script&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JS DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 基础04-JS BOM]]></title>
    <url>%2F2018%2F06%2F10%2FJavaScript%20%E5%9F%BA%E7%A1%8004-BOM%2F</url>
    <content type="text"><![CDATA[BOM1. 什么是BOMBrowser Object Model 浏览器对象模型 2. JavaScript 对象层次2.1 对象种类 自定义对象 Obejct 内置对象 A/S/N/B/M/D/R/G BOM 浏览器对象模型 DOM 文档对象模型 2.2 对象树 (倒树状结构)123456789 window |history location document screen navigator | doc html | head body | | mate link div p li span ... 3. BOM 对象3.1 window 描述整个浏览器窗口的 它是JS中 所有对象的根对象 使用window的属性和方法时,可以省略window的调用 自定义对象/变量/函数 属性: 见手册 方法: setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 clearInterval() 取消由 setInterval() 设置的 timeout。 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 alert() 警告框 confirm() 确认框 prompt() 输入框 open() 打开新窗口 close() 关闭窗口,只能关闭自己打开过的窗口 print() 打印 srcollTo() 滚到哪去 srcollBy() 滚多少 3.2 history 属性: length 方法: back() forward() go() 3.3 location 属性: href protocol hostname host pathname search hash 方法: reload() assign() replace() 3.4 screen 属性 width 屏幕宽度 height 屏幕高度 3.5 navigatorwindow操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;h1&gt;window&lt;/h1&gt;&lt;hr&gt;&lt;button onclick=&quot;run()&quot;&gt;打个招呼&lt;/button&gt;&lt;hr&gt;&lt;button onclick=&quot;window.open()&quot;&gt;打开一个新窗口&lt;/button&gt;&lt;button onclick=&quot;window.open(&apos;http://www.163.com&apos;)&quot;&gt;open : 163.com&lt;/button&gt;&lt;button onclick=&quot;window.open(&apos;http://m.baidu.com&apos;,&apos;&apos;, &apos;width=300,height=600&apos;)&quot;&gt;open(指定大小)&lt;/button&gt;&lt;button onclick=&quot;window.open(&apos;http://m.toutiao.com&apos;,&apos;jianjian&apos;)&quot;&gt;open(指定在哪个窗口打开)&lt;/button&gt;&lt;button onclick=&quot;window.close()&quot;&gt;关闭窗口&lt;/button&gt;&lt;button onclick=&quot;window.print()&quot;&gt;打印&lt;/button&gt;&lt;script&gt;window.name = &apos;jianjian&apos;;var obj = &#123;name:&quot;静静&quot;&#125;console.log(obj);console.log(window.obj);var a = 110;console.log(window.a);function demo()&#123; console.log(&apos;呆毛...&apos;);&#125;window.demo();// - alert() 警告框// var a = alert(&apos;警告框&apos;);// console.log(a); // undefined// - confirm() 确认框// var a = confirm(&apos;确认框&apos;);// console.log(a); // true/false// - prompt() 输入框// var a = prompt(&apos;请输入您的银行卡密码:&apos;);// console.log(a); // ...// if (confirm(&apos;你喜欢球吗??&apos;)) &#123;// alert(&apos;好巧,我也喜欢!&apos;);// &#125; else &#123;// alert(prompt(&apos;为什么不喜欢???&apos;));// &#125;function run()&#123; do &#123; // 弹出输入框 var name = prompt(&apos;您贵姓?&apos;); // 确认信息框 var content = confirm(&apos;您输入的是: [ &apos; + name + &apos; ]\n,是否确认?&apos;); &#125; while (!content); alert(&apos;Hi~ o(*￣▽￣*)ブ, 小&apos;+ name+name);&#125;&lt;/script&gt; history操作123456789101112131415&lt;h1&gt;history&lt;/h1&gt;&lt;hr&gt;&lt;button onclick=&quot;history.back()&quot;&gt;上一步(后退)&lt;/button&gt;&lt;button onclick=&quot;history.forward()&quot;&gt;下一步(前进)&lt;/button&gt;&lt;button onclick=&quot;history.go(1)&quot;&gt;下一步&lt;/button&gt;&lt;button onclick=&quot;history.go(-2)&quot;&gt;上2步&lt;/button&gt;&lt;script&gt;console.log(window.history);console.log(history.length); // 当前本页面打开过的历史记录数量&lt;/script&gt; location操作1234567891011121314151617181920212223242526272829&lt;h1&gt;location&lt;/h1&gt;&lt;hr&gt;&lt;button onclick=&quot;location.reload()&quot;&gt;刷新&lt;/button&gt;&lt;!-- JS 跳转一个页面 --&gt;&lt;button onclick=&quot;location.assign(&apos;http://acfun.cn&apos;)&quot;&gt;assign&lt;/button&gt;&lt;button onclick=&quot;location.replace(&apos;http://bilibili.com&apos;)&quot;&gt;replace&lt;/button&gt;&lt;button onclick=&quot;location.href=&apos;http://xiazaiav.com&apos;&quot;&gt;href&lt;/button&gt;&lt;script&gt;// console.log(window.location);console.log(&apos;URL: &apos; + location.href);console.log(&apos;协议: &apos; + location.protocol);console.log(&apos;主机名: &apos; + location.hostname);console.log(&apos;主机名+端口号: &apos; + location.host);console.log(&apos;路径: &apos; + location.pathname);console.log(&apos;参数: &apos; + location.search);console.log(&apos;锚点: &apos; + location.hash);// location.href = &apos;http://acfun.cn&apos;;// location.search = &apos;?age=18&apos;;location.hash = &apos;#p18&apos;;&lt;/script&gt; screen-navigator操作12345678910111213141516171819202122232425262728293031323334353637383940&lt;h1&gt;screen / navigator&lt;/h1&gt;&lt;hr&gt;&lt;script&gt;console.log(window.screen);console.log(window.screen.availHeight); console.log(window.navigator);console.log(window.navigator.appVersion);console.log(window.navigator.userAgent);// 检测用户的终端设备var browser = &#123; versions: (function()&#123; var u = navigator.userAgent; var app = navigator.appVersion; return &#123; trident: u.indexOf(&apos;Trident&apos;) &gt; -1, // IE内核 presto : u.indexOf(&apos;Presto&apos;) &gt; -1, // Opera内核 webKit : u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, // 苹果谷歌内核 gecko : u.indexOf(&apos;Gecko&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;KHTML&apos;) == -1, // 火狐内核 mobile : !!u.match(/AppleWebKit.*Mobile.*/) || !!u.match(/AppleWebKit/), // 是否为移动端 ios : !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), // ios终端 android: u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1, // android终端 或 uc浏览器 iPhone : u.indexOf(&apos;iPhone&apos;) &gt; -1 || u.indexOf(&apos;Mac&apos;) &gt; -1, // 是否为iPhone 或 QQHD浏览器 iPad : u.indexOf(&apos;iPad&apos;) &gt; -1, // 是否为iPad webApp : u.indexOf(&apos;Safari&apos;) == -1 // 是否为web应用程序,没有头部和底部 &#125;; &#125;)()&#125;document.write(&apos;是否为移动端:&apos; + browser.versions.mobile + &apos;&lt;br&gt;&apos;);document.write(&apos;是否为ios端:&apos; + browser.versions.ios + &apos;&lt;br&gt;&apos;);document.write(&apos;是否为android终端:&apos; + browser.versions.android + &apos;&lt;br&gt;&apos;);document.write(&apos;是否为chrome浏览器:&apos; + browser.versions.webKit + &apos;&lt;br&gt;&apos;);document.write(&apos;是否为FireFox浏览器:&apos; + browser.versions.gecko + &apos;&lt;br&gt;&apos;);&lt;/script&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JS BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 基础03-对象数组事件]]></title>
    <url>%2F2018%2F05%2F27%2FJavaScript%20%E5%9F%BA%E7%A1%8003-%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1.JS 数组声明数组 1 使用 Array() 构造函数方式 var list = new Array(); // 空数组 var list = new Array(length); // 定义数组 初始长度 var list = new Array(v1,v2,v3); // 指定初始值 2 JSON 方式 var list = []; // 空数组 var list = [v1,v2,v3]; // 指定初始值 数组特点 不能使用 [] 的形式去追加数组元素,想要追加的请使用 push() JS数组的下标是连续的, 跳跃着赋值数组元素的话,中间的元素会自动赋值为undefined JS 只有索引数组,没有关联数组 遍历 for 适合遍历从页面中获取到的元素集合对象 for-in 适合遍历对象 数组 属性见手册 数组 方法 不改变原数组的方法: concat() join() slice() 改变原数组的方法: reverse() push() pop() unshift() shift() sort() 2.JavaScript 的内置对象BooleanBoolean 对象的声明 直接赋值 转换函数 构造函数 NumberNumber 对象的声明 直接赋值 转换函数 构造函数 Number的属性 Number的方法 StringString 对象的声明 直接赋值 转换函数 构造函数 String 的属性 String 的方法 RegExpRegExp 对象的声明 直接赋值 RegExp 构造函数 RegExp的方法 RegExp 示例 Date获取 date 对象 获取 date 中的信息 设置 date MathMath 的属性 Math 的方法 Array已学习 3.JavaScript 事件1. 事件的绑定 事件作为 元素的属性 1&lt;tagName event="JS code..."&gt;&lt;/tagName&gt; 事件作为 元素对象的属性 12element.onclick = function()&#123;&#125;element.onclick = funName; 事件监听(标准) 12非IE: element.addEventListener('event', funName, false);IE: element.attachEvent('onevent', funName); 2. 解除绑定 第1种和第2种的绑定方式 12element.event = function()&#123;&#125;element.event = null; 监听方式 12非IE: element.removeEventListener('event', funName, false);IE: element.detachEvent('onevent', funName); 3. 给一组元素绑定事件和this的使用 循环绑定事件,获取触发事件的元素对象时,需要使用 this 元素内部绑定事件时 传入this, 表示该元素对象自己 4. 闭包 closure 在循环绑定事件时,将循环变量保留下来时,就需要使用闭包 用一组元素 去控制另一组元素时,建议使用闭包 语法: 1234567for( ... ) &#123; (function (i,x,y)&#123; element.event = function()&#123; // 使用 i,x,y &#125; &#125;)(i,x,y);&#125; 5. 常用事件5.1 鼠标事件 onclick 单击触发 ondblclick 双击触发 oncontextmenu 右击触发/return false阻止系统菜单 onmouseover 鼠标指向触发 onmouseout 鼠标移开触发 onmousedown 鼠标按下触发 onmouseup 鼠标松开触发 onmousemove 鼠标移动触发 5.2 键盘事件 onkeydown 按下按键触发 onkeyup 松开按键触发 onkeypress 按下并松开触发(JS高级事件)不是所有的按键都能触发,无输出的按键 就不能触发 (方向键/shift/alt/ctrl/tab/大小写) 5.3 表单事件 onsubmit 表单被提交时触发 onreset 表单被重置时触发 onfocus 获取焦点时触发 onblur 失去焦点时触发 onchange 改变表单控件的内容或状态时就触发`用于input元素时,value值变化且失焦才触发` oninput 非IE: 输入时输入时(input/textarea) onpropertychange IE: 输入时输入时(input/textarea) onselect 选中时触发 5.4 框架/对象事件 onload 文档加载完触发/图片加载完触发 onunload 文档关闭时触发 IE onbeforeunload 文档关闭时触发 非IE浏览器阻止了关闭前的弹框 需要return &quot;string...&quot; onabort 图片加载过程中中断触发 onerror 图片加载错误触发 onresize 窗口/框架大小变化时触发 onscroll 元素滚动条在滚动时触发 5.5 其他事件 oncopy 拷贝内容时触发 oncut 剪切内容时触发 onpaste 粘贴内容时触发 onplay 音/视频开始播放时触发(audio/video) onpause 音/视频暂停时触发(audio/video) onended 音/视频播放结束时触发(audio/video) // Chrome 73+ 自动处理 play 状态// https://www.tuicool.com/articles/J363M3v 6. Event 事件对象6.1 获取事件内部 传入 en 获取使用var en = en || window.event; 6.2 属性12345en.x/en.clientX 鼠标的x坐标en.y/en.clientY 鼠标的y坐标en.button 鼠标的按键码: 0左键/1中键/2右键/3后退键/4前进键en.offsetX 鼠标相对于触发事件元素的 x 坐标en.offsetY 鼠标相对于触发事件元素的 y 坐标 7. 常用HTML元素属性123456789101112innerHTML 双标签之间的文本当前元素 相对与body 或已定位的父元素的 偏移量offsetTopoffsetLeft当前元素 左边缘或顶边缘 滚过的像素值scrollTopscrollLeftclassName 当前元素的class属性值tagName 当前元素的标签名 PS.补充 JS 中的随机数的产生. Math.random() 函数 返回 0 和 1 之间的伪随机数可能为 0, 但总是小于 1 123456789101112// 生成 min-max,包含 min 但不包含 max 的整数:parseInt(Math.random() * (max-min) + min, 10);// 生成min-max,不包含 min 但包含 max 的整数:Math.floor(Math.random() * (max-min) + min) + 1;// 生成 min-max,不包含 min 和 max 的整数:Math.round(Math.random() * (max-min) + min + 1);// 生成min-max ,包含 min 和 max 的随机数:Math.round(Math.random() * (max-min)+min);Math.floor(Math.random() * ((max-min)+1) + min); 特效-下载进度条123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt; &lt;h1&gt;下载进度条&lt;/h1&gt; &lt;hr&gt; &lt;button onclick=&quot;start()&quot; id=&quot;but&quot;&gt;开始下载&lt;/button&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;color&quot;&gt; &lt;span id=&quot;tip&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //获取color的宽度 var container=document.getElementById(&apos;container&apos;); var color=document.getElementById(&apos;color&apos;); var tip=document.getElementById(&apos;tip&apos;); var but=document.getElementById(&apos;but&apos;); console.log(but.onclick); // 设置每次调用设置color宽度 var w=0; function download()&#123; color.style.width=w+&apos;%&apos;; w++; tip.innerHTML=(w-1)+&apos;%&apos;; but.onclick=stop; but.innerHTML=&apos;暂停下载&apos;; console.log(but.onclick); if (w&gt;100) &#123; clearInterval(c1); // alert(&apos;下载完成&apos;); tip.innerHTML=&apos;下载完成&apos;; but.innerHTML=&apos;下载完毕&apos;; but.onclick=start; &#125; &#125; // 点击start开启定时器 function start()&#123; if (w&lt;100) &#123; c1 = setInterval(&apos;download()&apos;,50) &#125; &#125; function stop()&#123; clearInterval(c1); but.onclick=start; but.innerHTML=&apos;继续下载&apos;; console.log(but.onclick); &#125; &lt;/script&gt; 特效-图层拖拽12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图层拖拽&lt;/title&gt; &lt;style&gt; #box&#123; width: 100px; height: 100px; border: 1px solid #000; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;图层拖拽&lt;/h1&gt; &lt;hr&gt; &lt;div id=&quot;box&quot;&gt; &lt;/div&gt; &lt;script&gt; var box = document.getElementById(&apos;box&apos;); box.onmousedown = function(en)&#123; var en = en || window.event; box.style.background=&apos;#00eef3&apos;; box.innerHTML=&apos;按住&apos;; console.log(box.style); document.onmousemove = function(env)&#123; var env = env || window.event; box.style.top=env.y-en.offsetY+&apos;px&apos;; box.style.left=env.x-en.offsetX+&apos;px&apos;; console.log(box.style.top); console.log(box.style.left); &#125; &#125; document.onmouseup = function()&#123; box.style.background = &apos;#fff&apos;; box.innerHTML=&apos;松开&apos;; document.onmousemove = null; &#125; &lt;/script&gt;&lt;/body&gt; 特效-地址联动1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;h1&gt;JS onchange 地址联动实例&lt;/h1&gt;&lt;hr&gt;&lt;select name=&quot;con&quot; id=&quot;con&quot;&gt;&lt;/select&gt;&lt;select name=&quot;city&quot; id=&quot;city&quot;&gt;&lt;/select&gt;&lt;script&gt;// 声明数组// 国家的信息var conList = [&apos;中国&apos;, &apos;美国&apos;, &apos;英国&apos;, &apos;日本&apos;, &apos;德国&apos;];// 城市的信息 二维数组var cityList = new Array();cityList[0] = [&apos;北京&apos;, &apos;上海&apos;, &apos;天津&apos;, &apos;重庆&apos;, &apos;南京&apos;];cityList[1] = [&apos;纽约&apos;, &apos;洛杉矶&apos;, &apos;芝加哥&apos;, &apos;旧金山&apos;, &apos;华盛顿&apos;];cityList[2] = [&apos;伦敦&apos;, &apos;伯明翰&apos;, &apos;曼彻斯特&apos;, &apos;剑桥&apos;, &apos;爱丁堡&apos;];cityList[3] = [&apos;东京&apos;, &apos;北海道&apos;, &apos;福冈县&apos;, &apos;广岛&apos;, &apos;大阪&apos;];cityList[4] = [&apos;柏林&apos;, &apos;汉堡&apos;, &apos;慕尼黑&apos;, &apos;科隆&apos;, &apos;法兰克福&apos;];// 获取下拉框 填充国家或城市var con = document.getElementById(&apos;con&apos;);var city = document.getElementById(&apos;city&apos;);// console.log(con, city);// 填充国家下拉框选项for (var i = 0; i &lt; conList.length; i++) &#123; // con.innerHTML += &apos;&lt;option value=&quot;&apos;+i+&apos;&quot;&gt;&apos;+conList[i]+&apos;&lt;/option&gt;&apos;; con.add(new Option(conList[i], i));&#125;// 绑定onchange事件到第一个下拉框之上con.onchange = function () &#123; // 清空之前的选项 // city.innerHTML = &apos;&apos;; city.options.length = 0; // 根据value值 获取被选中的option信息 var index = con.value; // console.log(index); // 根据索引值,去取出对应的城市信息 var citys = cityList[index]; // console.log(citys); // 填充城市信息 for (var i = 0; i &lt; citys.length; i++) &#123; city.add(new Option(citys[i], i)); &#125;&#125;// 手动触发onchange一次con.onchange();&lt;/script&gt; 特效-resize事件123456789101112131415161718192021222324252627&lt;h1&gt;JS onresize 事件&lt;/h1&gt; &lt;hr&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; window.onresize = function()&#123; box.innerHTML = Math.random(); // 随机背景颜色 // // rgb(0,0,0) ~ rgb(255,255,255) // var r = Math.floor(Math.random() * 100000 % 256); // var g = Math.floor(Math.random() * 100000 % 256); // var b = Math.floor(Math.random() * 100000 % 256); // console.log(r,g,b); // document.body.style.backgroundColor = &apos;rgb(&apos;+r+&apos;,&apos;+g+&apos;,&apos;+b+&apos;)&apos;; // 0~9a~f &gt;&gt;&gt; [0,1,2,3,4,....e,f] // #000000 ~ #ffffff var color = &apos;#&apos; + Math.floor(Math.random() * 16777215).toString(16); document.body.style.backgroundColor = color; // 2147483647 int // 10485760 =&gt; 10M // 1048576 =&gt; 1M &#125; &lt;/script&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 基础02-js函数]]></title>
    <url>%2F2018%2F05%2F22%2FJavaScript%20%E5%9F%BA%E7%A1%8002-js%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[JS 函数1. 函数的声明 function 关键字方式function 函数名([形参]) {JS 代码} 表达式方式var 函数名 = function([形参]) {JS 代码} Function 构造函数方式var 函数名 = new Function(‘参数1’, ‘JS 代码’); 2. 调用函数 加括号才是调用 不加括号 是引用 该函数 3. JS 函数特点 函数没有返回值 默认返回undefined 函数可以重复定义的 4. JS 函数中的参数 形参与实参 实参个数 &gt; 形参个数 多余的实参会被忽略 实参个数 &lt; 形参个数 未赋值的参数 会被自动赋值为 undefined 参数的默认值 在函数内部判断 是否是undefined. 做赋值 可变参数个数 arguments 获取所有传递的是参数,是一个数组对象 5. JS 中的变量作用域 全局和局部变量 在函数内 使用 var 定义的是 局部变量 在函数外 使用 var 定义的是 全局变量 在函数内/外 不使用 var 定义的是 全局变量 6. JS 的作用域链函数的执行 依赖于变量的作用域 这个作用域是在 函数定义声明时决定的，而不是 函数调用时决定的！ 如果当前作用域里 没有声明变量，则向上一层作用域里面找. 如果直到找到全局里 还都未找到，则在执行函数时 会报错. 7. 自执行函数 与 闭包7.1 自执行12( function()&#123;console.log(1)&#125; )()( function()&#123;console.log(2)&#125; () ) 这种写法的含义是将函数声明转换成函数表达式，消除了 JS 引擎识别函数表达式和函数声明的歧义. 它告诉 JS 引擎这是一个函数表达式，不是函数声明。并且可以在后面加括号，立即执行函数的内的代码. 7.2 闭包简单说，闭包就是 能够读取 其他函数内部变量的 函数。 由于在 JS 中，只有函数内部的 子函数 才能读取 局部变量，因此可以把闭包 简单理解成 “定义在一个 函数内部的 函数”。 所以，在本质上，闭包就是将 函数内部 和 函数外部 连接起来的一座桥梁。 闭包的最大用处有两个 一个是可以读取 函数内部的变量， 另一个就是 让这些变量的值 始终保持在内存中。 特效-倒计时同意1234567891011121314151617181920&lt;h3&gt;10s倒计时生效按钮&lt;/h3&gt;&lt;button id=&quot;btn&quot; disabled onclick=&quot;alert(&apos;已同意!&apos;)&quot;&gt;同意(10)&lt;/button&gt;&lt;script&gt; m = 10; function showbtn() &#123; var btn = document.getElementById(&apos;btn&apos;); if (m &lt;= 0) &#123; btn.disabled = false; btn.innerHTML = &apos;同意&apos;; return; &#125; btn.innerHTML = &apos;同意(&apos;+m+&apos;)&apos;; m--; setTimeout(&quot;showbtn()&quot;, 1000); &#125; showbtn();&lt;/script&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 基础操作-OOP面向对象]]></title>
    <url>%2F2018%2F05%2F13%2FMySQL%20%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[2.面向对象1.类简介 主要内容包括 类 和 对象 1.类 ​ class类中主要两种元素，函数（方法），变量（属性） ​ 函数不调用不执行功能，类不实例化为对象无法使用 设计类的时候，需要考虑什么：（一切皆对象） 该类有什么（属性）？ 该类会什么（方法）？ 注意： 类本身是无法执行的，本身是虚构的，不存在的 对象才是真正能使用的 类与对象之间的关系 类 就是对象的抽象化 对象 就是类的实例化 格式 12345class 类名&#123; 成员属性 成员方法&#125; 6.实例 12345678910111213141516171819202122232425262728293031323334class Beauty&#123; public $name = &apos;迪丽热巴&apos;; #属性 public $age = 18; public $weight = &apos;90斤&apos;; public $height = &apos;180cm&apos;; public function skill1() #方法 &#123; echo &apos;吹&apos;; &#125; public function skill2() &#123; echo &apos;拉&apos;; &#125; public function skill3() &#123; echo &apos;弹&apos;; &#125; public function skill4() &#123; echo &apos;唱&apos;; &#125;&#125;$obj = new Beauty; #实例化echo $obj-&gt;name; #对象 -&gt; 属性名echo $obj-&gt;height;echo $obj-&gt;weight;$obj-&gt;skill1(); #对象 -&gt; 方法名()$obj-&gt;skill2();$obj-&gt;skill3(); 总结： ​ 1、在使用之前，要先将类实例化为对象，即：类-&gt;对象 ​ $对象名 = new 类名; ​ 2、输出属性时，格式为：对象 -&gt; 属性名 ​ echo $obj-&gt;name; ​ 3、调用方法时，格式为：对象 -&gt; 方法名() ​ $obj-&gt;skill(); 2.伪对象1.定义 ​ 在类的内部，可以使用自己的属性or方法，此时， $this 代表当前对象 称为伪对象 2.实例 1234567891011121314151617181920212223class Beauty &#123; public $name = &apos;迪丽热巴&apos;; public $age = 18; public $weight = &apos;90斤&apos;; public $height = &apos;180cm&apos;; public function skill1()&#123;echo &apos;吹&apos;;&#125; public function skill2()&#123;echo &apos;拉&apos;;&#125; public function skill3()&#123;echo &apos;弹&apos;;&#125; public function skill4()&#123;echo &apos;唱&apos;;&#125; public function demo()&#123;// 类的内部, 使用自己的属性or方法 $x = new Beauty; echo $x-&gt;name; $x-&gt;skill4(); echo &apos;&lt;hr&gt;&apos;; echo $this-&gt;name; $this-&gt;skill4(); echo &apos;&lt;hr&gt;&apos;; &#125; &#125; &#125; 总结： ​ 伪对象$this代表当前对象, 在哪个类中使用, 就相当于$this = new 当前类名 ​ $this不需要实例化, 可直接使用. ​ $this只能在类内使用 3.连贯操作​ 若要在执行时连续调用方法，可采用如下格式： ​ 1. $obj-&gt;step1()-&gt;step2()-&gt;step3()...; ​ 2.将连续调用的前面的方法加上return $this 注意：若直接采用1，而不return返回对象，会报错 Call to a member function step2() on null 相当于null-&gt;step2() 4.魔术方法1.定义：​ 魔术方法，就是在指定条件触发时，会自动调用的方法，这里主要介绍两种 ​ __construct() 构造方法 ​ __destruct() 析构方法 2.构造方法​ 触发条件：在实例化时，自动触发 ​ 使用场合：常用于初始化属性 ​ 注意：一般构造都写在方法的最前面，属性的最后面 1234567891011121314151617class Lengend&#123; #构造方法 public function __construct() &#123; echo &apos;&lt;h1&gt;欢迎来到召唤师峡谷&lt;/h1&gt;&apos;; &#125; #普通方法 public function demo() &#123; echo &apos;升段局，掉2挂1，人马加大树强撑40分钟，队友重连绝地翻盘&lt;hr&gt;&apos;; &#125;&#125;$obj=new Lengend;$obj-&gt;__construct();// $obj-&gt;demo(); 3.析构方法​ 触发条件：当对象被销毁时，自动触发，包括： ​ 1）.程序全部执行完，自然销毁 ​ 2）.对象被主动删除了 ​ 3）.对象被覆盖了（更换） ​ 使用场合：当对象使用完的一些扫尾操作（fclose、closedir） ​ 注意：一般析构方法都写在方法的最后面 1234567891011121314151617181920class Lengend&#123; public function demo() &#123; echo &apos;开始一盘游戏&apos;; echo &apos;&lt;hr&gt;&apos;; &#125; public function __destruct() &#123; echo &apos;关上电脑&apos;; &#125;&#125;$obj=new Lengend;$obj-&gt;demo();echo &apos;断电了&lt;br&gt;&apos;;unset($obj); #2)对象被主动删除$obj=&apos;迪丽热巴&apos;; #3)换对象了 #1)自然结束，就会销毁$obj,从而触发析构 4.实例化PDO类​ PDO 数据抽象层，专门负责数据库操作管理 12345678$dsn=&apos;mysql:host=localhost;dbname=&apos;test&apos;;charset=utf8;$user=&apos;root&apos;;$pwd=&apos;&apos;;$pdo=new PDO($dsn,$user,$pwd); #1.链接数据库$sql=&apos;select id,nickname,tel,address from user&apos;; #2.编写sql语句$pdostatement=$pdo-&gt;query($sql); #3.执行sql语句$result=$pdostatement-&gt;fetchAll(PDO::FETCH_NUM); #4.解析对象var_dump($result); #5.输出结果 总结： ​ 1.PDO类::方法 PDO::query( ) 执行一条SQL语句 成功返回PSOStatement，适合查询，失败返回false PDO::exec( ) 执行一条SQL语句 成功返回受影响的行数，适合增删改，失败返回false PDO::lastInsertId( ) 获取最近一次插入的ID 成功返回最新的id，失败返回 &#39;0&#39; 字符 PDO::errorInfo( ) 获取错误信息 ​ 2.PDOStatement类::方法 PDOStatement::fetch( ) 获取结果集中的一条数据（依靠指针）失败返回false PDOStatement::fetchAll( ) 获取结果集中的所有数据，参数设置显示格式 PDO::FETCH_NUM 索引数组格式 PDO::FETCH_ASSOC 关联数组格式 PDO::FETCH_BOTH 混合数组格式 3.OOP面向对象面向对象OOP的三大特性：1.封装性 ；2.继承性 ；3.多态性 1.封装性 定义：将对象的所有成员结合在一起，形成一个不可分割的独立单位 目的：尽可能的隐藏属性 和 方法，只留下部分接口与外部联系 提供以下三种修饰符，来控制与外部的联系 修饰符 本类 继承类 类外 public √ √ √ 公有的 protected √ √ x 受保护的 private √ x x 私有的 想要有高安全性 或者 只想自己使用的，最好设置为private。 2.魔术方法 如果在类外使用私有属性或方法，程序会立即终止并报错 为了避免终止程序，可以使用一些魔术方法做提示，并绕过error错误 __get($x) 当访问权限不足或不存在的属性时，自动触发，返回访问属性名 __set($x,$y) 当设置权限不足或不存在的属性时，自动触发，返回设置属性名和值 __unset($x) 当删除权限不足或不存在的属性时，自动触发，返回要删除的属性名 __isset($x) 当判断是否存在的目标权限不足或不存在时触发，返回要判断的属性名 __call($x,$y) 当访问权限不足或不存在的方法时，自动触发，返回方法名和实参 __tostring() 当echo对象时触发，返回字符串值 3.继承性 定义：子类（-派生类/扩展类）继承父类（基础类/基类）的一些属性和方法 格式 class 子类 extends 父类 {} 实例 1234567891011121314class laozi&#123; public $name = &apos;老王&apos;; public function skill() &#123; echo &apos;喜欢去隔壁转转 &lt;br&gt;&apos;; &#125;&#125;class son extends laozi&#123;&#125;$obj = new son; #实例化子类echo $obj-&gt;name; #直接调用子类继承的属性$obj-&gt;skill(); #直接调用子类继承的方法 特点 子类可以继承属性，方法（除了private） 子类可以重写属性，方法 子类可以扩展方法 parent::父级方法名 访问级别： private&gt;protected&gt;public 子类继承父类时，修饰符可以保留等级，可以降级，就是不能升级 继承方式 单继承（一个子级可以继承一个父级） 连续继承（爷-&gt;父-&gt;子-&gt;孙 依次继承） 多继承（无法在PHP中实现） 4.类静态1.关键字： ​ static 2.格式： ​ static 修饰符 $属性名=属性值； ​ static 修饰符 function 方法名（）{}; 3.使用格式： ​ 类名::静态属性名 / 类名::静态方法名() ​ self 代表当前的类名，只能在类内使用 ​ $this 代表当前的对象 123456789101112class Beauty&#123; static public $name = &apos;小张&apos;; #设置静态属性 // public $age = 18; #静态类内不能使用非静态属性 static public function demo() #设置静态方法 &#123; echo &apos;i am static demo &lt;hr&gt;&apos;; echo self::$name; #类内调用静态属性 echo &apos;&lt;hr&gt;&apos;; &#125;&#125;Beauty::demo(); #引用静态方法 4.特性： 静态属性或方法 不需要实例化就可以直接使用 静态方法内部只能使用静态属性或方法 静态属性和方法可以继承 5.魔术方法 ​ __callStatic($x,$y) ​ 在访问不存在的静态方法时，自动触发，返回静态方法名和实参 5.类常量1.格式 ​ const 类常量名=值； 2.使用类常量 ​ 类名::类常量 3.特性 类常量可以继承，且可以重写一次 普通常量可以直接在类内使用（常量没有作用域） 类常量不能直接在类外使用，必须要通过类名来使用 1234567891011const NAME = &apos;黑寡妇&apos;;class Beauty&#123; const SEX = &apos;美女&apos;; #定义类常量 public function demo() &#123; echo self::SEX; echo NAME; # 直接输出类外的 普通常量NAME &#125;&#125;echo Beauty::SEX; #输出类内常量 6.最终 final1.使用：123456789101112final class Beauty #final 修饰类，保护不被继承 &#123; public $name = &apos;陈琳琳&apos;; &#125; ------------------------------------------------------class Father &#123; final public function Order() #final修饰方法 &#123; echo &apos;这是祖辈留下的祖训: 不能吃猪肉 &lt;br&gt;&apos;; &#125; &#125; 2.特性 final 可以修饰类和方法，不能修饰属性 final 修饰类，保护类不被继承 final 修饰方法，保护方法不被继承方法重写 7.克隆对象 clone1.格式​ 副本对象 = clone 样本对象； 2.使用1234567class Beauty &#123; public $name = &apos;米拉乔沃维奇&apos;; &#125; $a = new Beauty; #创建一个对象 $b = clone $a; #克隆对象 3.特性​ 副本与样本对象完全一样，却互不影响，完全独立 克隆（clone）与复制出来的对象不一样，修改克隆副本对原样本没有任何影响，而修改复制对象则会影响原样本，相同点是删除副本对原样本都没有影响，原因如下： ​ 变量与内存是通过标识来引用的； ​ 删除原样本，只是删除元样本和标识之间 的联系，与复制副本无关； ​ 息息相关的只是内存的内容 4.克隆魔术方法1.函数：​ __clone() 2.作用：​ 克隆操作时触发，可以为克隆副本重新初始化属性 3.实例12345678910111213class Demo&#123; public $name=&apos;kamora&apos;; public function __clone() &#123; $this-&gt;name=&apos;kamora2&apos;; #克隆对象重写 &#125; &#125;$a=new Demo;$b=clone $a; #克隆操作var_dump($a,$b); 8.串行化/序列化1.函数​ 串行化： serialize( ) ​ 反串行化： unserialize( ) 2.目的​ 将对象串行化为字符串 3.使用场景​ 传参，存入文本，存数据库 … 4.实例1234567$obj=new Game; #创建一个对象$str= serialize($obj); #串行化对象，存入变量file_put_contents(&apos;./save.txt&apos;,$str); #将变量内容存入文件$newStr=file_get_contents(&apos;./save.txt&apos;); #读取文件内容 $newObj=unserialize($newStr); #对读取内容反串行化$newObj-&gt;skill(); #使用对象属性方法 5.串行化魔术方法1.函数： __sleep( ) ​ serialize串行化时触发,用以返回需要的信息(数组形式) __wakeup( ) unserialize反串行化时触发, 用以重新初始化属性 2.应用:1234567891011121314151617181920class Game&#123; public $name = &apos;DNF&apos;; public $money = 200000; public function skill() &#123; echo &apos;崩山斩&apos;; &#125; public function __sleep() &#123; // 返回需要显示的信息(以数组形式返回) return [&apos;name&apos;,&apos;nickname&apos;]; &#125; //其余信息隐藏,实际上还是存在 public function __wakeup() &#123; // 在唤醒时, 重新初始化属性 $this-&gt;money = 2; &#125;&#125; 9.魔术方法—自动加载 在真实项目中 , 一个PHP文件内 , 只有一个类 , 没有多余的代码，可以在多PHP相互加载的状态下的纯PHP界面省略定界符&lt;?= ?&gt; 中的后面部分，需要引入的HTML文件使用 include / include 加载 1.格式1234function __autoload($x)&#123; &#125; 2.作用 :​ 在实例化一个不存在的类时 , 自动触发 , 返回要求实例化的类名 3.使用场景 :​ 使用数据库功能 , 上传文件功能 , 图形验证码功能等…. 4.实例:123456789101112一次性加载所有的类文件:function __autoload()&#123; #如果相关类文件存在 if( file_exists(&quot;./Model/&#123;$x&#125;.php&quot;) )&#123; include &quot;./Model/&#123;$x&#125;.php&quot;; &#125;else&#123; header(&apos;location:404.php&apos;); #跳转到404页面 die; &#125;&#125;$a=new DB; #实例化数据库类$b=new Upload; #实例化上传类 10.抽象1.抽象 抽象方法 : 没有方法体( 代码块 ) 的方法 抽象类 : 包含抽象方法的类 1.关键字 ​ abstract 2.特性 包含抽象方法的类必须为抽象类 抽象类不一定需要包含抽象方法 抽象类不能被实例化 抽象类必须被子类继承 , 并实现抽象方法 3.目的 ​ 强制约束子类继承并实现抽象方法 12345678910111213141516 abstract class Demo #定义抽象类&#123; public function func1() &#123; echo &apos;该项目已经完成了 20% &lt;br&gt;&apos;; &#125; abstract public function func2(); #定义抽象方法 &#125; class Friend extends Demo #子类继承抽象类 &#123; public function func2() #子类事项抽象方法 &#123; echo &apos;该项目已经完成了 30% &lt;br&gt;&apos;; &#125; &#125;$obj = new Friend; #实例化子类,调用方法 2.接口1.定义 ​ 当类中全部都是抽象方法时,可定义为接口 ​ 即接口就是抽象类( 条件 : 内部方法全部为抽象方法 ) 2.特性 ​ 接口继承是通过 implements 关键字继承的 (不是extends) ​ 接口可以实现多继承( 可以有多个父类,分别实现各个父类继承的抽象方法 ) 12345678910111213141516171819202122232425 interface Demo #定义接口Demo &#123; public function func1(); #内部方法全部为抽象方法 public function func2(); public function func3(); &#125; class Friend implements Demo #子类继承Demo&#123; public function func1() #子类实现继承的抽象方法 &#123; echo &apos;该项目已经完成了 20% &lt;br&gt;&apos;; &#125; public function func2() &#123; echo &apos;该项目已经完成了 50% &lt;br&gt;&apos;; &#125; public function func3() &#123; echo &apos;该项目已经完成了 30% &lt;br&gt;&apos;; &#125;&#125;$obj = new Friend; #实例化子类$obj-&gt;func1(); #调用Demo方法 3.类型约束 PHP支持的函数实参类型约束有数组和对象 格式 : 方法名( 类名 变量 )|方法名( array 变量 ) 12345678function demo(array $x) #约束送入的实参只能是数组类型 &#123; var_dump($x); &#125; // demo($a=100); #送入整型数据程序报错 $b = [10,20,30]; demo($b); #送入数组,正常输出 123456789101112131415161718class Demo1 &#123;&#125;class Demo2&#123; public function Test(Demo1 $x) #要求送入Demo1对象 &#123; var_dump($x); &#125;&#125;class Demo3 &#123;&#125;$demo1 = new Demo1; #实例化类,得到对象$demo2 = new Demo2;$demo3 = new Demo3;$demo2-&gt;Test($var=100); #送入整型数据,程序报错$demo1-&gt;Test($demo1); #送入demo1,正常输出 4.接口多态性 多态性 : 通过同一个接口 [ 抽象类|普通类 ] ,传入不同的设备,从而实现不同的效果 ( 普通类没有强制约束子类执行指定方法的特征 , 不推荐使用 ) 12345678910111213141516171819202122232425262728293031323334353637383940interface USB #定义接口&#123; public function run();&#125; #指定抽象方法,一旦实现USB必须执行run方法class Mouse implements USB #继承抽象类&#123; public function run() #实现抽象方法 &#123; echo &apos;安装鼠标驱动&apos;; &#125; public function double() #扩展接入接口的子类方法 &#123; echo &apos;双击功能实现&apos;; &#125;&#125;class Keyboard implements USB&#123; public function run() &#123; echo &apos;安装键盘驱动&apos;; &#125; public function click() &#123; echo &apos;击键功能实现&apos;; &#125;&#125;class Computer #设置接口使用环境&#123; public function Start(USB $x) #接入接口 &#123; $x-&gt;run(); &#125;&#125;$c=new Computer; #实例化$m=new Mouse;$k=new Keyboard;$c-&gt;start($m); #依接入类型运行接口方法$c-&gt;start($k); #?如何使用double() 5.foreach遍历对象 foreach不但能够遍历数组,也可以遍历对象 1234567891011121314151617181920class Book&#123; public $name; #成员属性只能定义,不赋初值 public $price; private $author; public function __construct($a,$b,$c) #初始化属性 &#123; $this-&gt;name = $a; $this-&gt;price= $b; $this-&gt;author=$c; &#125; $zhang=new Book(&apos;《新三国》&apos;,&apos;30元&apos;,&apos;小飞&apos;); $cheng=new Book(&apos;《旧三国》&apos;,&apos;50元&apos;,&apos;阿亮&apos;);&#125; #类外依旧受修饰符影响foreach($zhang as $key =&gt; $value)&#123; echo $key.&apos;------&apos;.$value.&apos;&lt;br&gt;&apos;;&#125;foreach($cheng as $key =&gt; $value)&#123; echo $key.&apos;------&apos;.$value.&apos;&lt;br&gt;&apos;;&#125; 注意: 遍历对象是将对象中的 ( 属性名=&gt;属性值 ) 遍历显示 6.对象相关函数 判断类是否存在 class_exists( &#39;类名&#39; ) 返回bool值 判断某个类下的属性是否存在 property_exists( &#39;类名&#39;,&#39;属性名&#39; ) 返回bool值 可以检测私有属性,但不显示具体值 获取类中的所有公有属性 get_class_vars( &#39;类名&#39; ) 返回数组, 包含属性名和属性值 获取对象中的所有公有属性 get_object_vars( &#39;对象&#39; ) 返回数组, 包含属性名和属性值 获取类中的所有公有方法 get_class_method( &#39;类名&#39; ) 返回索引数组, 包含所有方法名 获取某个对象的类名 get_class( &#39;对象&#39; ) 返回字符串, 类名]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 基础01-基本语法]]></title>
    <url>%2F2018%2F05%2F13%2FJavaScript%20%E5%9F%BA%E7%A1%8001-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[web 开发 前端 HTML 数据展示,负责内容 CSS 页面美化, 负责样式 JS 页面特效,与用户的交互.负责行为 后端 PHP JAVA python asp.net node.js Ruby Go javascript 简介什么是 javascript 概念： javascript是 基于对象 和 事件驱动 并具有相对安全性的 客户端 脚本语言 发展简史 Nombas 公司 1992 年开发 嵌入式脚本语言 C– 后改名 ScriptEase Netscape公司 1995 年发布 LiveScript 后改名 javascript1.0 三足鼎立 NetScape 推出 javascript 1.1后, Microsoft 推出 Jscript , 加上 ScriptEase 标准化 1997 javascript 1.1 作为草案 提交给 ECMA（欧洲计算机制造商协会） .由来自 Netscape、Sun、微软、Borland 和其他一些对脚本编程感兴趣的公司的程序员组成的 TC39 锤炼出了 ECMA-262,该标准定义了名为 ECMAScript 的全新脚本语言. 组成 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM） 客户端浏览器上执行的脚本 JavaScript VBScript… ECMAScript核心: JavaScript ActionScript ScriptEase 扩展衍生：node.js / phonegap框架 / vue.js / angular.js / React … 浏览器 IE IE6 7 8 / IE9+ 非IE Chrome firefox opera Safari … 浏览器占比统计: http://tongji.baidu.com/data/browser javascript 的特点 javascript 是一种脚本编程语言,也是一种解释性语言 javascript 的语法结构与C++、java 十分类似 javascript 是一种基于对象的语言 javascript 具有跨平台性. 安全性与简单性 基于对象（真正的对象 封装 继承 多态） java 与 javascript 的关系: 雷锋 和 雷峰塔 javascript 优点与局限 优点 javascript 在客户端运行,节省服务器资源 方便的操控页面中的各个对象,使网页更加友好可控 使多种任务仅在客户端就可以完成而不需要网络和服务器的参与,从而支持分布式的运算和处理 局限 兼容性问题,所有浏览器没有统一的标准 javascript 不能打开/读写/保存计算机上的文件. javascript 以下简称 JS JS 基本语法在 HTML 中使用 JS 写在 header 中的&lt;script&gt;&lt;/script&gt;标签内 外部文件导入&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;标签内不能写代码 通过 JS 事件写在标签内&lt;tag onclick=&quot;JS code....&quot;&gt;&lt;/tag&gt; 基本语法 区分大小写 : JS 所有的一切全都区分大小写 标示符 : 不能以数字开头，可以由：数字/字母/下划线/$组成 注释 单行注释： // 注释 多行注释： /* 注释 */ 语句（指令结束符）: ; 或 换行 关键字和保留字 1234567ECMAScript 关键字的完整列表:break case catch continue defaultdelete do else finally forfunction if in instanceof newreturn switch this throw trytypeof var void while with(关键字是保留的,不能用作变量名或函数名) 变量123var 变量名 = 值;var 变量名 = 值,变量名 = 值,变量名 = 值;var 变量名 = 变量名 = 变量名 = 值; 数据类型以下，是以我们熟悉的角度去分类： 基本类型 String （字串） Number （数值） Boolean （布尔） 复合类型 Ojbect （对象） array （数组） 特殊类型 Null （空） undefined （未定义） function （函数） typeof(aa) typeof aaa 返回一个值或变量的数据类型 字符串类型 定义字符串： &quot;&quot; 或 &#39;&#39; 不论是单引号还是双引号，都可以解析转义字符，都不能解析变量 字符串连接符 + 数值类型 数值的声明方式： 10 进制/ 8 进制/ 16 进制/ 科学计数法 数值范围 5e324 ~ 1.7976931348623157e+308 超过范围会自动转换成 infinity(正无穷) -infinity(负无穷) 可以使用 isFinity() 验证是不是无穷，超出范围不能参与运算 NaN 类型： 数值的特殊类型，表示 Not a Number NaN 与任何数字操作，结果都是 NaN NaN 与任何数都不相等，包括 NaN 自己 函数 isNaN() 判断是否是 NaN Number() 类型转换 true -&gt; 1 / false -&gt; 0 null -&gt; 0 undefined -&gt; NaN 字符串 空字串 -&gt; 0 ‘11’ -&gt; 11 / ‘011’ -&gt; 11 (非进制转换) ‘0b10’ -&gt; 2 (2进制转换) / ‘0xff’ -&gt; 255 (16进制转换) ‘1.1’ -&gt; 1.1 ‘12e3’ -&gt; 12000 (科学计数法解析) 如果包含除上述格式之外的字符，则将其转换成NaN parseInt() 类型转换 数字开头的字符串，只转换数字整数部分，忽略字母部分 0x开头的字串会转换成十六进制，0不可以 空字串 -&gt; NaN true / false / null / undefined 都会被转为 NaN 科学计数法(字串)不解析 parseFloat() 类型转换 基本同上 第一个小数点有效，第二个无效 数字开头的字符串，忽略后面的字母 科学计数法(字串)会解析其值 16 进制转换为 0 自动数据类型转换 数字类型: 在字符串环境下 隐身转换为字符串 字符串类型 在数字环境下，可以隐式转换为字符串中的数字或 NaN 在布尔环境下，可以隐式转换为 true 空字符串: 在数字环境下可以隐式转换为 0 在布尔环境下可以隐式转换为 false 字符串’true’: 在数字环境下可以隐式转换位1 布尔为 true 字符串’false’: 数字环境为 0 布尔位 false null: 在字符串环境下，转换为’null’ 数字环境下，转换为 0 布尔环境下，转为 false NaN: 在字符串环境下可以隐式转换为’NaN’ 布尔环境下，转换为 false undefined: 字符串环境下，转换为“undefined” 数字环境下，转为 NaN 布尔下，转为 false true: 字符串转为’true’ 数字环境下转为 1 false: 字符串转为’false’ 数字环境下转为 0 JavaScript数据类型转换–数字 数据 number( ) parseInt( ) parseFloat( ) 123 123 123 123 12.7 12.7 12 12.7 0b011 3 3 3 “0b011” 3 0 0 “123” 123 123 123 “12.1we” NaN 12 12.1 “12.1e1w” NaN 12 121 “ “ 0 NaN NaN true 1 NaN NaN null 0 NaN NaN undefined NaN NaN NaN 运算符 算术运算符 加法运算符 + 减法运算符 - 乘法运算符 * 除法运算符 / 模运算符 % 负号运算符 - 正号运算符 + 递增运算符 ++ 递减运算符 – 关系运算符 赋值运算符 = 相等运算符 == 等同运算符 === 不等运算符 != 不等同运算符 !== 小于运算符 &lt; 大于运算符 &gt; 小于或等于运算符 &lt;= 大于或等于运算符 &gt;= in 运算符 判断一个值是否属于某个数组或者一个属性是否属于一个对象 instanceof 判断一个对象的实例是否属于某个对象 字符串运算符 + 连字符 逻辑运算符 逻辑与 &amp;&amp; 逻辑或 || 逻辑非 ! 其他运算符 条件运算符 ?: new 运算符 new 对象类型 void 运算符 void 运算符可以让操作数进行运算，但是却舍弃运算之后的结果 typeof 运算符 返回类型 对象属性存取运算符 使用.来调用和设置对象的属性或者方法 : obj.attr| obj.func() delete 运算符 delete 运算符可以用来删除变量/对象的属性/数组中的元素 delete 运算符返回的是布尔值类型 delete 对象名 / delete 变量名 delete 对象名.属性 delete 数组[索引] 逗号运算符 var a = 1, b = 2; c = a + b, d = a - b; this 运算符 this 代表的是当前对象. 其他语句 判断语句 if()...else if()...else... 判断语句 switch()...case...break 迭代语句 while 迭代语句 do-while 迭代语句 for 迭代语句 for-in 立即退出循环 break 退出当前循环 continue 获取页面之中的元素对象 获取页面中的一个元素 document.getElementById()一定要写写在元素生成之后或者 写在函数中 获取或设置元素的 css 属性 element.style.color;element.style.color = ‘#f00’; 获取或设置元素标签的属性 styleinnerHTMLHTML元素标签 具有什么属性,当它变为 JS的element对象之后,该属性就会自动变为 该对象的属性了.(img: src alt title width height id class)(div: alt title id class) 定时函数 4.1 单次定时 setTimeout(‘JS 代码’, time) clearTimeout()4.2 多次定时 setInterval(‘JS 代码’, time) clearInterval() 特效-全选/反选1234567891011121314151617181920212223242526272829303132&lt;ul id=&quot;list&quot;&gt; &lt;li&gt;&lt;input type=&quot;checkbox&quot; value=&quot;0&quot;&gt;小翠翠&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;checkbox&quot; value=&quot;1&quot;&gt;小艳艳&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;checkbox&quot; value=&quot;2&quot;&gt;小莉莉&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;checkbox&quot; value=&quot;3&quot;&gt;小静静&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;checkbox&quot; value=&quot;4&quot;&gt;小萍萍&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;checkbox&quot; value=&quot;5&quot;&gt;小红红&lt;/li&gt;&lt;/ul&gt;&lt;button onclick=&quot;selectAll(1)&quot;&gt;全选&lt;/button&gt;&lt;button onclick=&quot;selectAll(2)&quot;&gt;全不选&lt;/button&gt;&lt;button onclick=&quot;selectAll(3)&quot;&gt;反选&lt;/button&gt;&lt;hr&gt;&lt;script&gt; //声明函数 function selectAll(m)&#123; //获取所有的li //var ul = document.getElementById(&apos;list&apos;); var lis =document.getElementById(&apos;list&apos;).getElementsByTagName(&apos;input&apos;); //遍历 li for (var i = 0; i &lt; lis.length; i ++) &#123; switch (m) &#123; case 1: lis[i].checked = true; break; case 2: lis[i].checked = false; break; case 3: lis[i].checked = !lis[i].checked; break; &#125; &#125; &#125; &lt;/script&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 基础操作-增删改查]]></title>
    <url>%2F2018%2F04%2F05%2FMySQL%20%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[1.数据库1.数据库基本操作常见数据库包括：MySQL，Oracle，SQL server，Redis … 1.定义 ​ 存储数据的仓库，即按照数据结构来组织，存储和管理数据的仓库 选择 MySQL 的原因有：免费，开源，跨平台，支持事务… 2.链接数据库的步骤 ​ 开启服务器——&gt;设置主机IP——&gt;用户名（默认root）——&gt;密码（默认为空） 3.组成 ​ 一个完整的数据库由库（database），表（table）和数据（data）组成，先有库，再有表，最后才有数据的增删改查，也就是说先使用库，才能使用表 4.基本语法 ​ MySQL 的每一条数据都是以分号( ; ) 作为结束符 5.常用SQL命令 ​ 打开命令窗口： F6 ​ 使用数据库： use 库名; ​ 创建数据库： create database [if not exists] 库名 default charset 编码方式; ​ 删除数据库： drop database 库名; ​ 查询数据库结构： show databases; 注意：database需要加s，作为复数格式 ​ 查询数据表： show tables; 注意：在使用库之前，无法使用表 ​ 创建数据表： 12345678910create table if not exists 库名(字段名 字段类型 字段属性,字段名 字段类型 字段属性,字段名 字段类型 字段属性, ...字段名 字段类型 字段属性,字段名 字段类型 字段属性 )engine=myisam|innodb default charset=utf8; ​ 注意：每一组之间用逗号( , ) 隔开，最后一组字段不用加 ​ 删除数据表： drop table 表名； ​ 查看表结构： desc 表名； ​ 查看建表语句： show create table 表名 ​ 注意：所有的库名，表名，字段名都需要加上反引号( ` )，所有的字符串需要加上单双引号 ​ 反引号可以将库名，表名，字段名实体化，取消特殊意义 2.数据库数据操作1.插入数据（增） 插入单条数据：格式： insert into 表名 values(值1，值2，值3，...); 注意点： ​ 主键由于配合自增属性，所以不用主动设置，默认用null代替，值会自动根据最大记录+1； ​ 如果有默认值，可以用default代替 插入单条数据部分字段：格式： insert into 表名（字段1，字段2，字段3，....） vaules(值1，值2，值3，...); 注意： ​ 表名后面填了多少个字段，values就对应填多少个值； ​ 如果字段具有not null属性，那么必须填写‘’ 使用场合：用户注册，不需要填写所有数据表单 插入多条数据：格式： insert into 表名 values(...),(...),(...), ... (...); 插入多条数据部分字段格式： insert into 表名（字段1，字段2，...）values(...),(...),(...), ... (...); 2.更新数据（改） 更新所有数据格式： update 表名 set 字段1=值1，字段2=值2，...; 条件更新格式： update 表名 set 字段1=值1，字段2=值2，... where 条件表达式 3.删除数据（删） 全部删除格式： ​ delete from 表名； 注意：该删除方式只会删除数据，不会删除曾经的数据记录 全部删除（不留记录）格式： ​ truncate table 表名； 注意：该删除方式会连着数据和记录一起删除，如果想清空表，推荐使用truncate 部分删除格式： ​ delete from 表名 where 条件表达式； 排序删除格式： ​ delete from 表名 [where 条件表达式] order by 字段 asc|desc limit 行数 注意： asc为升序排序，desc为降序排序 3.函数1.聚合函数 统计总个数：count( ) select count(id) from user; 统计user表中一共有几个id 求和：sum( ) select sum(age) from user; 统计user表中age的综合 求平均值：avg( ) select avg(age) from user; 统计user表中的平均年龄 求最大值：max( ) select max(age) from user; 获取user表中的最大年龄 求最小值：min( ) select min(age) from user; 获取user表中的最小年龄 2.字符串拼接函数​ 格式：concat(s1,s2,s3,...) ​ 注意：s1,s2,s3可以代表字段名，也可以代表字符串值 ​ select concat(id,&#39;......&#39;,nickname,&#39;......&#39;,address) from user; 3.数据库版本​ select version(); 4.当前时间​ select now(); 5.md5加密​ md5(&#39;1234234&#39;); 6.当前时间戳​ select unix_timestamp(); 4.查询数据1.整体结构1234567select * | distinct | 字段名 | 字段名 as 别名 | 表名.字段名from 表名 | 表名1，表名2，...where 条件表达式group by 字段having 条件order by 条件limit 下标，行数 注意：以上为查询数据的基本结构，先后书序无法颠倒，但可以省略其中一部分 2.具体查询 查询1：查询该表中的所有数据 格式： select * from 表名； 实例： select * from user; 注意： * 通配符代表所有的字段，查询所有的字段，推荐少用或不用 查询2：查询该表中的指定字段 格式： select 字段1，字段2，字段3，... from 表名； 实例：select tel pwd from user; 查询3：带条件查询 格式：select *|字段名 from 表名 where 条件； &lt; 查询所有未成年的名字 select name from user where age&lt;18; &gt;= 查询所有成年的名字 select name from user where age&gt;=18; = 精确查询刚好18岁的名单 select name from user where age=18; != 查询所有不是18岁的名单 select name from user where age!=18; between A and B 查询年龄在15到30之间的名单 select name from user where age between 15 and 30; not between A and B 查询年龄不在20~30岁之间的名单 select name from user where age not between 20 and 30; like 模糊查询 名字带有’小‘的名单 select name like &quot;小&quot;； select name like &quot;%小%&quot;; 注意：% 通配符可匹配0个，1个或多个字符； ​ _ 通配符可以匹配一个字符 in 查询来自于召唤师峡谷的名单 select name,address from user where address in (&#39;召唤师峡谷&#39;); not in 查询地址信息不为空的名单 select name,address from user where address not in (&#39;null&#39;); 逻辑：与 and | 或 or 查询 来自于召唤师峡谷的女孩子 select name,address,sex from user where address=&#39;召唤师峡谷&#39; and sex=2; 查询女孩子或者来自于xxx楼的名单 select name,address,sex from user where address like &quot;%楼&quot; or sex=2; 空与非空： is null 和 is not null 查询有住址的名单 select name from user where address is not null; 查询住址信息为空的名单 select name from user where address id null; group by 分组 : 查询user中名单分别来自哪些地方 select address from user group by address; 注意：一旦分组，就不能查询单一数据，必须按照“组”为单位来查询 having 筛选： 筛选人数多于一个的地址 select address,count(id) from user group by address having count(id)&gt;1; 注意：having一般都是配合group by来使用，先分组再筛选 order by 排序 按照生日从大到小查看名单 select nickname,birthday from user order by birthday desc; 注意：desc为降序排序，asc为升序排序 limit 前几个 查询user表单中的前3个人信息 select * from user limit 3; 注意：标准格式为：limit 下标，行数,代表从下标开始的几行数据 5.多表查询 多张表同时查询 1.条件限制：​ 多张表之间必须要求有联系 ​ 多表有相同字段时，必须声明是哪张表中的字段（表名.字段名） ​ n张表之间的联系至少有 n-1 条 2.格式：1234select 字段from 表名1，表名2，表名3，...where 表名1.字段1 = 表名2.字段1 ...... 3.实例：​ 查询每个人的昵称，住址，部门，薪资 123select uid,nickname,address,dep,moneyfrom user,salarywhere user.id=salary.uid 6.嵌套查询 将一条sql语句的结果作为另一条sql的条件来使用 实例 ​ 查询每个部门最高工资的uid 123select uid,money,depfrom salarywhere money in ( select max(money) from salary group by dep ) 7.多表+嵌套​ 查询每个部门最高工资的uid 123456select uid,s.money,s.depfrom salary as s,( select dep,max(money) as money from salary group by dep ) as twhere s.dep=t.dep and s.money=t.money 8.别名​ 给字段，表名取个别名 as ​ select dep,max(monry) as money from salary as s group bu dep; 9.取消重复​ select distinct address from user;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 简介07-文件操作]]></title>
    <url>%2F2018%2F03%2F15%2FPHP%20%E5%9F%BA%E7%A1%8007-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1.文件操作函数1.回顾：文件常见分类：file（文件） 和 dir（文件夹） 路径： 相对路径 . 当前目录 .. 上级目录 ​ 绝对路径 （盘符型，网址型，根www) 2.文件属性：1.文件类型：​ filetype（&#39; 文件路径 &#39;） 输入一个文件路径，返回文件类型（file 文件|dir 文件夹） 2.文件大小：​ filesize（&#39; 文件路径 &#39;） 输入一个文件路径，检测文件大小，单位是字节（不支持文件夹，结果不准确，以最小文件单元(4096字节)作为单元计算） 3.文件是否存在：​ file_exists（&#39; 文件路径 &#39;） 输入一个路径，返回判断结果bool值 4.文件是否可读可写​ is_readable（&#39; 文件路径 &#39;） 输入一个路径，判断是否可读，返回bool值 ​ is_writeable（&#39; 文件路径 &#39;） 输入一个路径，判断是否可写，返回bool值 5.返回文件的创建/修改/访问时间​ filectime（&#39; 文件路径 &#39;） 输入路径，返回文件的创建（creative）时间 ​ filemtime（&#39; 文件路径 &#39;） 输入路径，返回文件的修改（modification）时间 ​ fileatime（&#39; 文件路径 &#39;） 输入路径，返回文件的访问（access）时间 6.获取目录/文件名​ dirname（&#39; __FILE__ &#39;） 输入当前文件路径，获取路径名（dir） ​ basename（&#39; __FILE__ &#39;） 输入当前文件路径，获取文件名（file） 12345需求：面试题 获取该地址的文件扩展名$url = &apos;http://www.baidu.com/av/gt18/ka.n.g.mp4?age=18&amp;type=人兽#xxoo&apos;;$a=basename($url);$a=strtok($a,&apos;?&apos;);$a=strrchr($a,&apos;.&apos;); 7.网址解析​ parse_url(&#39; url &#39;) 123456789$url=&apos;http://www.baidu.com:80/av/gt18/ka.n.g.mp4?age=18&amp;type=人兽#xxoo&apos;var_dump(parse_url($ur;));/*array (size=6) &apos;scheme&apos; =&gt; string &apos;http&apos; (length=4) #协议 &apos;host&apos; =&gt; string &apos;www.baidu.com&apos; (length=13) #域名 &apos;port&apos; =&gt; int 80 #端口 &apos;path&apos; =&gt; string &apos;/av/gt18/ka.n.g.mp4&apos; (length=19) #路径 &apos;query&apos; =&gt; string &apos;age=18&amp;type=人兽&apos; (length=18) #参数 &apos;fragment&apos; =&gt; string &apos;xxoo&apos; (length=4)*/ #锚点 8.盘符解析​ pathinfo(&#39; $path &#39;) 1234567$path=&apos;D:\wamp\www\s86\0422\01-file.php&apos;;var_dump($path);/*array (size=4) &apos;dirname&apos; =&gt; string &apos;D:\wamp\www\s86\0422&apos; (length=20) #路径名 &apos;basename&apos; =&gt; string &apos;01-file.php&apos; (length=11) #文件名 &apos;extension&apos; =&gt; string &apos;php&apos; (length=3) #扩展名 &apos;filename&apos; =&gt; string &apos;01-file&apos; (length=7)*/ #文件名（无后缀） 3.递归函数（三元归一遍历）1.函数​ opendir(&#39; path &#39;) 打开一个目录，返回资源 ​ readdir(&#39; resource name &#39;) 读取一个资源，返回当前资源名（实际上利用指针） ​ close(&#39; resource name &#39;) 关闭一个资源，释放内存 2.应用​ 需求：将./demo1 目录中的所有文件名，输出到屏幕上 ​ 1.原始访问方式： 123456789$handle=opendir(&apos;./demo1&apos;); #windows中，每个文件夹中都有 . 和 .. 文件夹var_dump(readdir($handle)); #当前目录 . var_dump(readdir($handle)); #上级目录 ..var_dump(readdir($handle));...var_dump(readdir($handle));var_dump(readdir($handle)); #超出范围之外，返回falseclosedir($handle); ​ 2.循环访问方式： 123456789$handle=opendir(&apos;./demo1&apos;);while( ($file=readdir($handle))!=false )&#123; #循环访问方式 if($file==&apos;.&apos;||$file==&apos;..&apos;)&#123; #排除显示 . 和 .. continue; &#125; echo $file; echo &apos;&lt;br&gt;&apos;;&#125;closedir($handle); #关闭资源 3.递归函数1.函数：​ is_file( &#39;path name&#39; ) 判断当前路径是否为文件 ​ is_dir( &#39;path name&#39; ) 判断当前路径是否为目录 ​ 注：参数必须为完整的地址，否则输出false。相对，绝对都可以 2.递归函数：​ 1）函数自己调用自己 ​ 2）必须要有终止条件 3.应用123456789101112131415161718191.需求：函数功能-输出所有子目录下的所有文件和子目录function getFile( $dir )&#123; $handle=opendir($dir); #打开目录，获取资源 while(($file=readdir($handle))!=false)&#123; #读取资源 if($file==&apos;.&apos;|$file==&apos;..&apos;)&#123; #排除 . 和 .. 文件夹 continue; &#125; $path=$dir.&apos;/&apos;.$file; #拼凑完整路径 if(is_file($path))&#123; #判断是否为文件，是则输出文件名 echo $file.&apos;&lt;br&gt;&apos;; &#125; if(is_dir($path))&#123; #判断是否为目录，是则输出目录名， echo $file.&apos;&lt;br&gt;&apos;; getFile($path); #调用函数打开子目录 &#125; &#125; closedir($handle); #关闭资源&#125; 12345678910111213141516171819202.需求：函数功能-获取某个目录的大小function getDirSize( $dir )&#123; $handle=opendir($dir)； $sum=0; while(($file=readdir($handle))!=false)&#123; if($file=&apos;.&apos;|&apos;..&apos;)&#123; continue; &#125; $path=$dir.&apos;/&apos;.$file; if(is_file($path))&#123; $sum=$sum+fileseze($path); &#125; if(is_dir($path))&#123; $sum+=getDieSize($path); &#125; &#125; closedir($handle); renturn $sum;&#125; 1234567891011121314151617181920213.需求：函数功能-统计某个目录下有多少个文件和文件夹function getFileNumber( $dir )&#123; $handle=opendir($dir); $dirSum=0; $fileSum=0; while(($file=readdir($handle))!=false)&#123; if($file=&apos;.&apos;||$file=&apos;..&apos;)&#123; continue; &#125; $path=$dir.&apos;/&apos;.$file; if(is_file($path))&#123; $fileSum+=1; &#125; if(is_dir($path))&#123; $dirSum+=getFileNumber($path); $fileSum+=getFileNumber($path); &#125; &#125; closedir($handle);&#125; 4.文件操作1.拷贝文件​ copy( 来源地址，目标地址 ) 将目标文件拷贝到目标文件中（不支持目录拷贝） ​ copy(&#39;./01-file.php&#39;,&#39;./demo1/01-file.php&#39;); 2.创建目录​ mkdir( 目录路径 ) 在目标路径创建一个文件夹 ​ mkdir( 目录路径，0777，true ) 在目标路径创建多级目录文件夹 ​ mkdir(&#39;./x/y/z&#39;, 0777, true); 3.删除目录​ rmdir( 目录路径 ) 只能删除空文件夹 ​ rmdir(&#39;./x&#39;); 4.创建/删除文件​ touch( 文件名 ) 创建文件 ​ unlink( 文件名 ) 删除文件 ​ touch(&#39;./demo1/test.php&#39;); unlink(&#39;./demo1/test.php&#39;); 5.重命名/剪切文件​ rename( 旧文件名，新文件名 ) 修改目录，剪切 ​ rename(&#39;./test&#39;, &#39;./demo1/test.txt&#39;); #修改目录，剪切 ​ rename(&#39;./test.txt&#39;, &#39;./testxxx.txt&#39;); # 目录不变,重命名 5.文件编码问题Windows默认gbk编码，PHP默认utf-8编码，编码不一致时，会发生编码解析问题 ​ iconv( 源编码，目标编码，内容 ) ​ copy(iconv(&#39;utf-8&#39;,&#39;gbk&#39;,&#39;./递归.png&#39;),&#39;./xx.png&#39;) 6.baidu云盘递归遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;百度云盘&lt;/title&gt; &lt;style&gt; table&#123;width: 500px;/*height: 60px;*/margin:20px auto;border-collapse:collapse;font-size: 14px;&#125; table tr:hover&#123;background: #f4fbff;&#125; table tr:hover th&#123;border-color: #cbedff;&#125; table tr:hover td&#123;border-color: #cbedff;&#125; table th&#123;text-align: left;border-bottom:1px solid #ccc;/*line-height: 30px;*/border-color: #999;&#125; table td&#123;border-bottom:1px solid #ccc;border-color: #999;&#125; .dir&#123;background:url(&apos;./Baidu/icon.png&apos;) -380px -627px;width: 26px;height: 26px;display:inline-block;vertical-align: middle;&#125; .file&#123;background:url(&apos;./Baidu/icon.png&apos;) -380px -627px;width: 26px;height: 26px;display:inline-block;vertical-align: middle;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;文件名&lt;/th&gt; &lt;th&gt;大小&lt;/th&gt; &lt;th&gt;修改日期&lt;/th&gt; &lt;/tr&gt;&lt;!-- &lt;tr&gt; &lt;td&gt;&lt;div class=&quot;dir&quot;&gt;&lt;/div&gt;我的卡包&lt;/td&gt; &lt;td&gt;xxx&lt;/td&gt; &lt;td&gt;xxxxxx&lt;/td&gt; &lt;/tr&gt; --&gt;&lt;?php $x=empty($_GET[&apos;path&apos;])?&apos;./demo1&apos;:$_GET[&apos;path&apos;]; getFileName($x);?&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php function getFileName($dir)&#123; $handle=opendir($dir); // $file=readdir($handle); while(($file=readdir($handle))!=false)&#123; echo &apos;&lt;tr&gt;&apos;; if ($file==&apos;.&apos;||$file==&apos;..&apos;) &#123; continue; &#125; $path=$dir.&apos;/&apos;.$file; if (is_file($path)) &#123; echo &apos;&lt;td&gt;&lt;div class=&quot;file&quot;&gt;&lt;/div&gt;&apos;.$file.&apos;&lt;/td&gt;&apos;; echo &apos;&lt;td&gt;&apos;.filesize($path).&apos;&lt;/td&gt;&apos;; &#125; if (is_dir($path)) &#123; echo &quot;&lt;td&gt;&lt;div class=&apos;dir&apos;&gt;&lt;/div&gt;&lt;a href=&apos;?path=&#123;$path&#125;&apos;&gt;&#123;$file&#125;&lt;/a&gt;&lt;/td&gt;&quot;; echo &apos;&lt;td&gt; - &lt;/td&gt;&apos;; &#125; echo &apos;&lt;td&gt;&apos;.filemtime($path).&apos;&lt;/td&gt;&apos;; echo &apos;&lt;/tr&gt;&apos;; &#125; closedir($handle);&#125; ?&gt; 7.文件加载1.函数： ​ include &#39; 文件路径 &#39; #加载（当做关键字使用） 依赖 require &#39; 文件路径 &#39; ​ include( 文件路径 ) #加载（当做函数使用） 依赖 require( 文件路径 ) ​ include_once( 文件路径 ) #加载一次 依赖 require_once( 文件路径 ) ​ include_once &#39; 文件路径 &#39; #加载一次 依赖 require_once &#39; 文件路径 &#39; 2.作用： ​ 将文件A加载到文件B中，文件B从而可以使用文件A中的所有数据 ​ 相当于将文件A的所有代码复制到文件B中的 include / require 处 3.使用 ​ include &#39;./demo.php&#39;; require &#39;./demo.php&#39;; ​ include_once &#39;./demo.php&#39;; require_once &#39;./demo.php&#39;; 4.特性 ​ 1.include / require 可以重复加载 ​ 2.但被重复加载的文件内部，函数和常量会被重定义，报错 ​ 3.避免重复加载，可以通过include_once / require_once只加载一次 ​ 4.include 加载出错，不会终止程序，require 加载出错，立马终止程序 ​ 5.支持相对路径，盘符路径，不支持网址路径 8.文件内容操作函数1.向文件赋予内容​ file_put_contents(&#39;文件路径&#39;,&#39;文件内容&#39;)； ​ 若文件路径不存在，则自动创建；若路径存在，则先将文件大小截为0，再写入内容（覆盖） ​ 代码实例：file_put_contents(&#39;./test.txt&#39;,&#39;how are you?&#39;); 2.获取文件的所有内容​ file_get_contents(&#39;文件路径&#39;); ​ 支持全格式地址，若输入网址地址，则爬取跳转当前页面（只有外表，无功能） ​ 代码实例：echo file_get_contents(&#39;./test.txt&#39;); ​ echo file_get_contents(&#39;http://www.baidu.com&#39;); 3.打开一个文件​ fopen(&#39;文件路径&#39;，&#39;打开模式&#39;)； 返回值：资源 ​ #打开模式详解： ​ r 只读，指针指向文件开头，若文件不存在，报错 ​ w 只写，指针指向文件开头，若文件不存在，则自动创建，且大小截为0 ​ a 追加，指针指向文件末尾，若文件不存在，则自动创建 ​ + 增强，既可以读又可以写，但需要以上模式配合 ​ 代码实例： $handle=fopen(&#39;.test.txt&#39;,&#39;r&#39;); 4.读取内容​ fread(&#39;文件资源&#39;，&#39;字节&#39;); 读取资源，返回内容，每次读取指定字节数据 ​ 当函数读取资源超出资源范围时，返回空字符串 1234读取方式1： while( ($x=fread($handle,1)) !== &apos;&apos; )&#123; echo $x; &#125; 123读取方式2：echo fread($handle,11);echo fread($handle,filesize(&apos;./test.txt&apos;)); 5.写入内容​ fwrite(&#39;文件资源&#39;,&#39;内容&#39;) ​ 将内容写入目标文件，写入方式由 fopen() 的打开模式决定 ​ 代码实例： 1231.写入：$handle=fopen(&apos;./text.txt&apos;,&apos;w&apos;);fwrite($handle,&apos;MVP&apos;); #MVP 1232.追加：$handle=fopen(&apos;.text.txt&apos;,&apos;a&apos;);fwrite($handle,&apos;ADD&apos;); #MVPADD 1233.增强：r+$handle=fopen(&apos;./test.txt&apos;,&apos;r+&apos;); fwrite($handle,&apos;abc&apos;); #abcADD(覆盖前面的) 1234.增强：w+$handle=fopen(&apos;./test.txt&apos;,&apos;w+&apos;); fwrite($handle,&apos;def&apos;); #def(覆盖全部的) 1235.增强：a+$handle=fopen(&apos;./test.txt&apos;,&apos;a+&apos;); fwrite($handle,&apos;GG&apos;); #defGG(覆盖全部的) 6.关闭资源​ fclose($handle); 释放内存，节省空间 9.文件上传1.文件上传限制： 表单限制 MAX_FILE_SIZE HTML页面自定义大小，一旦超过，error=2 ​ 可通过F12跳过限制（一般都是通过隐藏域MAX_FILE_SIZE修改赋值） post协议限制 post_max_size 一旦超过8M，$_FILES直接为空 服务器限制 upload_max_filesize 一旦超过2M，error=1 2.文件上传相关函数​ $_FILES 专门用于接收上传文件，返回结果为数组 ​ $is_uploaded_file( 临时文件地址 ) 检测是否通过post发送，返回bool值 ​ uniqid（） 基于一微秒产生的唯一ID，适合低频率 ​ file_exists( ) 文件是否存在，返回bool ​ move_uploaded_file( 临时文件，目标文件 ) 移动临时文件到存储目录 123456789array (size=1) &apos;icon&apos; =&gt; array (size=5) icon =&gt; file表单的name名 name =&gt; 上传的文件名 type =&gt; 上传的文件类型 tmp_name =&gt; 临时文件 error =&gt; 错误号 0:没错 非0:有错 size =&gt; 上传的文件大小 ​ ​ 上传文件初版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function upload()&#123; #1.检测文件是否符合服务器大小限制（$_FILES是否为空） $key=key($_FILES); if(is_null($key))&#123; #若超过8M，错误号2，post协议不通过，FILES数组为空 echo &apos;文件太大，上传失败&apos;; echo &lt;meta http-equiv=&quot;refresh&quot;content=&quot;3;url=&apos;.$_SERVER[&apos;HTTP_REFERER&apos;].&apos;&quot;&gt;; die; #回到上一级 &#125; #2.获取错误号，输出错误信息 $error=$_FILES[$key][&apos;error&apos;]; #获取当前错误号 if($error!=0)&#123; #若错误号不为0，即上传失败，输出原因 switch($error)&#123; case1:echo &apos;文件太大，上传失败&apos;;break; case2:echo &apos;文件太大，上传失败&apos;;break; case3:echo &apos;网络中断&apos;;break; case4:echo &apos;未上传文件&apos;;break; case6:echo &apos;服务器繁忙（服务器存储目录丢失）&apos;;break; case7:echo &apos;服务器繁忙（权限不足）&apos;;break; &#125; echo &lt;meta http-equiv=&quot;refresh&quot;content=&quot;3;url=&apos;.$_SERVER[&apos;HTTP_REFERER&apos;].&apos;&quot;&gt;; die; &#125; #3.检测是否是post上传过来的 $tmp=$_FILES[$key][&apos;tmp_name&apos;]; #获取缓存目录 if(!is_uploaded_file($tmp))&#123; #是否通过post发送 echo &apos;非法上传&apos;; echo &lt;meta http-equiv=&quot;refresh&quot;content=&quot;3;url=&apos;.$_SERVER[&apos;HTTP_REFERER&apos;].&apos;&quot;&gt;; die; &#125; #4.检测文件类型是否符合要求 $type=strtok($_FILES[$key][&apos;type&apos;],&apos;/&apos;); #获取文件类型 $allowType=[&apos;image&apos;]; #准备允许的类型 if(!in_array($type,$allowType))&#123; echo &apos;上传类型不符合要求&apos;； echo &lt;meta http-equiv=&quot;refresh&quot;content=&quot;3;url=&apos;.$_SERVER[&apos;HTTP_REFERER&apos;].&apos;&quot;&gt;; &#125; #5.设计新的文件名（唯一）(格式：20190423xxxx.jpg) $suffix=strrchr($_FILES[$key][&apos;name&apos;],&apos;.&apos;); #4.1获取扩展名 $filename=date(&apos;Ymd&apos;).uniqid().$suffix; #产生唯一ID #6.设置存储目录 upload/年/月/日/ $dir=&apos;upload/&apos;.date(&apos;/Y/m/d/&apos;); if(!file_exists($dir))&#123; mkdir($dir,0777,true); &#125; #7.移动临时文件到存储目录 if(move_upload_file($tmp,$dir.$filename))&#123; echo &apos;上传成功&apos;; &#125;else&#123; echo &apos;上传失败&apos;; &#125;&#125; ​ 上传文件完全版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * upload 单文件上传 * @param string $saveDir 存储目录 * @param array $allowType 允许类型 * @return string 错误信息 * @return array 新的文件名 */function upload($saveDir=&apos;uploads/&apos;,$allowType=[&apos;image&apos;])&#123; #1.检测文件是否符合服务器大小限制（$_FILES是否为空） $key=key($_FILES); if(is_null($key))&#123; #若超过8M，错误号2，post协议不通过，FILES数组为空 return &apos;文件太大，上传失败&apos;; #返回信息 &#125; #2.获取错误号，输出错误信息 $error=$_FILES[$key][&apos;error&apos;]; #获取当前错误号 if($error!=0)&#123; #若错误号不为0，即上传失败，输出原因 switch($error)&#123; case 1:return &apos;文件太大，上传失败&apos;;break; case 2:return &apos;文件太大，上传失败&apos;;break; case 3:return &apos;网络中断&apos;;break; case 4:return &apos;未上传文件&apos;;break; case 6:return &apos;服务器繁忙（服务器存储目录丢失）&apos;;break; case 7:return &apos;服务器繁忙（权限不足）&apos;;break; &#125; &#125; #3.检测是否是post上传过来的 $tmp=$_FILES[$key][&apos;tmp_name&apos;]; #获取缓存目录 if(!is_uploaded_file($tmp))&#123; #是否通过post发送 return &apos;非法上传&apos;; &#125; #4.检测文件类型是否符合要求 $type=strtok($_FILES[$key][&apos;type&apos;],&apos;/&apos;); #获取文件类型 if(!in_array($type,$allowType))&#123; return &apos;上传类型不符合要求&apos;； &#125; #5.设计新的文件名（唯一）(格式：20190423xxxx.jpg) $suffix=strrchr($_FILES[$key][&apos;name&apos;],&apos;.&apos;); #4.1获取扩展名 $filename=date(&apos;Ymd&apos;).uniqid().$suffix; #产生唯一ID #6.设置存储目录 upload/年/月/日/ $dir=$saveDir.date(&apos;/Y/m/d/&apos;); if(!file_exists($dir))&#123; mkdir($dir,0777,true); &#125; #7.移动临时文件到存储目录 if(move_uploaded_file($tmp,$dir.$filename))&#123; return [$filename]; &#125;else&#123; return &apos;上传失败&apos;; &#125;&#125;$result=upload();if(is_array($result))&#123; notice(&apos;上传成功&apos;,&apos;http://www.baidu.con&apos;);&#125;else&#123; notice($result);&#125;/** * notice 提示信息 * @param string $info 提示信息 * @param string $url 提示之后的跳转地址 * @param integer $time 几秒后进行跳转 */function notice($info,$url=null,$time=3)&#123; echo $info; if($is_null($url))&#123; $url=$_SERVER[&apos;HTTP_REFERER&apos;]; &#125; echo &quot;&lt;meta http-equiv=&apos;refresh&apos; content=&apos;&#123;$time&#125;; url=&#123;$url&#125;&apos;&gt;&quot;; die;&#125; 10.文件下载1.步骤​ 1.接收下载的文件名 12$name = $_GET[&apos;name&apos;];$suffix=strchr($name,&apos;&apos;); ​ 2.凑完整的路径 1$path = &apos;./download/&apos;.$name; ​ 3.准备下载之后的名字 12$filename=str_shuffle(md5($name)).$suffix;header(&quot;content-disposition:attachment;filename=&#123;$filename&#125;&quot;); ​ 4.读取文件内容 1readfile($path);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 简介06-错误处理]]></title>
    <url>%2F2018%2F01%2F17%2FPHP%20%E5%9F%BA%E7%A1%8006-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.错误处理1.分类​ PHP的错误编码： ​ 1.error错误 错误号:1 ​ 致命错误，一旦碰到error错误，程序立马终止 ​ 2.warning错误 错误号：2 ​ 警告错误，一旦碰到warning错误，程序会给出错误警告，但不会终止程序的执行 ​ 3.notice错误 错误号：8 ​ 提示错误，可能是错误，也可能不是错误，不会终止程序的执行 2.错误的屏蔽在上线项目中，不允许出现任何错误 1.方法一：通过错误抑制符@来屏蔽当前某一变量的错误 2.方法二：（推荐）通过error_reporting函数来屏蔽函数之后的错误 该函数一般写在程序的最前面 影响范围：该文件 error_reporting(E_ALL) 显示所有的错误 error_reporting(E_WARNING) 只显示warning级错误 error_reporting(E_NOTICE) 只显示notice级错误 error_reporting(E_ERROR) 只显示error级错误，一般屏蔽不掉 error_reporting(E_ALL ^E_NOTICE) 除了notice级错误，其余都报 error_reporting(E_ALL &amp; ~E_NOTICE) error_reporting(E_ALL ^E_EARNING) 除了warning级错误，其余都报 error_reporting(E_ALL &amp; ~E_WARNING) 3.方法三：通过修改配置文件，来屏蔽错误 影响范围：整个服务器 配置文件位置：wamp\bin\apache\apache2.4.18\bin\php.ini 注意：修改任意配置后，都需要重启服务器 123// 修改内容2:// error_reporting = 值 该值与 屏蔽2的函数值一模一样 4.方法四：通过函数临时修改配置文件ini_get() 或 ini_set() 影响范围：当前文件 1234567891011121314151617181920var_dump( ini_get(&apos;display_errors&apos;) );ini_set(&apos;display_errors&apos;, 0);ini_set(&apos;display_errors&apos;, &apos;Off&apos;);ini_set(&apos;display_errors&apos;, &apos;On&apos;);var_dump( ini_get(&apos;display_errors&apos;) );# 32767 E_ALL# 1 E_ERROR# 2 E_WARNING# 8 E_NOTICEvar_dump( ini_get(&apos;error_reporting&apos;) );ini_set(&apos;error_reporting&apos;, 1);ini_set(&apos;error_reporting&apos;, E_ERROR);ini_set(&apos;error_reporting&apos;, E_WARNING);ini_set(&apos;error_reporting&apos;, E_NOTICE);var_dump( ini_get(&apos;error_reporting&apos;) );echo $a;echo strrev(); 3.PHP错误日志日志函数：error_log(日志信息，日志类型，目标文件) 日志类型：如果是写入日志，选择3 目标文件：当日志类型为3，才需要第三个参数 12345678910111213141516171819202122232425262728$a = 10;$b = 0;if ($b == 0) &#123; // 日志信息 $ip = $_SERVER[&apos;REMOTE_ADDR&apos;]; # 客户IP $time = date(&apos;Y/m/d H:i:s&apos;); # 访问时间 $method = $_SERVER[&apos;REQUEST_METHOD&apos;]; # 访问方式 $info = &apos;除数不能为0&apos;; # 错误信息 $address = __FILE__; # 错误文件地址 $line = __LINE__; # 当前行号 # 记事本的换行: \r\n 先回车再换行 $log = &quot;&#123;$ip&#125; - - [&#123;$time&#125;] &#123;$method&#125; &#123;$info&#125; in &#123;$address&#125; on line &#123;$line&#125; \r\n&quot;; error_log($log, 3, &apos;./log.txt&apos;); // 自定义报错 // trigger_error(报错信息, 错误类型) // E_USER_ERROR 用户自定义的致命错误 // E_USER_WARNING 用户自定义的警告错误 // E_USER_NOTICE 用户自定义的提示错误 trigger_error($info, E_USER_NOTICE);&#125;else&#123; echo $a/$b;&#125; 3.逻辑错误的处理 逻辑错误：既不报错，也不终止程序，主要因为设计错误 两种缩小排错范围的方法： 1.断点法：通过die/exit中断程序的执行，在die之前输出相关变量，查看是否与预想数值符合 2.注释法：通过注释局部代码，查看结果是否有变化]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 简介05-数组/正则/时间函数]]></title>
    <url>%2F2018%2F01%2F05%2FPHP%20%E5%9F%BA%E7%A1%8005-%E6%95%B0%E7%BB%84.%E6%AD%A3%E5%88%99.%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.数组1.数组1.分类 ​ 索引数组：键为 int ​ 关联数组：键为 string ​ 混合数组：键为 混合类型（字母，数字，汉字，字符串….） 2.键： ​ 别名：下标，偏移量，索引 3.值： ​ 可以为任意类型 4.格式： ​ $数组名[ 键 ] = 值; ​ $数组名 = [ 键1 =&gt; 值1，键2 =&gt; 值2，键3 =&gt; 值3，... ]; 5.索引数组 ​ 1）数组的键为一系列有一定规律的数字组成，当键不是 int 型时，会强制转化为 int 。 ​ 2）当没有指定键时：默认从0开始；从已有记录过的最大键开始+1； 6.关联数组 ​ 1）数组的键为字符串组成，没有特别的顺序和规律 ​ 2）如下一些键值可能会产生同样的效果： ​ # 1 = 1.xxx =true ​ # 0 = 0.0 = &#39;0&#39; = false ​ # null = 空字符串 = 未定义变量 ​ # 非法键：数组，对象 ​ # 资源虽然可以作为键，但是不推荐 ​ 键既有数字，又有字符串，一般称之为混合数组 7.多维数组 ​ 数组间发生嵌套关系，即可称之为多维数组 ​ 多维数组的操作，需要操作几维数组，就需要几个[ ] 12345$name=[ [&apos;成龙&apos;, &apos;洪金宝&apos;, &apos;李连杰&apos;, &apos;周润发&apos;], [&apos;易筋经&apos;, &apos;洗 髓经&apos;, &apos;金钟罩&apos;, &apos;童子功&apos;], [&apos;象猴得度&apos;, &apos;普度众生&apos;, &apos;割肉喂鹰&apos;, &apos;佛说前生&apos;], ]; 另一个写法： 1$name=[&apos;a&apos;=&gt;[1,2,3,4,5,],&apos;b&apos;=&gt;[2,3,4,5,6,6]]; 8.遍历数组 1.索引遍历 for 对于键为有规则的数字，可以用索引遍历 12345$name = [&apos;貂蝉&apos;, &apos;西施&apos;, &apos;王昭君&apos;, &apos;杨玉环&apos;]; for($i=0; $i&lt;4; $i++)&#123; echo $name[$i].&apos; &apos;; &#125; var_dump($name); 2.指针遍历 point 对于没有规则的数字键，是很难通过for遍历出来 常用函数： ​ key( ) 返回当前指针所指向的键 ​ current( ) 返回当前指针所指向的值 ​ 相对移位： ​ next( ) 下移一位 ​ prev( ) 上移一位 ​ 绝对移位： ​ reset( ) 指针直接指向数组的第一个键值对 ​ end( ) 指针直接指向数组的最后一个键值对 注意点： 当使用 next 和 prev 移出范围之外时，无法通过next和prev再移动回来，返回键为 null ，值为 false。 一般使用键为null来作为遍历终止条件 12345$name = [4=&gt;&apos;貂蝉&apos;, 1=&gt;&apos;西施&apos;, 99=&gt;&apos;王昭君&apos;, 12=&gt;&apos;杨玉环&apos;]; // 利用指针 来遍历数组 for( ; !is_null( key($name) ) ; next($name) )&#123; echo current($name).&apos; &apos;; &#125; 3.指针遍历 each each（）函数自带current+key+next 123456$name = [4=&gt;&apos;貂蝉&apos;, 1=&gt;&apos;西施&apos;, 99=&gt;&apos;王昭君&apos;, 12=&gt;&apos;杨玉环&apos;]; for( ; $x = each($name) ; )&#123; echo $x[0].&apos;=======&gt;&apos;.$x[1].&apos;&lt;br&gt;&apos;; &#125; echo &apos;&lt;hr&gt;&apos;; #输出形式：0=key;1=value。 4.扩展循环结构： foreach 格式： ​ foreach( 数组 as 键 =&gt; 值 ){ 代码块 } 简化版：当不需要使用键时 ​ foreach( 数组 as 值 ）{ 代码块 } 12345$name = [4=&gt;&apos;貂蝉&apos;, 1=&gt;&apos;西施&apos;, 99=&gt;&apos;王昭君&apos;, 12=&gt;&apos;杨玉环&apos;]; foreach($name as $k =&gt; $v)&#123; echo $k.&apos;=======&gt;&apos;.$v.&apos;&lt;br&gt;&apos;; &#125; 2.预定义数组1.$GLOBALS 存储全局环境中所有的可用变量 2.$_GET 接收所有以get方式传输的值 3.$_POST 接收所有以post方式传输的值 4.$_FILES 专门用于接收上传文件 5.$_COOKIE 存储浏览器中的cookie值 6.$_SESSION 存储服务器中的session值（不重复登录） 7.$_REQUEST 同时接收get，post，cookie 的值 8.$_SERVER 存储服务器相关的信息，包含地址，IP，服务器环境等 12345678var_dump($_SERVER) # $_SERVER[&apos;HTTP_HOST&apos;] 主机地址 # $_SERVER[&apos;HTTP_USER_AGENT&apos;] 客户端的信息(设备, 浏览器信息) # $_SERVER[&apos;REMOTE_ADDR&apos;] 客户端的IP地址 (常见面试题) # $_SERVER[&apos;HTTP_REFERER&apos;] 获取上一级来源地址(你是从哪个页面来的) # $_SERVER[&apos;REQUEST_URI&apos;] 脚本地址(带参数) # $_SERVER[&apos;QUERY_STRING&apos;] 获取参数 # $_SERVER[&apos;SCRIPT_NAME&apos;] 脚本地址(不带参数) 9.当 method=get , action带参数时，action 的参数会被全部抛弃 ​ 解决方案：将 action 的参数通过隐藏域进行传递 123456&lt;form action=&quot;http://localhost/s86/0416/09-server.php?name=999&amp;age=99&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;name&quot; value=&quot;999&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;age&quot; value=&quot;99&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 10.上传文件 三个必要条件： file表单必须要有name，用以在PHP端接收内容 form表单中 method = post form表单中 enctype=multipart/form-date 单文件上传： ​ &lt;input type=&quot;file&quot; name=&quot;xxx&quot;&gt; 多文件上传： ​ 1.需要在name值得最后面加 [ ]，形成数组接收多内容 ​ 2.file 添加 multiple 属性 3.字符串数组把字符串当做数组来使用 123456789101112131415161718192021$str = &apos;i love you&apos;; echo $str[0]; echo $str[1]; echo $str[2]; echo $str[3]; // ... echo $str[9]; # 已经超出字符串范围 echo @$str[10]; var_dump( @$str[10] ); # 空字符串 echo &apos;&lt;hr&gt;&apos;; // for($i=0; $i&lt;10; $i++)&#123; // echo $str[$i]; // &#125; for($i=0; @$str[$i] !== &apos;&apos; ; $i++)&#123; echo $str[$i]; &#125; 2.正则表达式1.定义：正则表达式就是用某种模式去匹配字符串的公式 2.功能：主要用于字符串的查询，替换操作 3.组成：由正规字符和一些特殊字符组成 4.特征： 小而强大 的控制源（正则集的代数） 存储大 读取快 1正则语法规则：包含：定界符，原子，元字符，模式修正符 2.定界符：表示一个正则表达式的开始和结束，有以下三种方式： / [0-9] / 一对斜线 #[0-9]# 一对井号 {[0-9]} 一对大括号 3.原子：表达式中代表一个匹配单元的个体，分为可见原子和不可见原子 不可见原子： 换行符 \n 回车 \r 制表符 \t 空格 其他不可见符号 4.元字符1）原子的筛选方式： | 匹配两个或多个分支选择 [ ] 匹配方括号中的任意一个原子 [^] 匹配除了方括号中的原子之外的任意字符 2）原子的集合（将某一类原子归类简化） . 匹配除换行符之外的任意字符 \d 匹配任意一个十进制数字，即[0-9] \D 匹配任意一个非十进制数字，即[^0-9] \s 匹配一个不可见原子，即[\n\t\r] \S 匹配一个可见原子，即[^\n\t\r] \w 匹配一个数字、字母或下划线，即[0-9a-zA-Z_] \W 匹配一个非数字、字母或下划线，即[^0-9a-zA-Z_] 3）量词（查找字符串中某个原子连续出现多少次） {n} 表示其前面的原子出现n次 {n,} 表示其前面的原子至少出现n次 {n,m} 表示其天免得原子出现了n~m次 * 匹配0次，1次或者多次其前的原子，即{0,} + 匹配1次或者多次其前的原子，即{1,} ? 匹配0次或者1次其前的原子，即{0,1} 4）便捷控制，模式单元和模式选择符 ^ 匹配字符串开始的位置 $ 匹配字符串结尾的位置 ( ) 匹配其中的整体为一个原子 (|) 匹配其中的两个或者更多的选择之一，分隔多选一模式 5.模式修正符 贪婪匹配 .* 匹配结果存在歧义时取其长（默认） 懒惰匹配 U 匹配结果存在歧义时取其短，同.*? 忽略空白 x 匹配结果忽略空白 大小写匹配 i 匹配结果不区分大小写 中文适配 u 把中文汉字当做一个字符计算 6.正则的基本使用 正则在PHP中就是字符串类型 1.函数： 1）preg_match(正则，字符串 [,匹配结果]) （单词匹配函数） ​ 返回值：匹配的次数（0-失败；1-成功） 2）preg_match_all(正则，字符串 [,匹配结果]) （全部匹配函数） ​ 返回值：字符串中匹配字符的个数 3）preg_replace(正则，替换值，对象) （替换匹配字符串函数） ​ 返回值：替换之后的对象 4）preg_grep(正则，数组) （过滤函数） ​ 返回值：符合过滤条件的字符串 2.后向引用 ​ \1 代表将第一个（）内的内容复制到 \1 所在的位置 ​ \2 代表将第一个（）内的内容复制到 \2 所在的位置 ​ \n 代表将第一个（）内的内容复制到 \n 所在的位置 3.分组概念：（）模式单元 ​ 在正则中，一旦匹配（）的内容，会产生两个效果 ​ 1)将（）内的内容当成一个整体，以一个大原子的形式看待 ​ 2)将（）内的内容送入子模式匹配 ​ 参与子模式匹配，方便后向引用 若只是单纯想将（）内容当成一个整体，不想让（）内容参与子模式，可以取消子模式：（?:正则内容） 4.中文 中文在PHP中默认占3位，模式修正符 u 可以将中文当做一位. 若要统计字符串中有多少汉字，可以匹配 \x{4e00}-\x{9fa5} . 3.时间函数1.时区​ 获取时区：date_default_timezone_get() ​ 设置时区：date_default_timezone_set() 默认时区为UTC时区，世界标准时间（英国 格林威治时间） 中国时区为参数 PRC 2.Unix时间戳 time()​ time( ) 获取的时间为自1970年一月一日开始到现在的秒数 3.时间戳格式化 date()​ date(格式，时间戳) 格式：（严格区分大小写） 12345678910111213// Y 4位年份// y 2位年份// M 英文月份// m 数字月份// w 中文周几// W 中文第几周// D 英文周几// d 天// H 24小时// h 12小时 配合a// i 分钟// s 秒数// z 第几天 格式中除了字母外，其他字符都是原样输出 4.创建固定时间点 mktime()​ mktime(时,分,秒,月,日,年) 创建的时间点格式也是Unix时间戳 5.英文时间命令 strtotime()​ strtotime() 格式： 123456//now 此刻时间//yesterday 昨天//tomorrow 明天//last year 上一年//-2 day 前两天//2 year 两年后 时间上限：2037-12-31 23:59:59 6.延迟 sleep()​ sleep(秒数) 7.微秒 microtime()​ microtime() 将时间戳微秒数显示出来 ​ 参数：false（默认）微秒数在前，较精确 ​ true 将微秒数置后，方便参数计算]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 简介04-函数]]></title>
    <url>%2F2017%2F12%2F27%2FPHP%20%E5%9F%BA%E7%A1%8004-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.函数 function1.定义：​ 用来执行特定任务，实现某种功能 2.分类：​ 系统函数：PHP自带的函数，如数学，字符串，数组，时间… ​ 自定义函数：用户根据具体的需求来设计的函数 3.自定义函数​ 1.格式： ​ function 函数名（参数1，参数2，...）{代码块} ​ 2.注意事项： ​ 1） function 关键字不能少； ​ 2）函数名不区分大小写； ​ 3）参数（也称形参）可以写也可以不写，具体根据需求决定； ​ 4）代码块：函数功能的主要部分； 4.特性： 函数不调用不会自动执行 没有执行函数时，依旧会检测里面的语法，若有错误，程序报错 函数互不影响，可以互相调用 调用函数和定义函数的先后顺序没有要求 5.调用函数​ 函数名（）; 6.函数名1 函数的命名规范：​ 由数字，字母和下划线组成，但不能由数字开头 2 函数名不区分大小写3 函数命名要求​ 有意义，以提高可读性（动词＋名词） 4 函数命名方式：1.小驼峰命名法： ​ 从第二个单词开始，首字母大写 getUserName 2.大驼峰命名法（帕斯卡命名法） ​ 每个单词的首字母都大写 GetUserInfo 3,下划线命名法 ​ 每个单词之间用下划线隔开 var_dump 5 函数名不允许重复7.返回值 return1.关键字： ​ return 2.格式： ​ return 内容 3.流程： ​ 当程序执行到 return 时，马上将“内容”返回到调用函数的地方 4.返回状态： 自然返回：函数中的代码全部执行完，自动回到调用函数的地方 没有返回值时，强行接收，只能得到null 提前返回：函数中执行了return，马上结束函数，并返回到调用函数的地方 当程序执行到return时，立马返回，带了一个内容，如果想带两个变量回去，可以将多个变量存入同一个数组中，并return数组。 8.参数1.定义： ​ 参数分为实参（实际参数）和形参（形式参数） ​ 实参—— argument ，在调用函数时给的具体参数 ​ 形参——parameter ，在定义函数时给的某一类参数形式 2.参数接收 1）实参个数=形参个数 （匹配完美） ​ 实参与形参会一一对应，相互匹配接收 2）实参个数&gt;形参个数 ​ 和形参匹配的前几个实参一一接收，后面多余的实参会被抛弃 3）实参个数&lt;形参个数 ​ 多余的形参通常会采用之前设置的默认值，若没有默认值，则会被当做未定义变量 9.可变长度参数的函数当实参个数为一个不确定值时，称为可变长度参数的函数 接收所有实参（数组形式） func_get_args() 单独获取键为N的实参 func_get_arg(N) 统计一共有多少个实参 func_num_args() 当不知道有多少实参时，形参一个都不要写，用上述函数接收数据 1234567891011// 需求:// 根据传入的多个实参, 进行求和function add()&#123; $sum=0; $count=$func_num_args(); for($i=0;$i&lt;$count;$i++)&#123; $sun+=func_get_arg($i); &#125; return $sum;&#125; 10.函数设计准备1.设计函数名：​ 具体功能描述 2.考虑参数设置： 功能中需要输入几个参数 参数需不需要设置默认值 3.核心功能​ 其中缺乏的数据，可以先模拟出来，保证结果是有效的 4.补充​ 缺什么补什么，把模拟数据扩展为灵活数据 123456789//需求：获取 x~y 之间的偶数function getEven($x,$y)&#123; for($i=$x;$i&lt;$y;$i++)&#123; if($i%2 == 0)&#123; $result[]=$i; &#125; &#125;return $result;&#125; 2.变量作用域1.定义： ​ 变量能够作用的区域。 2.分类 全局变量：在函数外部声明的变量 局部变量：在函数内部声明的变量 3.规则： 全局变量无法直接在局部作用域中使用 局部变量不能直接在全局作用域中使用 12345678$a=100; #全局变量function demo()&#123; $b=200; #局部变量 echo $a; #失败&#125;demo(); #null，函数内部声明的变量，在函数结束时，所有的值会被释放echo $b #失败，输出时，会输出全局$b，若找不到就报错 4.改变作用域 将全局变量作用域扩展至局部变量： 通过超全局数组获得全局变量， $GLOBALS[&#39;a&#39;] 用于存储所有全局可用的变量 将局部变量作用域扩展至全局； 通过使用 global 给局部变量赋予令牌，使其能够在全局中使用。 5.常量 12345678910const CHINA=&apos;zhongguo&apos;; #全局定义常量function demo()&#123; echo CHINA; #正常输出，可以直接在局部中使用 const NAME=&apos;cheng&apos;; #不能在函数中通过const定义局部常量 define(&apos;AGE&apos;,20); #可以用define( )定义成功，但不推荐 echo AGE&#125;demo();echo AGE; 小结：常量在本质上是没有作用域的。 6.静态变量 ​ 1.定义：在函数中，被声明为静态变量的值，函数执行结束后不会被释放，而是在下一次调用同函数时，直接使用上一次的静态值结果。 ​ 2.关键字： static ​ 3.多个不同函数中，出现相同的静态变量，这些静态变量互不影响。 12345678function demo()&#123; static $num = 10; # 静态初始值 echo $num.&apos;&lt;br&gt;&apos;; $num++;&#125;demo(); #10demo(); #11]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 简介03-运算符/流程控制]]></title>
    <url>%2F2017%2F12%2F13%2FPHP%20%E5%9F%BA%E7%A1%8003-%E8%BF%90%E7%AE%97%E7%AC%A6.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. 运算符 OperationPHP中运算符主要有以下七种： 算术运算符 自增/自减运算符 赋值运算符 比较运算符 拼接运算符 逻辑运算符 三元运算符 1.算术运算符：​ 加 减 乘 除 取模（取余） ​ + - * / % ​ 取模（%）详解： ​ 1)普通取模： 123var_dump(5%2); #1var_dump(1%2); #1var_dump(2%2); #0 ​ 2)高阶取模 ​ ①取模的正负：取决于被除数的正负 1234var_dump(5%2); #1var_dump(5%-2); #1var_dump(-5%2); #-1var_dump(-5%-2); #-1 ​ ​ ②取模结果的范围：x~y 12345678var_dump(0%3); #0 # %3var_dump(1%3); #1var_dump(2%3); #2var_dump(3%3); #0var_dump(4%3); #1var_dump(5%3); #2var_dump(6%3); #0var_dump(7%3); #1 # %3的结果永远在0~2之间，都小于3 ​ 12345678var_dump(0%5); #0 # %5var_dump(1%5); #1var_dump(2%5); #2var_dump(3%5); #3var_dump(4%5); #4var_dump(5%5); #0var_dump(6%5); #1var_dump(7%5); #2 # %x的结果永远在0~x-1之间，都小于x ​ ​ 若需求2~5，如何才能达到需求： 1234 0 ~ ？ #？=5-2=3 0~3为%4的结果+ 2----------------- 2 ~ 5 #即要达到2~5的结果，需要%4+2 ​ ​ 推理到x~y，则有：%(y-x+1)+x 1234 0 ~ ? # ?=y-x 为%[(y-x)+1]的结果+ x---------------- x ~ y # 即要达到x~y的结果，需要%（y-x+1）+x ​ 2.拼接运算符 string1.符号： ​ . 小数点 2.作用 ： ​ 拼接变量与字符串 / 拼接变量与变量 3.实例： 1234567$a=&apos;winter&apos;;$b=&apos;fall&apos;;$c=&apos;winter fall is the home of arya&apos;; $c=&apos;$a $b is the home of arya&apos;; #不识别，显示为$a $b$c=$a.&apos; &apos;.$b.&apos; is the home of arya&apos;; #正常显示echo $c; 3.赋值运算符 equal主要有以下几种赋值运算符： ​ 变量=值 赋值（先运算=右边的，再运算=左边的） ​ 变量+=值 变量=变量+值​ 变量-=值 变量=变量-值​ 变量*=值 变量=变量*值​ 变量/=值 变量=变量/值​ 变量%=值 变量=变量%值​ 变量.=值 变量=变量.值 4.比较运算符 compare​ 1.比较的结果都是布尔值（bool） ​ 2.运算符： ​ &gt; &gt;= 大于，大于等于 ​ &lt; &lt;= 小于，小于等于 ​ == 等于 （判断=两端的值是否相等） ​ === 全等于 （判断两边的值和数据类型是否全部相等） ​ != 不等于 （判断两边的值是否不相等） ​ !== 全不等于 （判断两边的值和数据类型是不是都不相等） 5.逻辑运算符 logic 类型 运算符 运算规则 逻辑与 &amp;&amp; 两边全真才是真,一边为假即为假 逻辑或 || 一边为真即是真，两边为假才是假 逻辑非 ！ 真即是假，假即是真 6.自增/自减 increment​ 1.自增运算符：++ ​ 2.自减运算符：-- ​ 3.易混乱点： ​ a++ 先返回a值，再给a+1 ​ ++a 先给a+1，再返回a值 12345$a=10;echo $a++; #输出a 10echo $a; #输出a+1 11echo ++$a; #输出a+1 12echo $a; #输出a 12 7.三元运算符 three​ 一元运算符：！ a++ a-- ​ 二元运算符：a=b a%b a-b ​ 三元运算符：?: 1.定义：简化的if-else结构 2.格式：条件表达式 ? true环境 : false环境； 3.运算规则： ​ 当条件表达式成立时，进入true环境执行；当条件不成立时，进入false环境。 4.实例 ​ echo 1+1==2?&#39;yes!&#39;:&#39;no&#39;; 补充：运算符优先级 2. PHP流程控制在PHP中，主要有四种结构：顺序结构，分支结构，循环结构和异常结构，其中异常结构主要适用于面向对象，先不进行介绍。 1.顺序结构：代码从上往下依次执行；（参考HTML中文档流） 2.分支结构：通过 if / switch 来进行分支选择 3.循环结构：通过 for / while 来重复执行某一部分的代码 以下详细介绍分支结构和循环结构的具体内容 1.顺序结构（不介绍）2.分支结构1.单一分支结构：（if） if( 条件表达式 ) 一行代码； 该结构只能影响紧跟在 if 后面的第一行代码，从第二行开始，就不受 if 判断结果的影响 if( 条件表达式 ){ 一个代码块； } 该结构后面可以跟一整个代码块，通过复合结构（代码块）， if 可以影响多条语句 2.双向分支结构（else） if( 条件表达式 ){ 代码段;}else{ 代码段；} if 语句的延伸，可以对不满足 if 条件的情况进行阐述 3.多向条件分支结构（elseif） if(条件表达式){代码块}elseif（条件）{ ... }elseif(条件){ ... }...else{...} 在 elseif 中只有一个被执行，多个条件是逻辑或的关系，只要有一个满足，就可以进入相应的true环境，优先处理包含范围较小的条件 4.巢状条件分支结构（if 嵌套） 1234567if(条件表达式)&#123; if(条件表达式)&#123; if(条件表达式)&#123; ... &#125;else&#123; ... &#125; &#125;else&#123; ... &#125; &#125;else&#123; ... &#125; 这里的多个条件是逻辑与的关系，要同时满足才能进入最深的true环境 5.多向条件分支结构(switch) 1234567switch( 表达式 )&#123; case 值1: 代码块1；break; case 值2： 代码块2;break; ... case 值n: 代码块n;break; default: 代码块n+1;&#125; 专门用于等值判断， switch 后面的表达式数据类型只能是整型或字符串，不能为bool 值; 若不加 break ，会在匹配到值后继续向下执行后面的所有标识; default 代表不与之前所有值匹配的情况; 6.练习 简易计算器 需求: 由用户输入两组 数值, 并选择运算符, PHP根据运算符结算结果 123456789101112131415161718192021222324//1.接收数据： $n1=empty($_GET[&apos;num1&apos;])? null :$_GET[&apos;num1&apos;]; #三元运算符，若设置则赋值，未设置赋值null//2.根据运算符选择计算方式 $result = null; switch ($ope) &#123; case &apos;+&apos;: $result = $n1 + $n2; break; case &apos;-&apos;: $result = $n1 - $n2; break; case &apos;*&apos;: $result = $n1 * $n2; break; case &apos;/&apos;: $result = $n1 / $n2; break; &#125;//3.HTML表单提交 &lt;input type=&quot;text&quot; name=&quot;num1&quot; value=&quot;&lt;?= $n1 ?&gt;&quot;&gt; &lt;select name=&quot;ope&quot;&gt; &lt;option value=&quot;+&quot; &lt;?= $ope == &apos;+&apos;?&apos;selected&apos;:null ?&gt; &gt;+&lt;/option&gt; &lt;option value=&quot;-&quot; &lt;?= $ope == &apos;-&apos;?&apos;selected&apos;:null ?&gt; &gt;-&lt;/option&gt; &lt;option value=&quot;*&quot; &lt;?= $ope == &apos;*&apos;?&apos;selected&apos;:null ?&gt; &gt;&amp;times;&lt;/option&gt; &lt;option value=&quot;/&quot; &lt;?= $ope == &apos;/&apos;?&apos;selected&apos;:null ?&gt; &gt;&amp;divide;&lt;/option&gt; &lt;/select&gt; #三元运算符，若选中默认显示，未选中为空 &lt;input type=&quot;text&quot; name=&quot;num2&quot; value=&quot;&lt;?= $n2 ?&gt;&quot;&gt; #value输入提交时默认显示 //4.HTML中输出结果 &lt;span&gt; &lt;?= $result ?&gt; &lt;/span&gt; 3.循环结构1.while循环（当） 格式： 12345$sum=1; 初始化;while($num&lt;=100)&#123; while(条件)&#123; echo $num; 代码块； $num++; &#125;&#125; 循环规则： ​ 初始化 –&gt; 条件 成立–&gt; 代码块 –&gt;条件（循环） ​ 不成立 –&gt; 跳出循环 注意： while 循环常用来控制循环次数未知的循环结构，条件表达式的结果必须为 bool 值 2.do…while循环（直到） 格式： 12345$num=1; 初始化;do&#123; do&#123; echo $num; 代码块； $num++; &#125;while（条件）；&#125;while($num&lt;0); 循环规则： ​ 初始化 –&gt; 代码块 –&gt; 条件 成立 –&gt; 代码块（循环） ​ 不成立 –&gt; 跳出循环 注意： do...while 是先执行一次代码块，然后判断是否符合条件，来决定是否继续循环； ​ while(条件) 后面要加上分号 ； ​ 适合执行至少必须循环一次的情况。 3.for循环 格式： for( 初始化 ; 条件表达式 ; 增量 ){ 代码块; } 循环规则： 初始化 –&gt; 条件表达式 成立–&gt; 代码块 –&gt; 增量 –&gt; 条件 –&gt; 代码块（循环） ​ 不成立–&gt; 跳出循环 注意点： for语句中的三部分可以部分或全部为空，如把第一部分初始化语句提到for语句之前，第二部分和第三部分提到for语句之内；（for的退化形式） 123//把初始化提到for之前 $num=1; for(;$num&lt;10;$num++)&#123;echo $num;&#125; 123456//把第三部分增量提到for之内 $num=1; for(;$num&lt;10;)&#123; echo $num; $num++; &#125; 1234567//把第二部分条件表达式提到for之内 $num=1; for(;;)&#123; if($num&lt;10)break; echo $num; $num++; &#125; for语句中的每个部分都可以写多个表达式，之间用 , 逗号隔开； 4.循环语句之间的区别 while语句先判断再执行，do…while语句先执行一次，再判断是否继续循环。 while语句计算机执行速度较快，for语句代码书写方便，排版整洁，使用程度较高。 5.for循环使用技巧 当条件表达式为空或非false值时，程序条件永远满足，产生死循环 12345$x=0;for(;;)&#123; echo $x.&apos; &apos;; $x++;&#125; 当条件表达式为与false等价（0 , 0.0，‘ ‘，…）时，程序认为条件不满足，不会执行; 当初始化表达式为空时，false=0，初始值为0； 当增量为空时，若条件成立则一直循环输出初始值；z 4.特殊流程控制符1.continue当执行到continue时，会准备进入下一轮循环 2.break当执行到break时，会马上结束当前循环或者分支结构 3.die当执行到die时，整个程序结束（后面全部不会执行）（？断点调试？） 5.扩展使用​ 需求：输出0~9，如果碰到4，跳过 12345for($i=0;$i&lt;10;$i++)&#123; if($i!==4)&#123; echo $i.&apos; &apos;; &#125;&#125; 12345for($i=0;$i&lt;10;$i++)&#123; if($i==4)&#123; continue; &#125;echo $i.&apos; &apos;;&#125; ​ 需求：输出0~9，如果碰到4，就结束循环 12345for($i=0;$i&lt;10;$i++)&#123; if($i==4)&#123; break; &#125;echo $i.&apos; &apos;;&#125; ​ 需求：输出0~9，如果碰到4，就结束程序 12345for($i=0;$i&lt;10;$i++)&#123; if($i==4)&#123; die(&apos;111&apos;); &#125;echo $i.&apos; &apos;;&#125; ​ 结论： continue 只是跳过此次循环，继续下次循环； break 是结束本循环结构，继续后面的程序执行； die 是结束整个程序，后面的程序直接无效；（exit 同样） 5.HTML与PHP结合写法 for 和 HTML 混合写法： 123&lt;?php for() ?&gt; HTML代码块&lt;?php endfor ?&gt; if 和 HTML 混合写法： 123456789101112131415161718192021 &lt;?php if() ?&gt; HTML代码块 &lt;?php endif ?&gt; &lt;?php if() ?&gt; HTML代码块(true环境) &lt;?php else: ?&gt; HTML代码块(false环境) &lt;?php endif ?&gt; &lt;?php if(): ?&gt; html代码块 (true环境)&lt;?php elseif(): ?&gt; html代码块 (true环境)&lt;?php elseif(): ?&gt; html代码块 (true环境)&lt;?php elseif(): ?&gt; html代码块 (true环境)&lt;?php else(): ?&gt; html代码块 (false环境)&lt;?php endif ?&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 简介02-数据类型转化]]></title>
    <url>%2F2017%2F12%2F04%2FPHP%20%E5%9F%BA%E7%A1%8002-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.几个常用函数1.释放内存：unset（）； 2.检测一个变量是否为空：empty(); 实质上为检测是否与false等价 空=true 非空=false 3.检测一个变量是否设置：isset(); 实际上为检测是否为null或未定义变量 已设置：true 未设置：false 12345678910$a=10; #未空，已设置$a=0; #空，已设置$a=0.0; #空，已设置$a=false; #空，已设置$a=[]; #空，已设置$a=&apos;0&apos;; #空，已设置$a=null; #空，未设置$a=$b; #空，未设置$a=$obj; #未空，已设置$a=$resource; #非空，已设置 2. 输出方式PHP中常用输出方式常见的有4种： 1.echo ​ 为PHP基本语法，支持int，float，string，resource类型的数据输出 ​ 格式：echo &#39;输出内容&#39;； 2.print / print（） ​ print为基本语法结构，print（）为函数，返回值为int ​ 支持int，float，string，resource类型的数据输出 ​ 格式：print 输出内容 print（输出内容）； 3.print_r（） ​ print_r（） 为函数，返回值为bool ​ 支持int，float，string，array，resource，object类型的数据输出 4.var_dump（） ​ var_dump（）为函数，无返回值。可以支持任何类型的数据 print_r() 和 var_dump() 的区别： print_r() 理论上可以输出无数个数据，但实际上受到内存大小的限制 var_dump() 最多只能输出128条数据，其他的隐藏 print_r() 的美化： 123print_r(&apos;&lt;pre&gt;&apos;);print_r($arr);print_r(&apos;&lt;/pre&gt;&apos;); 3. 数据类型转化 DateType运算本质是同类型的数据之间的运算 标量数据的转换分为两种：自动类型转换 和 强制类型转换 1.自动类型转换：隐式转换 布尔型（bool）转为整型（int） 12var_dump(true+10); #11 true-&gt;1var_dump(false+10); #10 false-&gt;0 布尔型（bool）转为浮点型（float） 12var_dump(true+10.5); #11.5 true-&gt;1.0var_dump(false+10.5); #10.5 false-&gt;0.0 字符串（string）转为整型（int） 12345var_dump(&apos;abc&apos;+10); #10var_dump(&apos;123&apos;+10); #133var_dump(&apos;1a2b&apos;+10); #11var_dump(&apos;a1b3&apos;+10); #10var_dump(&apos;12av&apos;+10); #22 从前往后，保留前面的数字，从第一个非数字开始向后全部抛弃（包括后面的数字） 字符串（string）转为浮点型（float） 1234567var_dump( &apos;1.2&apos; + 10.5 ); #11.7var_dump( &apos;1a.2&apos; + 10.5 ); #11.5var_dump( &apos;a1.2&apos; + 10.5 ); #10.5var_dump( &apos;1.2e3&apos; + 10.5 ); #1210.5var_dump( &apos;1.2e3e4&apos; + 10.5 ); #1210.5var_dump( &apos;1.2.3.4&apos; + 10.5 ); #11.7 从前往后，保留前面的数字，从第一个非数字开始向后全部抛弃（包括后面的数字） 识别第一个科学计数法和第一个小数点 整型（int）转为浮点型（float） 1var_dump( 1 + 2.5 ); # 3.5 1 -&gt; 1.0 2.强制类型转换：强制转换 临时转换 通过运算符来强制转换（值适用于标量和复合数据，不包含特殊类型的数据） 123456var_dump((int)$str);var_dump((float)$str);var_dump((bool)$str);var_dump((string)$str);var_dump((object)$str);var_dump((array)$str); 通过函数来强制转换 1234var_dump(intval($str));var_dump(floatval($str));var_dump(boolval($str));var_dump(strval($str)); #字符串转化是strval，而不是stringval 永久转换 通过函数 settype(变量名，类型) 来永久转换数据，之后数据不一定能转换回原数据 12345settype($str,&apos;int&apos;);var_dump($str); settype($str,&apos;string&apos;);var_dump($str); 4. 常量 Define1.常量：经常固定不变的量（constant） 2.格式：格式：const 常量名=常量值； 或者 define(常量名，常量值) 12345const CHINA = &apos;中国&apos;; var_dump( CHINA );define(&apos;NUME&apos;,1000);var_dump(NUME); 注意： ​ 常量名默认区分大小写，推荐使用大写，与变量区分； ​ define函数的完整格式为define（常量名，常量值，bool值），其中总bool值默认值为false，代表区分大小写，若为true则不区分大小写； 3.魔术常量： ​ __FILE__ 当前文件路径 ​ __LINE__ 当前代码行号 ​ __DIR__ 当前文件目录 123var_dump(__FILE__); #:string &apos;D:\wamp\www\XIA\0409\08-define.php&apos; (length=34) var_dump(__LINE__); #:int 39var_dump(__DIR__); #:string &apos;D:\wamp\www\XIA\0409&apos; (length=20) 4.预定义常量： ​ PHP_INT_MAX 显示最大整型常量 ​ PHP_INT_MIN 显示最小整型常量 ​ M_PI 圆周率 ​ PHP_VERSION 显示当前PHP版本号 ​ PHP_OS 显示当前使用操作系统（Windows都显示WINNT） 12345var_dump(PHP_INT_MAX)； #:int 2147483647var_dump(PHP_INT_MIN)； #:int -2147483648var_dump(M_PI)； #:float 3.1415926535898var_dump(PHP_VERSION)； #:string &apos;7.0.4&apos; (length=5)var_dump(PHP_OS); #:string &apos;WINNT&apos; (length=5) 5. 运算符 OperationPHP中运算符主要有以下七种： 算术运算符 自增/自减运算符 赋值运算符 比较运算符 拼接运算符 逻辑运算符 三元运算符 1.算术运算符： ​ 加 减 乘 除 取模（取余） ​ + - * / % ​ 取模（%）详解： ​ 1)普通取模： 123var_dump(5%2); #1var_dump(1%2); #1var_dump(2%2); #0 ​ 2)高阶取模 ​ ①取模的正负：取决于被除数的正负 1234var_dump(5%2); #1var_dump(5%-2); #1var_dump(-5%2); #-1var_dump(-5%-2); #-1 ​ ​ ②取模结果的范围：x~y 12345678var_dump(0%3); #0 # %3var_dump(1%3); #1var_dump(2%3); #2var_dump(3%3); #0var_dump(4%3); #1var_dump(5%3); #2var_dump(6%3); #0var_dump(7%3); #1 # %3的结果永远在0~2之间，都小于3 ​ 12345678var_dump(0%5); #0 # %5var_dump(1%5); #1var_dump(2%5); #2var_dump(3%5); #3var_dump(4%5); #4var_dump(5%5); #0var_dump(6%5); #1var_dump(7%5); #2 # %x的结果永远在0~x-1之间，都小于x ​ ​ 若需求2~5，如何才能达到需求： 1234 0 ~ ？ #？=5-2=3 0~3为%4的结果+ 2----------------- 2 ~ 5 #即要达到2~5的结果，需要%4+2 ​ ​ 推理到x~y，则有：%(y-x+1)+x 1234 0 ~ ? # ?=y-x 为%[(y-x)+1]的结果+ x---------------- x ~ y # 即要达到x~y的结果，需要%（y-x+1）+x]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 基础01- 数据类型]]></title>
    <url>%2F2017%2F11%2F21%2FPHP%20%E5%9F%BA%E7%A1%8001-%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.PHPPHP特性： 1.PHP文件或者文件夹命名中不能有中文，不能有中文路径。 2.PHP文件存放位置：wamp/www/目录下。 3.访问PHP脚本的步骤： ​ 开启wamp服务——&gt;在浏览器地址栏中输入：localhost 4.PHP是什么：（Professional Hypertext Preprocessor）超文本预处理器 一句话：一种用来开发动态网站的服务器脚本语言。 5.PHP定界符 ​ 格式：&lt;?php PHP代码 ?&gt; ​ 只有在定界符内的代码才会被PHP解析 6.向浏览器输出一句话：echo &#39;hello,world!&#39;; 7.PHP设置编码（一般情况下，该编码声明写在文件头部） ​ header(&#39;content-type:text/html;charset=&quot;utf-8&quot;&#39;); 8.注释 单行注释：#注释内容 or //注释内容 多行注释：/*注释内容*/ 9.PHP基本语法 每一条命令均以分号（；）结尾，代表这条命令已经结束。 只有最后一条可以不加，但推荐都加上。 10.查询PHP相关信息 ​ phpinfo(); 11.若只想输出一句话，可以使用如下格式： ​ &lt;?=&#39;hello,world!&#39;?&gt; ​ &lt;?php echo &#39;hello,world!&#39;?&gt; 2.变量var1.变量，即未知数（variable）,主要是负责指向（引用）一个值，值不是固定的。 ​ $a=10; 2.格式：$变量名=值； 值必须给定，不给会报错，称之为“未定义变量” 3.变量命名 右数字，字母和下划线组成； 不能以数字开头； 变量严格区分大小写； 支持中文，但不推荐 4.变量技巧 1）可变变量：将一个变量的值作为另一个变量的名字来使用 12345$山鸡 = &apos;陈小春&apos;;$陈小春 = &apos;应采儿&apos;;echo $陈小春; #输出应采儿echo $$山鸡; #输出应采儿 引用变量名为另一个变量值的变量值，可以使用两个$直接引用 2）传值：将一个变量的值赋予另一个变量 12345$a=10;$b=$a; $b=5;echo $a; #输出10echo $b; #输出5 3）传址：将一个变量的内存地址赋予另一个变量 12345$a=10;$b=&amp;$a; $b=5;echo $a; #输出5echo $b; #输出5 3.数据类型PHP中的数据类型包括： 标量类型： 整型 Int 浮点型 Float 布尔型 Bool 字符型 String 复合类型： 数组 array 对象 object 特殊类型： 资源 resource 空类型 NULL 4.整型int1.最大整型：PHP_INT_MAX 最大整型就是php中数据显示为整型的最大值，为2的31次方 若某个值比PHP_INT_MAX还大，则自动转为float型 2.检测是否为整型：is_int(); 输出值为bool值 3.进制 基数 前缀 二进制 0/1 0b 八进制 0~7 0 十进制 0~9 无前缀 十六进制 0~f 0x 4.计算方法： 1）任何进制转为十进制： 次方求和法：∑（基数*进制^次方） 2）十进制转化为其他进制： 除基数取余法：当商比任意进制基数还小时，停止除法运算；将余数倒排序，即得到结果。 快捷方法： 2048 1024 512 256 128 64 32 16 8 4 2 1 5.浮点型 float1.科学计数法： 12$num=2e3;var_dump($num); #输出为浮点型 如果使用科学计数法，则默认该值为浮点型数据 2.判断是否为浮点型数据：is_float(); 3.精度： 浮点型数据在php显示结果中只显示14位有效数字，故在浮点运算中，结果并不精确，浮点型数据不适合做二进制计算，同时也尽量不要用小数做等值判断，防止数值误差产生，得到错误结果 12345678910111213$a=0.1+0.2;var_dump($a);if($a==0.3)&#123; echo &apos;true&apos;;&#125;else&#123; echo &apos;false&apos;; #运算结果为false&#125;if($a&gt;0.3)&#123; echo &apos;true&apos;;&#125;else&#123; echo &apos;false&apos;; #运算结果为true&#125; 6.布尔型 bool/boolean1.值：false true 2.作用：代表两种极端状态，常用与判断比较等 3.判断数据是否属于bool值：is_bool(); 4，等价判断：以下7种情况与false等价 false 0 0.0 ‘’ or ‘0’ NULL空类型 空数组 未定义变量 7.字符串string1.作用： 用于存储or表达信息，包含数字，字母，标点，汉字等 2.格式： 小段内容：单双引号 1234$a=&apos;dead man may never die&apos;;$b=&apos;winter is coming&apos;;var_dump($a);var_dump($b); 大段内容：heredoc结构 1234 $c=&lt;&lt;&lt;xxx曾经跟媳妇吵架, 吵到最激烈的时候, 我就想: 一个大老爷们跟老娘们较什么劲. 当时就跟媳妇道歉了,媳妇挺开心的... 他哥就放下菜刀, 他妹松开了拽着我头发的手, 老丈人拿起了电话: 棺材退了吧. 夫妻之间只要多沟通, 生活还是很和谐.xxx; var_dump($c); 注意： 1）xxx可以替换成任意其他结构次（自制） 2）保证首尾一致 3）开始结构词的后面不能有任何多余的字符（包括空格） 4）结尾结构词的前后不能有任何多余的字符（包括空格） 3.检测类型： 是否为字符串：is_string(); 是否为数字或数字字符串：is_numaric(); 是否为标量类型：is_scalar(); 4.单双引号的区别 单引号：不能识别变量，执行速度快；但不能识别解析转义字符， 双引号：可以识别变量，执行速度较慢；可以识别解析转义字符。 转义字符：\ 能够给普通字母赋予特殊意义，也可以把特殊意义的字符变成普通字符输出。 常见转义字符： \n 换行 \r 回车 \t 制表符Tab \&#39; &#39; \&quot; &quot; \$ $ 8.数组 Array1.简述：键值对； 2.定义：数据的集合； 3.格式：$数组名[]=数组值 或者 $数组名=[值1，值2，值3，...] 4.显示格式： 123456789 显示： array (size=7)$bag[]=&apos;三国演义&apos;; 0 =&gt; string &apos;三国演义&apos; (length=12)$bag[]=&apos;水浒传&apos;; 1 =&gt; string &apos;水浒传&apos; (length=9)$bag[]=&apos;红楼梦&apos;; 2 =&gt; string &apos;红楼梦&apos; (length=9)$bag[]=&apos;西游记&apos;; 3 =&gt; string &apos;西游记&apos; (length=9)$bag[]=&apos;10000&apos;; 4 =&gt; string &apos;10000&apos; (length=5)$bag[]=NULL; 5 =&gt; null$bag[]=1000; 6 =&gt; int 1000var_dump($bag); 5.数组操作： 查询数组中的一个值：通过键来查询； var_dump($bag[2];) 修改数组中的某个值：通过已经存在的键来修改； $bag[1]=&#39;菜根谭&#39;； 新增数组中的某个值：通过不存在的键来新增； $bag[9]=&#39;说文解字’； 删除数组中的某个值：通过键来操作（unset）； unset($bag[1]); 9.空类型 Null1.定义：null代表什么都没有，常用于先占据内存，供后期使用； 2.以下三种情况，直接显示null： 直接赋值null $a=null; 未定义变量 var_dump(@$b); @为错误抑制符，可以临时屏蔽$b的错误； 被删除的变量 unset($c); 注意：只要与false等价，基本都与null等价 10.对象 Object1.对象：在PHP中，一切皆对象 ​ 获取一个对象: 12$a=new stdClass; var_dump($a); #显示：object(stdClass)[1] 11 资源 Resource2.资源：所有的文件都是资源 ​ 获取一个资源： 12$b=fopen(&apos;./ex.html&apos;); var_dump($b); #显示：resource(3, stream)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 简介-背景特性]]></title>
    <url>%2F2017%2F11%2F14%2FPHP%E7%AE%80%E8%BF%B0-%E8%83%8C%E6%99%AF%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1. PHP应用领域 在浏览器端应用的软件, PHP都可以进行开发 门户网站: 新浪, 雅虎, 搜狐 电子商务: 淘宝, 京东 网页游戏的后台 APP接口 企业级项目: OA: 办公自动化系统 (学生, 员工档案, 考勤…) CRM: 客户关系管理系统 (销售, 中介, …) ERP: 企业物资管理系统 ( 快递, 猎头, .. ) 2. PHP市场行情拉勾网 Boss直聘 含金量较高: 100Offer 门槛: 2年以上的工作经验 3. 软件架构模式B/Sbrower/server 浏览器/服务器 无需下载, 通过浏览器来使用 依赖HTTP协议 数据存储服务器上, 安全性高 维护更新, 相对方便, 不占用用户时间 C/Sclient/server 客户端/服务端 先下载安装, 通过特定的客户端来使用 通过多种协议进行通信 数据有的存储在本地, 有的存储在服务器上, 相比B/S安全性低 维护更新, 相对麻烦, 比较占用用户时间 4.动静态网站静态网站在线浏览网页, 但是不能输入数据, 没有数据的更新和交互 动态网站有数据交互过程, 链接数据库 5. 浏览器内核浏览器Trident: IE 独流 Webkit: chrome, safari Gecko: firefox Blink: chrome 壳浏览器360 QQ 搜狗 猎豹 UC 百度 6. 开发工具IDE Sublime Text 3 最轻量级的IDE PHPStrom 最专业, 最热门的IDE之一 ATom Zend Studio VIM NodePad++ 7. LAMP 环境LAMP : Linux + Apache + MySQL + PHP LNMP: Linux + Nginx + MySQL + PHP 操作系统: Linux 服务器: Apache, Nginx 数据库: MySQL 脚本工具: PHP 8.使用PHP的特性PHP特性： 1.PHP文件或者文件夹命名中不能有中文，不能有中文路径。 2.PHP文件存放位置：wamp/www/目录下。 3.访问PHP脚本的步骤： ​ 开启wamp服务——&gt;在浏览器地址栏中输入：localhost 4.PHP是什么：（Professional Hypertext Preprocessor）超文本预处理器 一句话：一种用来开发动态网站的服务器脚本语言。 5.PHP定界符 ​ 格式：&lt;?php PHP代码 ?&gt; ​ 只有在定界符内的代码才会被PHP解析 6.向浏览器输出一句话：echo &#39;hello,world!&#39;; 7.PHP设置编码（一般情况下，该编码声明写在文件头部） ​ header(&#39;content-type:text/html;charset=&quot;utf-8&quot;&#39;); 8.注释 单行注释：#注释内容 or //注释内容 多行注释：/*注释内容*/ 9.PHP基本语法 每一条命令均以分号（；）结尾，代表这条命令已经结束。 只有最后一条可以不加，但推荐都加上。 10.查询PHP相关信息 ​ phpinfo(); 11.若只想输出一句话，可以使用如下格式： ​ &lt;?=&#39;hello,world!&#39;?&gt; ​ &lt;?php echo &#39;hello,world!&#39;?&gt;]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础-03]]></title>
    <url>%2F2017%2F10%2F29%2FCSS-03%2F</url>
    <content type="text"><![CDATA[1.盒子模型 盒子模型分为两类：（非IE）标准物理盒子 和 IE盒子 标准物理盒子：物理空间=内容+边框+内边距 （以外都是外边距） IE盒子：物理空间=内容 内容包括边框和内边距（内容固定，做减法） （以外都是外边距） 2.行块级元素 html中，标签分为两种： 块级 和 行级 块级元素（display：block）： 特征： 1.独占一行。 ​ 2.宽度若不设置，则默认与浏览器宽度一样； ​ 3.高度若不设置，则默认随着内容增高而增高； ​ 4.宽高，行高，内外边距的等属性均可以设置； ​ 5.容纳性：可容纳任何元素； 行级元素（display：inline）： 特征：1.不独占一行； ​ 2.宽度若不设置，则默认随着内容的增加而增加； ​ 3.高度若不设置，则默认随着内容的增高而增高； ​ 4.宽高，内外上下边距等无法控制，行高，内外左右边距等可以控制； ​ 5.容纳性：行级元素 3.内外边距外边距（margin）：定义元素与元素之间的距离 ​ margin：10px；（四边） ​ margin：10px 20px；（上下10，左右20） ​ margin：10px 20px 30px；（上10，左右20，下30） ​ margin：10px 20px 30px 40px；（上10 ，右20，下30，左40） 单边距： ​ margin-方向 :__px； 常用技巧：基于父级宽度内，自动居中 ​ margin-left：auto； ​ margin-right：auto； 常见简写： ​ marigin：__px auto； 内边距（padding）：定义边框与内容之间的距离 ​ padding：10px；（四边） ​ padding：10px 20px ；（上下10，左右20） ​ padding：10px 20px 30px；（上10，左右20，下30） ​ padding：10px 20px 30px 40px；（上10，右20，下30，下40） 单边距 ​ padding-方向：__px; 4.定位(position)使用场景：当元素（标签）发生重合时，就可以使用定位判定双方的位置属性。 属性名：position 属性值： absolute（绝对定位） 定位后是否保留原位置：不保留原来的位置（网） 定位原点：基于网页第一页的四个角落 relative（相对定位） 定位后是否保留原有位置：保留原来的位置（柱子） 定位原点：基于原来位置的四个角落 fixed（固定定位） 定位后是否保留原有位置：不保留原来的位置（网） 定位原点：基于当前可视窗口的四个角落 补充概念： 文档流：在body体中，标签从上往下依次排列，形成一条奔流不止的河流。 定位：脱离文档流，原始位置就会被清除，下方元素上移补位，定位元素就会与文档流中的元素发生重叠 定位优先级(z-index) ​ 当定位元素发生重叠时，可通过z-index来改变上层顺序； ​ 格式：z-index:数字； ​ 其中数字越大，优先级越高 仅限定位元素使用 5.浮动属性名：float 属性值：left | right | none 作用：脱离文档流，将兄弟（同级）元素排成一排 位置：不保留原来的位置 .box1{ background:pink; float:left; /*float:right;*/ } 有些场合不需要保留原来的位置，但有些也需要保留原来的位置 如何保留原来的位置：通过clear清除浮动 6.清除浮动属性名：clear 属性值：left | right | both 方法一：条件（原理） 在兄弟元素的最后面，加空标签（非浮动），通过空标签来清除前面的浮动元素 123456789101112原理 &lt;ul&gt; &lt;li&gt;小米手机&lt;/li&gt; &lt;li&gt;红米&lt;/li&gt; &lt;li&gt;电视&lt;/li&gt; &lt;li&gt;笔记本&lt;/li&gt; &lt;li&gt;家电&lt;/li&gt; &lt;li&gt;新品&lt;/li&gt; &lt;li&gt;路由器&lt;/li&gt; &lt;li&gt;智能硬件&lt;/li&gt; &lt;div style=&quot;clear: left;&quot;&gt;&lt;/div&gt; &lt;/ul&gt; 方法二 ​ 在浮动元素的父级，添加属性overflow：hidden，形成BFC区域，即可清除儿子项的浮动 BFC区域：内部元素不会影响任何外界的元素（统统保留位置） 形成BFC区域的方式：overflow：hidden；或者 float：none； 目前部分浏览器不支持BFC，故不推荐此种写法 12345678910&lt;ul style=&quot;overflow:hidden&quot;&gt; &lt;li&gt;小米手机&lt;/li&gt; &lt;li&gt;红米&lt;/li&gt; &lt;li&gt;电视&lt;/li&gt; &lt;li&gt;笔记本&lt;/li&gt; &lt;li&gt;家电&lt;/li&gt; &lt;li&gt;新品&lt;/li&gt; &lt;li&gt;路由器&lt;/li&gt; &lt;li&gt;智能硬件&lt;/li&gt; &lt;/ul&gt; 方法三 在浮动元素的父级，通过伪对象的方式实现清除儿子项的浮动 12345父级元素::after&#123; content:&apos; &apos;; display:block; /*将当前元素转为块级标签*/ clear:both;&#125; 123456789101112131415161718192021&lt;style&gt; /* 完美点的 方法3 */ ul::before, ul::after&#123; content:&apos;&apos;; display:block; &#125; ul::after&#123; clear:both; &#125;&lt;/style&gt; ...&lt;ul&gt; &lt;li&gt;小米手机&lt;/li&gt; &lt;li&gt;红米&lt;/li&gt; &lt;li&gt;电视&lt;/li&gt; &lt;li&gt;笔记本&lt;/li&gt; &lt;li&gt;家电&lt;/li&gt; &lt;li&gt;新品&lt;/li&gt; &lt;li&gt;路由器&lt;/li&gt; &lt;li&gt;智能硬件&lt;/li&gt; &lt;/ul&gt; ​ 友情提示：浮动若不需要后面的元素向上填充，记得及时清除浮动 四.市场常用写法： 12345678.clearfix::before, .clearfix::after&#123; content:&apos; &apos;; display:block;&#125;.clearfix::after&#123; clear.both&#125;之后儿子项需要使用清除浮动，只需给父级赋予class=&quot;cleanfix&quot; 7.元素转换标签名：display 标签名： block 将当前元素转换为块级元素 （替换：独占一行，可应用宽高控制） .i2{width: 400px; height: 100px; background: skyblue; display: block;} inline 将当前元素转换为行级元素 （替换：无法使用宽高控制，不独占一行） .b1{width: 300px; height: 50px; background: pink; display: inline; } inline-block 将当前元素转换为内联-块元素（既不独占一行(block)，也可以应用宽高控制(inline)） .b3{width: 300px; height: 50px; background: pink; display: inline-block;} table 将当前元素转换为块级表格 table-cell 将当前元素转换为td单元格 none 将当前元素隐藏（不占位） .box1{width: 300px; height: 50px; background: lightgreen; display: none; visibility：hidden 将当前元素隐藏（占位） .box1{width: 300px; height: 50px; background:lightgreen; visibility: hidden;} 8.初始化​ 目的：各个浏览器对css样式的默认设定值不一定一样，为了保证代码在各个浏览器上显示的效果一致，所以需要对浏览器的默认css值重新统一设定，（也称初始化） ​ 主要初始化内容包括：默认内外边距（margin、padding），字体（font），项目符号（li），超链接（a下划线），表格等 9.网页布局主要使用：Div+Css 在布局中主要使用定位和浮动，为方便维护修改，推荐尽量使用浮动 布局规则： 由宏观到微观 先看行，再看列 由上至下，从左到右]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础-02]]></title>
    <url>%2F2017%2F10%2F22%2FCSS-02%2F</url>
    <content type="text"><![CDATA[1.背景属性名：background 子属性名： ​ background-color： 背景颜色 ​ background-image: 背景图片 属性值：url（’ 链接地址 ‘） ​ background-repeat: 背景重复 属性值：no-repeat | repeat-x |repeat-y |repeat（默认） ​ position: X Y 若x和y的值为正数，向右或下移动；若x和y 的值为负数，向左或上移动 ​ background-size： 背景大小 简写：background:[color | image | repeat | position[/size]] 注意：定位position尺寸必须放在size尺寸前面 10px 10px/200px 2.盒子阴影属性名：box-shadow 属性值：s1，s2，s3，s4，s5（color），s6（insert） s1 水平位移 可负值 s2 垂直位移 可负值 s3 模糊度 不能取负值，0为不模糊 s4 阴影面积 不能取负值，0为原大小，可以省略 s5 阴影颜色 内阴影 后加inset，可省略 box-shadow: -104px -97px 0px 0px blue inset; 简写：box-shadow:s1 s2 s3 [s4] s5 [s6;] 拓展： 移动当前元素到页面中间margin:100px auto; solid-实线 dashed-虚线 dotted-点状线 double-双实线 3.平滑过渡属性名：transition 属性值：s1，s2，s3，s4 s1 过渡的标签名（transition-property） ​ 取值：all（所有可以过渡的属性） none（不指定过渡的属性） &lt;标签名&gt; s2 过渡的持续时间（transition-duration） ​ 取值：&lt;持续时间&gt; 1 s = 1000 ms s3 过渡速率（transition-timing-function） ​ 取值：linear（线性） ease（平滑） ease[-in|-out]（缓入、缓出、缓入缓出） s4 延迟时间（transition-delay） 注意：transition能起作用的前提条件是该标签的属性值是可以进行 + / - 的值 eg：transition:a .5s ease / transition：all 1s ease ； / transition:p1,p2,p3 .5s ease 4.变形属性名：transform 属性值： none 不变形 rotate 旋转 单位：deg skew 扭曲 单位：deg skewX 指定水平方向扭曲 skewY 指定垂直方向扭曲 scale 中心缩放 单位：倍数 scaleX 水平缩放 单位：倍数 scaleY 垂直缩放 单位：倍数 translate 位移 单位：px translateX 指定x轴方向的位移 translateY 指定y轴方向的位移 注意：skew扭曲为90*奇数倍时，都会被扭曲成一条线，导致看不见 5.列表样式属性名：list-style 属性值： list-style-image 项目列表标记图像 none 不指定图像 &lt;url(‘ … ‘)&gt; 使用指定图像作为项目列表标记 list-style-position outside 标记放在文本外，且文本不依据标记对齐 inside 标记放置在文本内部，依据标记对其文本 list-style-type 项目列表标记类型 disc 实心圆（默认） circle 空心圆 square 实心方块 none 不适用项目符号 简写：list-style[list-style-image]|[list-style-position]|[list-style-type] 6.溢出属性名：overflow 包括overflow-x，和overflow-y 属性值： visible 不剪切（默认） hidden 将超出对象尺寸的内容进行裁剪，将不出现滚动条。 auto 将超出部分内容剪切，并以滚动条方式显示超出对象 常见属性 ​ width height ​ mingwidth maxheight ​ minheight maxheight 7.文本 text-indent: 首行缩进（也可控制图片）（单位：px ，%，em） text-align: 水平对齐方式（left center right）（对image标签也起作用） text-decoration 划线方式（underline overline line-through none blink） text-shadow 文本阴影 格式：text-shadow：h-shadow v-shadow blur color; text-overflow 溢出文本处理 属性值：clip 修建文本 属性值：ellipsis 使用省略号代替省略的文本ellipsis 强制转为一行：white-space:nowrap; 将溢出内容隐藏：overflow:hidden vertical-align 垂直对齐（top middle bottom） ​ （默认情况情况下，是对外垂直对齐） ​ （若对内对齐，则需要配合display属性） 将当前元素转为td单元display:table cell 垂直居中：line-height:500px; vertical-align:middle; 8.鼠标样式属性名：cursor（光标，指针） 属性值： ​ pointer 指向（手掌样式） ​ text 文本（大写的 i 字样式） ​ move 移动（十字箭头） ​ default 默认（鼠标指针） ​ none 隐藏箭头 补充：progress（正在进行）|wait（等待）|方向-size（双向箭头）|no-drop（无法拖动）|crosshair（十字准星） 9.字体图标 计算机中图片分为两类：位图、矢量图 位图：放大失真 矢量图：放大不失真 字体图标基本都是矢量图，可以使用字体的属性，但不能使用图片的属性 字体图标下载：阿里巴巴矢量图url（‘ https://www.iconfont.cn/ ’） 阿里字体图标使用： ​ 1.下载图标文件 ​ 2.导入iconfont.css文件 ​ 3.给需要使用字体图标的标签赋予class=”iconfont” ​ 4.给需要使用字体图标的位置填写相应的图标符号（查询demo_unicode.html文件）]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础-01]]></title>
    <url>%2F2017%2F10%2F15%2FCSS-01%2F</url>
    <content type="text"><![CDATA[1. css文件导入方式css的导入方式有四种： 内联式 ：在head头标签中，通过style标签书写css 使用场景：测试调试环境 格式 : 12345678&lt;head&gt;&lt;style&gt; p&#123; color:blue; text-indent:2em; &#125;&lt;/style&gt;&lt;/head&gt; 外链式 ：在head头标签中，通过link标签引入css文件 格式： 使用场景：正式上线 123&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./demo.css&quot;&gt;&lt;/head&gt; 导入式 ：在head头标签中，通过style标签引入css文件 先加载html，再加载css，卡顿时会出现先出现原始内容的情况 123&lt;style&gt; @import url(&apos;.demo.css&apos;)&lt;/style&gt; 注意：@import 必须写在style标签里面的最前面 ​ @import 的本行最后必须加上分号； 内嵌式 ：直接在开始标签中，通过style属性书写css 不推荐，优先级太高，可能打乱整体布局 1&lt;开始标签 style=&quot;属性名：属性值；属性名：属性值；&quot; 2. css基础语法书写格式： 12345选择器&#123; 属性名1：属性值； 属性名2：属性值； 属性名3：属性值； &#125; 注：css属性不区分大小写 css注释：/* 注释内容 */ 3. 颜色属性名：color 字体颜色 属性值： 单词 red white blue … #rgb 000~fff ​ r,g,b 的范围：09 af #rrggbb 000000~ffffff rgb(0255,0255,0~255) rgba(0255,0255,0255,01) 1a:透明度，可小数 hsla（h,s,l,a） 色轮值 h：色调 0~360 s：饱和度 % l：亮度 % a：透明度 0~1 属性名：opacity 透明度 属性值：0~1 可小数 4. 长度单位1绝对长度​ cm 厘米 ​ mm 毫米 ​ in 英寸 1 in=2.54 cm=25.4 mm 2相对长度​ px 像素 ​ em 倍数 ​ % 百分比 5. 基础选择器1 html四大通用属性style 样式 name 命名 class 类，绰号 id 身份码 2 基础选择器- 标签选择器：​ 格式：标签名{…} ​ 特性：匹配方位广，涉及整个body。适合做初始化 - 类选择器：​ 格式：.class名{…} ​ 特性：一个标签可以有多个class名 ​ 多个标签可以有相同的class名 - 身份选择器：​ 格式：#id名{…} ​ 特性：一个标签只能有一个id名，多个标签原则上不能有重复id css可以重复id，但js检查到重复id会报错 6. 选择器详解1.关联选择器 关联选择器：也叫关系选择器 ​ 设：s1,s2,s3,…为基础选择器 ​ 则： 1234s1 s1&#123; ... &#125; 匹配s1下的所有后辈s1&gt;s2&#123; ... &#125; 匹配s1下的所有儿子s2s1+s2&#123; ... &#125; 匹配s1后面的一个兄弟元素s2s1~s2&#123; ... &#125; 匹配s1后面的所有兄弟 2.组合选择器格式：s1，s2，s3，...，sn{ ... } 分别给s1, s2 和 s3等元素赋予相同的css样式 s1, s2等元素之间没有关系 3.伪类选择器格式：s1:hover{ ... } 效果：当鼠标悬停在s1上时，触发css样式 ​ 隔山打牛类： s1:hover s2{} ​ 当鼠标悬停在s1上时，s1下所有后辈s2触发css样式 s1:hover&gt;s2{} 当鼠标悬浮在s1上时，s1下的所有儿子s2触发css样式 s1:hover+s2 当鼠标悬浮在s1上时，s1后的一个兄弟元素s2触发css样式 s1:hover~s2 当鼠标悬停在s1上时，s1后的所有兄弟元素s2触发css样式 引申级 s1:first-child{...} 找s1父级下的第一个标签，若是s1，应用css样式 s1:first-of-type{...} 找到s1父级下的第一个标签，应用css样式 s1:last-child{...} 找s1父级下的最后一个标签，若是s1，应用css样式 s1:last-of-type{...} 找到s1父级下的最后一个标签，应用css样式 s1:nth-child{...} 找s1父级下的指定顺序的标签，若是s1，应用css样式 s1:nth-of-type{...} 找到s1父级下的指定顺序的标签，应用css样式 nth属性值 ​ 单词：奇数（odd） 偶数（even） ​ 公式：一元一次方程（2n）（2n+1）（3n+5） 4.伪对象选择器 s1::before{...}在s1里面内容的最前面 s1::after{...} 在s1里面内容的最后面 content 配合before，代表内容 before和after配合将来的浮动技术做布局使用 7. 优先级各标签权重值： ​ 标签名：1 class名：10 id名：100 优先级规则： ​ 权重值越大，优先级越高 ​ 权重值相同，离标签越近的选择器，优先级越高 权重值可以叠加 最高权重： ​ 没有具体值，只是一种象征 ​ 格式：属性值 !important 继承性： ​ 许多标签都可以继承祖辈的大多数属性，会有小部分属性无法继承 ​ 例如： ​ a标签的颜色 ​ h标签的大小 ​ 。。。 组合选择器前后权重不会叠加，互不影响 8. 边框1 border属性名：border 属性值：方向（top bottom left right） 单边： border-方向-color： 边框单边颜色 ​ border-方向-width： 边框单边宽度 ​ border-方向-style： 边框单边线显示（solid）或关闭（none） 简写：border-方向：[color|width]|style 四边：border-color： 边框四边颜色 ​ border-width： 边框四边宽度 ​ border-style： 边框四边线显示/关闭 简写：border：[color|width]|style 注意：单边和四边属性中，style属性必须设置，简写没有先后顺序要求 2 radius属性名：border-radius 圆角 属性值：px，% ​ border-上下-左右-radius： 单边圆角 3 collapse属性名：border-collapse 边框合并（一般用于表格） 属性值：collapse 4 outline属性名：outline 外轮廓 属性值：与border相同，常用none，取消外轮廓 9. 字体属性名：font 属性值： font-size： 字体大小 不同浏览器最小值不一样，竟可能不要触碰最小值 font-family: 字体家族 必须本地存在该字体，浏览器才可以使用 font-weight： 字体加粗 属性值：加粗（bold）或 普通（normal） font-style： 字体倾斜 属性值：斜体（italic）或 普通（naomal） line-height: 行高 line-height 若设置为与当前元素的高度一致，怎显示垂直居中效果（仅限一行） 简写：font：size familyfont:[weight\style] size [/line-height] family; 注意：font属性至少要写 size 和 family，且 font 属性中 size 必须在family的前面 手册常用公式写法： ​ | 选择左侧或者右侧或者两者都选，前后顺序无要求 ​ [ ] 中括号内部的值可写可不写]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML (基本02)]]></title>
    <url>%2F2017%2F09%2F27%2Fhtml%20-02%2F</url>
    <content type="text"><![CDATA[二.HTML (基本02)1. 多媒体标签1.图片标签标签名： img 属性： 123456789src 图片来源地址 width 图片宽度调节height 图片高度调节title 鼠标悬停显示文本alt 图片加载失败替代文本 注意：高度属性和宽度属性一般不同时使用，避免影响图片固有宽高比。 计算机常用长度单位：px （像素） 1&lt;img src=&quot;图片路径&quot; width=&quot;20px&quot; title=&quot;picture&quot; alt=&quot;~&quot; 2.音频标签标签名： audio 属性： 1234src 音频来源路径controls 控制器loop 循环播放autoplay 自动播放 12&lt;audio src=&quot;音频路径&quot; controls loop autoplay&gt;音频播放异常&lt;/audio&gt; 媒介标签——source 12345&lt;audio controls&gt; &lt;source src=&quot;./music.mp3&quot;&gt; &lt;source src=&quot;./music.amv&quot;&gt; &lt;source src=&quot;./music.fac&quot;&gt;&lt;/audio&gt; 媒介标签提供了一种可能：当所用浏览器不支持某种格式的音频时，有替代格式的同一音频可以正常播放。 3.视频标签标签名： video 属性： 123456src 视频来源地址controls 控制器weight 视频宽度height 视频高度loop 循环播放autoplay 自动播放 1&lt;video src=&quot;视频地址&quot; wieght=&quot;200&quot; controls loop autoplay&gt; 媒介标签——source 12345&lt;video controls&gt; &lt;source src=&quot;./video.mp4&quot;&gt; &lt;source src=&quot;./video.flv&quot;&gt; &lt;source src=&quot;./video.avi&quot;&gt;&lt;/video&gt; 媒介标签提供了一种可能：当所用浏览器不支持某种格式的音频时，有替代格式的同一音频可以正常播放。 4.地址路径计算机文件路径分为 绝对路径 和 相对路径 。 相对路径​ . 当前路径，默认 ​ .. 上一级路径 1234567&lt;img src=&quot;1.jpg&quot;&gt;&lt;img src=&quot;./1.jpg&quot;&gt;&lt;!--以上均为在当前目录下寻找1.jpg文件--&gt;&lt;img src=&quot;../1.jpg&quot;&gt;&lt;img src=&quot;../../1.jpg&quot;&gt;&lt;!--以上两个分别为在上层目录和上上层目录中寻找1.jpg--&gt; 绝对路径盘符式： x:/…/…/… 网址式： http://…/…/… 根目录： /…/…/… 此处的根目录，在wamp中代表www目录 123&lt;img src=&quot;D:/wamp/www/3.jpg&quot;&gt;&lt;img src=&quot;http://localhost/3.jpg&quot; width=&quot;300&quot;&gt;&lt;img src=&quot;/3.jpg&quot; width=&quot;300&quot;&gt; 5.表单声明 表单—常用于和用户做交互 标签名： form（表单声明标签） 属性： 1234567891011121314151617action 指定一个地址，将表单内容提交给服务器 若属性值为空，则默认提交给自己method 指定页面内容传输方式； get 明文传输，为默认传输方式； （查） 速度快，但安全性较低； 传输大小在http协议上没有限制， 实际上受到浏览器限制, 大多数&lt;2KB = 2048 B； post 密文传输； （增删改） 速度相对get要慢，但安全性高； 传输大小在http协议上没有限制， 实际上受到服务器限制；enctype = &quot;multipart/form-date&quot; 专用于提交文件给服务器 使用 12345&lt;form action=&quot;http://www.baidu.com/s&quot; method=&quot;post&quot;&gt; 百度：&lt;input type=&quot;text&quot; name=&quot;word&quot;&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 6.表单标签 标签名： input 特殊属性： name 给当前标签命名，只有命名之后，服务器才能知道接收的信息属于谁。一般情况下，所有的表单都需要name。 value 给当前标签赋予默认值，其中可手动输入标签，value值可写可不写，不可手动输入标签必须写入value值。 常用属性： type 1234567891011121314type属性值： text 文本域，默认 password 密码域（输入不可见） radio 单选（配合name使用） checkbox 多选 email 邮箱（确保输入&quot;xxx@xxx&quot;格式） number 数字（只能输入数字） url 地址（确保输入&quot;xxx://xxx&quot;格式） date 日期选择 file 文件提交 hidden 隐藏域 search 搜索 submit 提交 button 按钮（必须配合js使用） 12345678910111213141516171819202122232425262728293031323334&lt;form action=&quot;./demo.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-date&quot;&gt;默认文本框：&lt;input&gt; &lt;br&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot; value=&quot;id&quot;&gt;&lt;br&gt;密码：&lt;input type=&quot;password&quot; name=&quot;psd&quot;&gt;&lt;br&gt;手机号：&lt;input type=&quot;number&quot; name=&quot;tel&quot;&gt;&lt;br&gt;性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;man&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女 &lt;br&gt;爱好:&lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&quot;book&quot;&gt;book &lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&quot;sports&quot;&gt;sports &lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&quot;game&quot;&gt;game &lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&quot;bike&quot;&gt;bike &lt;br&gt;&lt;!--checkbox要将name值后补上[]，才能形成真正的多选 --&gt;邮箱：&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;&lt;br&gt;生日:&lt;input type=&quot;date&quot; name=&quot;birthday&quot;&gt;&lt;br&gt;搜索：&lt;input type=&quot;search&quot; name=&quot;search&quot;&gt;&lt;br&gt;头像：&lt;input type=&quot;file&quot; name=&quot;icon&quot;&gt;&lt;br&gt;&lt;!--上传文件的3个必要条件--&gt;&lt;!-- 1.file表单必须要有name属性 2.form表单的属性method=post 3.form表单的属性enctype=multipart/form-date--&gt;隐藏域：&lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;0328&quot;&gt;&lt;br&gt;URL:&lt;input type=&quot;url&quot; name=&quot;url&quot;&gt;&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;&quot;&gt;&lt;br&gt;&lt;!--默认为提交--&gt;按钮：&lt;input type=&quot;button&quot; value=&quot;insure&quot;&gt;&lt;/form&gt; 其中由于默认文本框中标签未添加name属性，提交后无法查看相应内容，更改为&lt;input name=&quot;default&quot;&gt;后提交可正常显示 2. 表单1.下拉框表单标签声明标签： select ​ 属性： name 字内容标签： option ​ 属性：value option标签若没有value值则会将正文内容提交给服务器 1234567891011户籍： &lt;select name=&quot;address&quot;&gt; &lt;option&gt;choice&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;shanghai&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;zhejiang&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;jiangsu&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;shadong&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;hunan&lt;/option&gt; &lt;option value=&quot;6&quot;&gt;hubei&lt;/option&gt; &lt;option value=&quot;7&quot;&gt;jiangxi&lt;/option&gt; &lt;/select&gt; 2.快捷键快捷键： 123456789101112131415161718192021222324快捷键： ctrl + c 光标只要在当前行即可 ctrl + v 马上在上一行进行粘贴 ctrl + shift + d 复制当前行到下一行 ctrl + x 删除（本质为剪切） ctrl + alt + 方向键 快速选中 同列光标 ctrl + / 快速注释 emmet插件快速编写类似html标签： $ 索引， 本质就是数字，默认从1开始 $@num 索引， 默认从num开始计数 * 乘以几次，重复几次，出现几个标签 [] 属性 [属性名=属性值] &#123;&#125; 正文内容 实例 12345678910111213141516171819202122&lt;select name=&quot;test&quot;&gt; &lt;!-- option&#123;$&#125;*5 --&gt; &lt;option value=&quot;&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;&quot;&gt;3&lt;/option&gt; &lt;option value=&quot;&quot;&gt;4&lt;/option&gt; &lt;option value=&quot;&quot;&gt;5&lt;/option&gt; &lt;!-- option[value=$]*5 --&gt; &lt;option value=&quot;1&quot;&gt;&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;&lt;/option&gt; &lt;!-- option[value=$]&#123;$@1990&#125;*5 --&gt; &lt;option value=&quot;1&quot;&gt;1990&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;1991&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;1992&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;1993&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;1994&lt;/option&gt;&lt;/select&gt; 3.多文本域标签名： texterea ​ 属性: rows —— 行 ​ cols —— 列 之前input，select 默认值都是valuetextarea 的默认值是正文内容，而非value &lt;textarea rows=&quot;5&quot; cols=&quot;50&quot;&gt;&lt;/textarea&gt; 4.button标签12345&lt;form action=&quot;&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt; &lt;button&gt; button按钮&lt;/button&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; form表单中的独立button按钮，默认值也是正文内容 默认效果是将表单内容提交给服务器（同type-submit） 后期更多是配合js，实现更多的效果。 注意：不同于input标签下的type属性值 &lt;input type=&quot;button&quot; value=&quot;提交&quot;&gt; 5.表单常用属性常见属性： 12345678910111213placeholder 背景虚化字minlength 输入值最小长度maxlength 输入值最大长度autofocus 自动获取光标autocomplete 自动提示历史记录 —— on 开启，默认 —— off 关闭required 输入不能为空checked 单选/复选默认勾选项selected 下拉框默认显示项readonly 只读，只能看不能改，提交给服务器disabled 禁用，只能看不能改，不能提交给服务器multiple 开启多选选项 6.头标签设置1234567891011121314151617181920212223&lt;!-- 1.设置编码 &lt;meta charset=&quot;UTF-8&quot;&gt; --&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;!-- 2.设置标题 &lt;title&gt;&lt;/title&gt; --&gt;&lt;title&gt;head标签&lt;/title&gt;&lt;!-- 3.搜索引擎关键字 --&gt;&lt;meta name=&quot;keywords&quot; content=&quot;keyword1,keyword2,...&quot;&gt;&lt;!-- 4.设置描述 --&gt;&lt;meta name=&quot;description&quot; content=&quot;描述内容&quot;&gt;&lt;!-- 5.网页重定向 --&gt;&lt;!-- &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=./041.html&quot; --&gt;&lt;!-- 6.导入css --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./demo.css&quot;&gt;&lt;!-- 7.导入js --&gt;&lt;script src=&quot;./demo.js&quot;&gt;&lt;/script&gt;&lt;!-- 8.导入icon图标 --&gt;&lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot;&gt; 7.表格表格声明： table 表格标题： caption ​ 表行： tr table row ​ 表头： th table head 表格描述： td table description 设计：先看行，再看列 属性： 1234567891011border 边框宽度 cellspacing 外边距（单元格之间的距离） cellpadding 内边距（单元格与内容之间的距离） width 表格宽度 height 表格高度 colspan 列合并 rowspan 行合并 align 水平对齐：（left/center/right） valign（vertical） 垂直对齐：（top/middle/bottom） bgcolor 背景颜色 background 背景图片 8.下拉框表单标签声明标签： select ​ 属性： name 字内容标签： option ​ 属性：value option标签若没有value值则会将正文内容提交给服务器 1234567891011户籍： &lt;select name=&quot;address&quot;&gt; &lt;option&gt;choice&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;shanghai&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;zhejiang&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;jiangsu&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;shadong&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;hunan&lt;/option&gt; &lt;option value=&quot;6&quot;&gt;hubei&lt;/option&gt; &lt;option value=&quot;7&quot;&gt;jiangxi&lt;/option&gt; &lt;/select&gt; 9.快捷键快捷键： 123456789101112131415161718192021222324快捷键： ctrl + c 光标只要在当前行即可 ctrl + v 马上在上一行进行粘贴 ctrl + shift + d 复制当前行到下一行 ctrl + x 删除（本质为剪切） ctrl + alt + 方向键 快速选中 同列光标 ctrl + / 快速注释 emmet插件快速编写类似html标签： $ 索引， 本质就是数字，默认从1开始 $@num 索引， 默认从num开始计数 * 乘以几次，重复几次，出现几个标签 [] 属性 [属性名=属性值] &#123;&#125; 正文内容 实例 12345678910111213141516171819202122&lt;select name=&quot;test&quot;&gt; &lt;!-- option&#123;$&#125;*5 --&gt; &lt;option value=&quot;&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;&quot;&gt;3&lt;/option&gt; &lt;option value=&quot;&quot;&gt;4&lt;/option&gt; &lt;option value=&quot;&quot;&gt;5&lt;/option&gt; &lt;!-- option[value=$]*5 --&gt; &lt;option value=&quot;1&quot;&gt;&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;&lt;/option&gt; &lt;!-- option[value=$]&#123;$@1990&#125;*5 --&gt; &lt;option value=&quot;1&quot;&gt;1990&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;1991&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;1992&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;1993&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;1994&lt;/option&gt;&lt;/select&gt; 10.多文本域标签名： texterea ​ 属性: rows —— 行 ​ cols —— 列 之前input，select 默认值都是valuetextarea 的默认值是正文内容，而非value &lt;textarea rows=&quot;5&quot; cols=&quot;50&quot;&gt;&lt;/textarea&gt; 11.button标签12345&lt;form action=&quot;&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt; &lt;button&gt; button按钮&lt;/button&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; form表单中的独立button按钮，默认值也是正文内容 默认效果是将表单内容提交给服务器（同type-submit） 后期更多是配合js，实现更多的效果。 注意：不同于input标签下的type属性值 &lt;input type=&quot;button&quot; value=&quot;提交&quot;&gt; 12.表单常用属性常见属性： 12345678910111213placeholder 背景虚化字minlength 输入值最小长度maxlength 输入值最大长度autofocus 自动获取光标autocomplete 自动提示历史记录 —— on 开启，默认 —— off 关闭required 输入不能为空checked 单选/复选默认勾选项selected 下拉框默认显示项readonly 只读，只能看不能改，提交给服务器disabled 禁用，只能看不能改，不能提交给服务器multiple 开启多选选项 13.头标签设置1234567891011121314151617181920212223&lt;!-- 1.设置编码 &lt;meta charset=&quot;UTF-8&quot;&gt; --&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;!-- 2.设置标题 &lt;title&gt;&lt;/title&gt; --&gt;&lt;title&gt;head标签&lt;/title&gt;&lt;!-- 3.搜索引擎关键字 --&gt;&lt;meta name=&quot;keywords&quot; content=&quot;keyword1,keyword2,...&quot;&gt;&lt;!-- 4.设置描述 --&gt;&lt;meta name=&quot;description&quot; content=&quot;描述内容&quot;&gt;&lt;!-- 5.网页重定向 --&gt;&lt;!-- &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=./041.html&quot; --&gt;&lt;!-- 6.导入css --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./demo.css&quot;&gt;&lt;!-- 7.导入js --&gt;&lt;script src=&quot;./demo.js&quot;&gt;&lt;/script&gt;&lt;!-- 8.导入icon图标 --&gt;&lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot;&gt; 14.表格表格声明： table 表格标题： caption ​ 表行： tr table row ​ 表头： th table head 表格描述： td table description 设计：先看行，再看列 属性： 1234567891011border 边框宽度 cellspacing 外边距（单元格之间的距离） cellpadding 内边距（单元格与内容之间的距离） width 表格宽度 height 表格高度 colspan 列合并 rowspan 行合并 align 水平对齐：（left/center/right） valign（vertical） 垂直对齐：（top/middle/bottom） bgcolor 背景颜色 background 背景图片 3. 布局1.大分帧 大分帧：frameset （在 html5 中已经淘汰，但很多较老的网页还在用大分帧布局） （frameset 与 body 标签不能共存） 标签名： frameset 设置窗口（分帧） 格式： 123456&lt;frameset rows=&quot;x%,x%&quot;&gt; &lt;frameset col=&quot;x%,x%&quot;&gt; &lt;frame&gt; &lt;frame&gt; &lt;frame&gt; &lt;frame&gt;&lt;/frameset&gt; &lt;/frameset&gt;&lt;!--可以嵌套使用，嵌套时，将下次要分频的frame标签替换为frameset--&gt; 属性： rows 行分 ​ cols 列分 ​ * 剩余空间 ​ noresize 固定分频区域 ​ frameborder 分频边框关闭(=0)或开启(非0) 子标签名： frame 窗口（分帧） 属性： src 窗口内容来源地址 ​ name 给当前窗口命名 ​ scrolling 设置滚动条启用(=yes)或禁用(=no) 12345678&lt;!-- 设置上，下（左，右）分频，并自定义内容--&gt;&lt;frameset rows=&quot;10%,90%&quot; noresize frameborder=&quot;1&quot;&gt; &lt;frame src=&quot;./topPage.jpg&quot; name=&quot;top&quot; scrolling=&quot;no&quot;&gt; &lt;frameset cols=&quot;20%,*&quot;&gt; &lt;frame src=&quot;xxx.html&quot; name=&quot;left&quot; scrolling=&quot;no&quot;&gt; &lt;frame src=&quot;xxx.html&quot; name=&quot;right&quot;&gt; &lt;/frameset&gt;&lt;/frameset&gt; 2.小分帧标签名： iframe 属性 ： scrolling 滚动条（yes/no） ​ src 引用来源 ​ width 小分帧宽度 ​ height 小分帧高度 ​ frameborder 小分帧边框显示（0/非0） ​ name 给小分帧命名 格式： 12&lt;iframe src=&quot;广告来源地址&quot; scrolling=&quot;no&quot; width=&quot;500&quot; height=&quot;200&quot; frameborder=&quot;no&quot;&gt;&lt;/iframe&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML (基本01)]]></title>
    <url>%2F2017%2F09%2F21%2Fhtml%20-01%2F</url>
    <content type="text"><![CDATA[一.HTML (基本01)准备工作 1.常见的几种文件类型： *.html *.css *.js *.php *.sql 2.wamp存放位置：~/wamp/www/ 3.运行：打开wamp ​ 打开浏览器 ​ 地址栏输入localhost 1.HTML简介12345678910&lt;!DOCTYPE html&gt; &lt;!--声明--&gt;&lt;html lang=&quot;en&quot;&gt; &lt;!--语言--&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!--编码--&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 正文内容&lt;/body&gt;&lt;/html&gt; ​ 以上为基本的一段html代码，包含版本声明，编码，标题，其中全局架构标签为html，head，body。body标签内部的才是文字，图片，音视频等内容需要占用的位置。 编码： 计算机早期, 世界只有ASCII编码, 只有128个, 不认识汉语, 韩语, 日语新一代的编码 Unicode编码, 支持世界上绝大多数的语言, 数字, 字母, 标点, 汉字等都占4个字节升级版 UTF-8 编码 (万国码), 数字,字母,标点占1B, 汉字占3B 2.基本语法①.全局架构标签 html head body ②.注释注释是对代码的描述，不会显示在页面上，但可以增加代码的可读性 格式： 注意：不能嵌套使用 ③.标签格式网页全部是由标签组成的，标签分为两种： 单标签：&lt;开始标签/&gt; 如:&lt;br/&gt;,&lt;hr/&gt;,&lt;img/&gt;,&lt;meta/&gt; 双标签：&lt;开始标签&gt;正文内容&lt;结束标签/&gt; 如： &lt;p&gt; &lt;/p&gt; ④.标签属性格式：&lt;开始标签 属性名=“属性值” 属性名=“属性值” ...&gt; 标签属性写在标签内部，每对属性之间至少保留一个空格 标签名和属性名不区分大小写 3.浏览器特性1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;cn&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;浏览器特性&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;浏览器特性&lt;/h1&gt; &lt;hr&gt; 亚洲有四大邪术: 日本的化妆术 韩国的整容术 泰国的变性术 中国的PS术&lt;/body&gt;&lt;/html&gt; 虽然在代码中进行了排版，但实际效果是： 注意：浏览器中，任何多的空格和回车，要么不解析，要么解析为一个空格，利用这个特性，可以在代码中做好排版和注释。 一个职业程序员，应该有良好的注释习惯及排版审美 4.文本格式标签①.标题标签&lt;h1&gt;标题&lt;/h1&gt; 从&lt;h1&gt;到&lt;h6&gt;,标题格式由高层级向低层级转化。一般常用的为h1到h4 其中h1标签在一个页面中最好只用一次，因为h1可以用于提高搜索排名，而使用两次及以上，则会被搜索引擎拉入黑名单。 ②.段落标签&lt;p&gt;正文&lt;/p&gt; 在p标签中的文字，为一个段落。不同段间上下行间间距较大，自动换行 ③.样式标签 &lt;b&gt;bold&lt;/b&gt; 加粗 &lt;i&gt;italic&lt;/i&gt; 倾斜 &lt;u&gt;underline&lt;/u&gt; 下划线 &lt;del&gt;delete&lt;/del&gt; 删除线 只负责表面样式，不具备实际意义。 ④.语义化标签 &lt;strong&gt; strong&lt;/strong&gt; 强调 &lt;em&gt;emphasize&lt;/em&gt; 加强 不仅负责表面样式，还具备方便浏览器解析的特性 ⑤.上、下标 x&lt;sup&gt;2&lt;/sup&gt; 上标 x2 CO&lt;sub&gt;2&lt;/sub&gt; 下标 CO2 ⑥.原样输出 &lt;pre&gt; &lt;/pre&gt; 保持代码样式格式输出 5.列表标签场景: 一排排 or 一列列长的差不多, 样式相似, 都可以用列表 有序列表ol（ordered list） 1234567《回乡偶书》 &lt;ol&gt; &lt;li&gt;瘦小离家老大回&lt;/li&gt; &lt;li&gt;乡音未改肉成堆&lt;/li&gt; &lt;li&gt;儿童相见不相识&lt;/li&gt; &lt;li&gt;请问胖子你是谁&lt;/li&gt; &lt;/ol&gt; 无序列表ul（UNordered list） 1234567《静夜思》 &lt;ul&gt; &lt;li&gt;窗前明月光&lt;/li&gt; &lt;li&gt;地上鞋两双&lt;/li&gt; &lt;li&gt;一对狗男女&lt;/li&gt; &lt;li&gt;其中就有你&lt;/li&gt; &lt;/ul&gt; 定义列表dl（defined list） 123456&lt;dl&gt; &lt;dt&gt;帮助中心&lt;/dt&gt; &lt;dd&gt;账户管理&lt;/dd&gt; &lt;dd&gt;购物指南&lt;/dd&gt; &lt;dd&gt;订单操作&lt;/dd&gt; &lt;/dl&gt; 在实际开发中, ul 使用频率比较 ol 高, 原因是ul解析不用排序，速度比ol快一点 6.实体符号 基本格式： &amp;符号代码； 空格 &amp;nbsp； 小于 &amp;lt； &lt; 大于 &amp;gt； &gt; 版权 &amp;copy； © 人民币 &amp;yen； ¥ 其余实体符号具体参考实体符号速查表 符号代码 释义 表现 &amp;hearts; 爱心 &hearts; &amp;euro; 欧元 &euro; &amp;frac25; 分数 &frac25; &amp;uarr; 向上箭头 &uarr; &amp;larr; 向左箭头 &larr; 7.超链接 标签名：a 属性： href 链接地址 target 在制定窗口打开链接 _self 在本窗口打开链接，默认 _blank 在新的空白页打开链接 _top 在顶级窗口打开链接 自定义name窗口 注意点：链接地址为协议+域名，若不写地址，则默认跳转到当前页面 任意一个地址只会对应一个文件 在任意目录下，命名为 index.html 或者 index.php 的文件，访问该目录时会自动执行index文件。 URL：网址 在完整地址中，第一个？是文件与参数的分隔符 参数 格式：参数名1=”参数值1” 参数名1=”参数值1” 多个参数之间有&amp;隔开 锚点 格式： #锚点名 必须在锚点名前加#号 1&lt;a href=&quot;http://www.xxx.com:80/image/av/a.jpg?name=yuhan&amp;age=18#xxoo&quot;&gt; 瞎编的完整地址 &lt;/a&gt; 8.锚点作用：跳转至某一页面或者某一节点 步骤： ​ 1.确定锚点：HTML4 name=”锚点名” ​ HTML5 id=”锚点名” ​ 2.跳转到锚点： ​ &lt;a href=&quot;url+#锚点名&quot;&gt;点击跳转&lt;/a&gt; 注意点：链接地址为协议+域名，若不写地址，则默认跳转到当前页面 baidu]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>
